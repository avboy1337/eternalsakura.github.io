<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="Sakuraのblog" type="application/atom+xml" />






<meta name="description" content="环境配置 下载bochs2.6.2  安装依赖 1234sudo apt-get install build-essentialsudo apt-get install xorg-devsudo apt-get install bisonsudo apt-get install libgtk2.0-dev  编译 12345678.&#x2F;configure \--prefix&#x3D;&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel base">
<meta property="og:url" content="http://eternalsakura13.com/2020/09/14/kernel_base/index.html">
<meta property="og:site_name" content="Sakuraのblog">
<meta property="og:description" content="环境配置 下载bochs2.6.2  安装依赖 1234sudo apt-get install build-essentialsudo apt-get install xorg-devsudo apt-get install bisonsudo apt-get install libgtk2.0-dev  编译 12345678.&#x2F;configure \--prefix&#x3D;&amp;#">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-015421.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-015533.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-020039.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-020729.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-020925.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-021921.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081136.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081159.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081216.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081247.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081307.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081326.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081622.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081435.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081529.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-144639.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-071822.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-031935.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-031955.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-032043.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-075746.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081435.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-084838.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-084949.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-090633.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-090652.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-090702.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-090852.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-094553.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-100151.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-101706.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-144639.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-150310.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-150440.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-155659.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-16-065554.jpg">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-151035.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-16-074306.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-16-074936.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163533.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163702.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163843.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163820.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163925.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163942.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163744.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-164032.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-164112.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-165042.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-171300.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-171321.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-171337.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-105049.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-153257.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-155326.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-155659.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-155713.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-26-040146.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-022428.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-072144.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-085846.jpg">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-085529.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-085548.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-090904.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-160520.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-161949.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-162015.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-28-020347.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-28-140953.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-28-145521.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-28-152958.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-08-091322.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-08-125633.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-09-083104.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-024803.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-025318.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-031120.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-031255.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-091535.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-092415.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-093325.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-094929.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-105644.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-022723.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-081948.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-081933.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-030932.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-071244.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-071848.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-072315.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-073140.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-020617.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-023432.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-025718.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-032445.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-032631.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-094754.png">
<meta property="article:published_time" content="2020-09-14T15:53:43.514Z">
<meta property="article:modified_time" content="2020-10-14T09:47:58.368Z">
<meta property="article:author" content="sakura">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-015421.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'QOPH9ID41Z',
      apiKey: '',
      indexName: 'sakura',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://eternalsakura13.com/2020/09/14/kernel_base/"/>





  <title>kernel base | Sakuraのblog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113420358-1', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sakuraのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-buglist">
          <a href="/buglist/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            BugList
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2020/09/14/kernel_base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sakura_heart.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">kernel base</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-14T23:53:43+08:00">
                2020-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index">
                    <span itemprop="name">kernel</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/14/kernel_base/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/14/kernel_base/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/09/14/kernel_base/" class="leancloud_visitors" data-flag-title="kernel base">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol>
<li><p>下载bochs2.6.2</p>
</li>
<li><p>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install xorg-dev</span><br><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install libgtk2.0-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure \</span><br><span class="line">--prefix&#x3D;&#x2F;home&#x2F;sakura&#x2F;kernel_learn&#x2F;bochs-2.6.2 \</span><br><span class="line">--enable-debugger \</span><br><span class="line">--enable-disasm \</span><br><span class="line">--enable-iodebug \</span><br><span class="line">--enable-x86-debugger \</span><br><span class="line">--with-x \</span><br><span class="line">--with-x11</span><br></pre></td></tr></table></figure>
<p>找到Makefile文件LIBS =这句最后面添加上-lpthread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBS &#x3D;  -lm -lgtk-x11-2.0 -lgdk-x11-2.0 -lpangocairo-1.0 -latk-1.0 -lcairo -lgdk_pixbuf-2.0 -lgio-2.0 -lpangoft2-1.0 -lpango-1.0 -lgobject-2.0 -lglib-2.0 -lfontconfig -lfreetype -lpthread</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写配置文件，放在<code>/home/sakura/kernel_learn/bochs-2.6.2/bin</code>路径下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Configuration file for Bochs</span><br><span class="line"># 设置Bochs在运行过程中能够使用的内存: 32 MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 设置真实机器的BIOS和VGA BIOS</span><br><span class="line"># 修改成你们对应的地址</span><br><span class="line"></span><br><span class="line">romimage: file&#x3D;&#x2F;home&#x2F;sakura&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;share&#x2F;bochs&#x2F;BIOS-bochs-latest</span><br><span class="line">vgaromimage: file&#x3D;&#x2F;home&#x2F;sakura&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;share&#x2F;bochs&#x2F;VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 设置Bochs所使用的磁盘</span><br><span class="line"># 设置启动盘符</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输出</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 开启或关闭某些功能，修改成你们对应的地址</span><br><span class="line">mouse: enabled&#x3D;0</span><br><span class="line">keyboard:keymap&#x3D;&#x2F;home&#x2F;sakura&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;share&#x2F;bochs&#x2F;keymaps&#x2F;x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 硬盘设置</span><br><span class="line">ata0: enabled&#x3D;1, ioaddr1&#x3D;0x1f0, ioaddr2&#x3D;0x3f0, irq&#x3D;14</span><br><span class="line"></span><br><span class="line"># 增加gdb支持，这里添加会报错，暂时不需要</span><br><span class="line"># gdbstub: enabled&#x3D;1, port&#x3D;1234, text_base&#x3D;0, data_base&#x3D;0, bss_base&#x3D;0</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试，步骤如图<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-015421.png" alt=""></p>
</li>
<li><p>增加硬盘,修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;bximage -hd -mode&#x3D;&quot;flat&quot; -size&#x3D;60 -q hd60M.img</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;增加这句</span><br><span class="line">ata0-master: type&#x3D;disk, path&#x3D;&quot;hd60M.img&quot;, mode&#x3D;flat, cylinders&#x3D;121, heads&#x3D;16, spt&#x3D;63</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-015533.png" alt=""></p>
</li>
<li><p>再次启动测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-020039.png" alt=""></p>
</li>
</ol>
<h2 id="编写BootLoader"><a href="#编写BootLoader" class="headerlink" title="编写BootLoader"></a>编写BootLoader</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><p>实模式<br>Intel 8086有20条地址线，其可表示的内存范围是1M，也就是0x00000-0xfffff，实模式下的1MB内存布局如下，其中0～0x9FFFF处是DRAM，即动态随机访问内存，我们所装的物理内存就是DRAM，如DDR、DDR2等。顶部的0xF0000～0xFFFFF，这64KB的内存是ROM。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-020729.png" alt=""><br>所以CPU根据不同的地址映射，访问到不同的设备<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-020925.png" alt=""></p>
</li>
<li><p>BIOS<br>BIOS即输入输出系统，是按下主机键之后第一个运行的软件，其主要工作有</p>
</li>
</ol>
<ul>
<li>调用检测、初始化硬件功能</li>
<li>建立中断向量表(IVT)<ul>
<li>用于外设访问</li>
</ul>
</li>
<li>校验启动盘中位于0盘0道1扇区的内容<ul>
<li>如果此扇区末尾的两个字节分别是魔数 0x55 和 0xaa，BIOS便认为此扇区中确实存在可执行的程序，也就是MBR</li>
<li><strong>注意CHS方式的磁盘并没有0扇区，所以它就是磁盘上最开始的那个扇区</strong></li>
</ul>
</li>
<li>加载MBR（主引导程序）到0x7c00，并跳转过去。<ul>
<li>MBR的大小是512字节</li>
</ul>
</li>
</ul>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-021921.png" alt=""><br>实模式下CS等段寄存器里保存段基址，CPU加电之后，cs:ip 寄存器被强制初始化为 0xF000:0xFFF0，其访问<code>0xF000 &lt;&lt; 4 + 0xFFF0</code>，也就是0xFFFF0，这就是BIOS的入口地址。<br>这个起始地址距离1MB内存只有16字节大小，所以这里肯定不是真正实现BIOS的地方，这里肯定只是一个类似于函数索引表的跳板，跳转到真正执行BIOS的地方。</p>
<ol start="3">
<li>分段地址管理</li>
</ol>
<ul>
<li><p>总览<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081136.png" alt=""></p>
</li>
<li><p>段寄存器<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081159.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081216.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081247.png" alt=""></p>
</li>
<li><p>段描述符和描述符表<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081307.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081326.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081622.png" alt=""></p>
</li>
<li><p>寻址<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081435.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081529.png" alt=""></p>
</li>
</ul>
<ol start="4">
<li>分页存储管理<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-144639.png" alt=""></li>
</ol>
<h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><ol>
<li>首先启动BIOS并让其加载一个简单的打印程序到内存的0x7c00执行<br>显卡的内存布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">起始	结束	大小	用途</span><br><span class="line">C0000	C7FFF	32KB	显示适配器BIOS</span><br><span class="line">B8000	BFFFF	32KB	用于文本模式显示适配器</span><br><span class="line">B0000	B7FFF	32KB	用于黑白显示适配器</span><br><span class="line">A0000	AFFFF	64KB	用于彩色显示适配器</span><br></pre></td></tr></table></figure>
操作显卡显示文本<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;主引导程序 </span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="meta">SECTION</span> MBR vstart=<span class="number">0x7c00</span>         </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>      </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">fs</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0x7c00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清屏 利用0x06号功能，上卷全部行，则可清屏。</span></span><br><span class="line"><span class="comment">; -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span></span><br><span class="line"><span class="comment">;------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入：</span></span><br><span class="line"><span class="comment">;AH 功能号= 0x06</span></span><br><span class="line"><span class="comment">;AL = 上卷的行数(如果为0,表示全部)</span></span><br><span class="line"><span class="comment">;BH = 上卷行属性</span></span><br><span class="line"><span class="comment">;(CL,CH) = 窗口左上角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;(DL,DH) = 窗口右下角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;无返回值：</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">ax</span>, <span class="number">0x600</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">bx</span>, <span class="number">0x700</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">cx</span>, <span class="number">0</span>           <span class="comment">; 左上角: (0, 0)</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">dx</span>, <span class="number">0x184f</span>	   <span class="comment">; 右下角: (80,25),</span></span><br><span class="line">			   <span class="comment">; VGA文本模式中,一行只能容纳80个字符,共25行。</span></span><br><span class="line">			   <span class="comment">; 下标从0开始,所以0x18=24,0x4f=79</span></span><br><span class="line">   <span class="keyword">int</span>     <span class="number">0x10</span>            <span class="comment">; int 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;</span></span><br><span class="line"><span class="comment">;.get_cursor获取当前光标位置,在光标位置处打印字符.</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">3</span>		<span class="comment">; 输入: 3号子功能是获取光标位置,需要存入ah寄存器</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">0</span>		<span class="comment">; bh寄存器存储的是待获取光标的页号</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x10</span>		<span class="comment">; 输出: ch=光标开始行,cl=光标结束行</span></span><br><span class="line">			<span class="comment">; dh=光标所在行号,dl=光标所在列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;     打印字符串    ;;;;;;;;;;;</span></span><br><span class="line">   <span class="comment">;还是用10h中断,不过这次是调用13号子功能打印字符串</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, message </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">ax</span>		<span class="comment">; es:bp 为串首地址, es此时同cs一致，</span></span><br><span class="line">			<span class="comment">; 开头时已经为sreg初始化</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">5</span>		<span class="comment">; cx 为串长度,不包括结束符0的字符个数</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0x1301</span>	<span class="comment">; 子功能号13是显示字符及属性,要存入ah寄存器,</span></span><br><span class="line">			<span class="comment">; al设置写字符方式 ah=01: 显示字符串,光标跟随移动</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0x2</span>		<span class="comment">; bh存储要显示的页号,此处是第0页,</span></span><br><span class="line">			<span class="comment">; bl中是字符属性, 属性黑底绿字(bl = 02h)</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x10</span>		<span class="comment">; 执行BIOS 0x10 号中断</span></span><br><span class="line"><span class="comment">;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> $		<span class="comment">; 使程序悬停在此</span></span><br><span class="line"></span><br><span class="line">   message <span class="built_in">db</span> <span class="string">"1 MBR"</span></span><br><span class="line">   <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   <span class="built_in">db</span> <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>$代表当前行的地址，$$代表当前section的地址。</li>
<li>vstart=0x7c00代表编译这个section的入口地址为0x7c00</li>
<li>int 10是关于打印显示的BIOS例程，通过配置好参数就可以使用int 10来调用它来打印。从地址空间可以看出实际执行的代码在bios里<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-071822.png" alt=""></li>
<li>因为MBR要有512字节，且最后两个字节是0x55,0xaa，所以前面使用<code>510-($-$$)</code>个字节来填充</li>
</ul>
<ol start="2">
<li><p>编译并写入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ nasm -o mbr.bin mbr.S</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ dd if&#x3D;mbr.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line">dd: failed to open &#39;hd60M.img&#39;: Permission denied</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ ls</span><br><span class="line">bochs  bochs.out  bochsrc.disk  bxcommit  bximage  hd60M.img  mbr.bin  mbr.S</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ sudo dd if&#x3D;mbr.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.00164969 s, 310 kB&#x2F;s</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-031935.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-031955.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-032043.png" alt=""><br>如图<code>0x7c31</code>就是我们死循环的那一行地址。<br>这样我们就简单的让BIOS加载了一个程序到内存并执行,这个程序就是MBR。</p>
</li>
<li><p>完善MBR<br>MBR只有512字节，无法实现对内核的加载，MBR需要从硬盘加载loader到内存，然后用loader加载内核。</p>
</li>
</ol>
<ul>
<li>编写MBR，其效果是读硬盘然后将loader加载到0x900处</li>
</ul>
<p><strong>注意vstart的前几句对段寄存器的赋值，因为跳转到mbr会将cs寄存器赋值为0，然后用其初始化其他几个段寄存器，就是将其都置为0</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;主引导程序 </span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line"><span class="meta">SECTION</span> MBR vstart=<span class="number">0x7c00</span>         </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>      </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">fs</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0x7c00</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xb800</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;清屏</span></span><br><span class="line"><span class="comment">;利用0x06号功能，上卷全部行，则可清屏。</span></span><br><span class="line"><span class="comment">; -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span></span><br><span class="line"><span class="comment">;------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入：</span></span><br><span class="line"><span class="comment">;AH 功能号= 0x06</span></span><br><span class="line"><span class="comment">;AL = 上卷的行数(如果为0,表示全部)</span></span><br><span class="line"><span class="comment">;BH = 上卷行属性</span></span><br><span class="line"><span class="comment">;(CL,CH) = 窗口左上角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;(DL,DH) = 窗口右下角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;无返回值：</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">ax</span>, <span class="number">0600h</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">bx</span>, <span class="number">0700h</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">cx</span>, <span class="number">0</span>                   <span class="comment">; 左上角: (0, 0)</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">dx</span>, <span class="number">184fh</span>		      <span class="comment">; 右下角: (80,25),</span></span><br><span class="line">				   <span class="comment">; 因为VGA文本模式中，一行只能容纳80个字符,共25行。</span></span><br><span class="line">				   <span class="comment">; 下标从0开始，所以0x18=24,0x4f=79</span></span><br><span class="line">   <span class="keyword">int</span>     <span class="number">10h</span>                     <span class="comment">; int 10h</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 输出字符串:MBR</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x00</span>],<span class="string">'1'</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x01</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x02</span>],<span class="string">' '</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x03</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x04</span>],<span class="string">'M'</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x05</span>],<span class="number">0xA4</span>	   <span class="comment">;A表示绿色背景闪烁，4表示前景色为红色</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x06</span>],<span class="string">'B'</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x07</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x08</span>],<span class="string">'R'</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x09</span>],<span class="number">0xA4</span></span><br><span class="line">   <span class="comment">; 寄存器传三个参数</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>,LOADER_START_SECTOR	 <span class="comment">; 起始扇区LBA地址</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>,LOADER_BASE_ADDR       <span class="comment">; 写入的地址</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1</span>			            <span class="comment">; 待读入的扇区数,这里是简单的loader故一个扇区足够</span></span><br><span class="line">   <span class="keyword">call</span> rd_disk_m_16		    <span class="comment">; 以下读取程序的起始部分（一个扇区）</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">jmp</span> LOADER_BASE_ADDR</span><br><span class="line">       </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;功能:读取硬盘n个扇区</span></span><br><span class="line"><span class="symbol">rd_disk_m_16:</span>	   </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">				       <span class="comment">; eax=LBA扇区号</span></span><br><span class="line">				       <span class="comment">; ebx=将数据写入的内存地址</span></span><br><span class="line">				       <span class="comment">; ecx=读入的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>	  <span class="comment">;备份eax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">cx</span>		  <span class="comment">;备份cx</span></span><br><span class="line"><span class="comment">;读写硬盘:</span></span><br><span class="line"><span class="comment">;第1步：选择通道，往该通道的sector count寄存器中写入待操作的扇区数</span></span><br><span class="line"><span class="comment">;因为bochs配置文件中虚拟硬盘属于ata0,是Primary通道,所以sector count寄存器由0x1f2端口访问</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f2</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>            <span class="comment">;读取的扇区数</span></span><br><span class="line">      <span class="comment">;out 往端口中写数据</span></span><br><span class="line">      <span class="comment">;in  从端口中读数据</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">esi</span>	   <span class="comment">;恢复ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第2步：将LBA地址写入三个LBA寄存器和device寄存器的低4位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址7~0位写入端口0x1f3</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f3</span>                       </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>                          </span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址15~8位写入端口0x1f4</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">8</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f4</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址23~16位写入端口0x1f5</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f5</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x0f</span>	   <span class="comment">; lba第24~27位</span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xe0</span>	   <span class="comment">; 设置7～4位为1110,表示lba模式</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f6</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第3步：向command寄存器写入读命令，0x20 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f7</span> <span class="comment">;要写入的端口</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x20</span>  <span class="comment">;要写入的数据          </span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第4步：检测硬盘状态，读取该通道上的status寄存器，判断硬盘工作是否完成</span></span><br><span class="line"><span class="symbol">  .not_ready:</span></span><br><span class="line">      <span class="comment">;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x88</span>	       <span class="comment">;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x08</span></span><br><span class="line">      <span class="keyword">jnz</span> .not_ready	   <span class="comment">;若未准备好，继续等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第5步：从0x1f0端口读数据</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">di</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">256</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span>	   <span class="comment">; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span></span><br><span class="line">			          <span class="comment">; 共需di*512/2次，所以di*256</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f0</span></span><br><span class="line"><span class="symbol">  .go_on_read:</span> <span class="comment">; 循环写入bx指向的内存</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">ax</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span>		  </span><br><span class="line">      <span class="keyword">loop</span> .go_on_read</span><br><span class="line">      <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   <span class="built_in">db</span> <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure>
<p>boot.inc</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOADER_BASE_ADDR <span class="built_in">equ</span> <span class="number">0x900</span></span><br><span class="line">LOADER_START_SECTOR <span class="built_in">equ</span> <span class="number">0x2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>写一个简单的loader，实现bios-&gt;mbr-&gt;loader的跳转执行</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line"><span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x00</span>],<span class="string">'2'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x01</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x02</span>],<span class="string">' '</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x03</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x04</span>],<span class="string">'L'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x05</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x06</span>],<span class="string">'O'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x07</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x08</span>],<span class="string">'A'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x09</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x0a</span>],<span class="string">'D'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x0b</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x0c</span>],<span class="string">'E'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x0d</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x0e</span>],<span class="string">'R'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x0f</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">jmp</span> $</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">akura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ nasm -I include&#x2F; -o mbr.bin mbr.S</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ sudo dd if&#x3D;mbr.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.000347796 s, 1.5 MB&#x2F;s</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;注意这里写到第二个扇区,seek&#x3D;2</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ nasm -I include&#x2F; -o loader.bin loader.S</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ sudo dd if&#x3D;loader.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;1 seek&#x3D;2 conv&#x3D;notrunc</span><br><span class="line">0+1 records in</span><br><span class="line">0+1 records out</span><br><span class="line">98 bytes copied, 0.000230929 s, 424 kB&#x2F;s</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-075746.png" alt=""></p>
</li>
<li><p>总结<br>总结一下MBR的功能，其实就是从硬盘加载loader程序到一个可用的内存地址，然后<code>jmp LOADER_BASE_ADDR</code>到该地址执行loader</p>
</li>
</ul>
<h3 id="loader-进入保护模式"><a href="#loader-进入保护模式" class="headerlink" title="loader-进入保护模式"></a>loader-进入保护模式</h3><p>CPU加电之后其实是运行在实模式下的，实模式可访问的地址空间只有1MB，且有很多缺陷，所以我们的loader需要先启动保护模式，开启分段机制。<br>关于分段存储管理的理论基础见上。</p>
<ul>
<li><p>实模式的安全缺陷总结：</p>
<ul>
<li>操作系统和用户属于同一特权级</li>
<li>用户程序引用的地址都是指向真实的物理地址</li>
<li>用户程序可以自由修改段基址，自由访问所有内存</li>
</ul>
</li>
<li><p>loader的主要功能如下:</p>
<ul>
<li>建立分段机制<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-081435.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-084838.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-084949.png" alt=""></li>
<li>通过LGDT来给GDTR寄存器赋值，其保存GDT的地址<br>lgdt的指令格式是:lgdt48位内存数据。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-090633.png" alt=""></li>
<li>打开A20地址线<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-090652.png" alt=""></li>
<li>打开CR0寄存器的PE位<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-090702.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-090852.png" alt=""></li>
</ul>
</li>
<li><p>修改boot.inc,定义一些符号/宏</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;--------------------- loader 和 kernel---------------------</span></span><br><span class="line"></span><br><span class="line">LOADER_BASE_ADDR <span class="built_in">equ</span> <span class="number">0x900</span></span><br><span class="line">LOADER_START_SECTOR <span class="built_in">equ</span> <span class="number">0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;--------------------  gdt 描述符属性  ----------------------</span></span><br><span class="line">DESC_G_4K         <span class="built_in">equ</span> <span class="number">1_00000000000000000000000b</span>        <span class="comment">;描述符的G位为4k粒度，以二进制表示，下划线可去掉</span></span><br><span class="line">DESC_D_32         <span class="built_in">equ</span>  <span class="number">1_0000000000000000000000b</span></span><br><span class="line">DESC_L            <span class="built_in">equ</span>   <span class="number">0_000000000000000000000b</span>        <span class="comment">;64位代码标记，此处标记为0便可</span></span><br><span class="line">DESC_AVL          <span class="built_in">equ</span>    <span class="number">0_00000000000000000000b</span>        <span class="comment">;CPU不用此位，暂置为0</span></span><br><span class="line">DESC_LIMIT_CODE2  <span class="built_in">equ</span>     <span class="number">1111_0000000000000000b</span>        <span class="comment">;段界限，需要设置为0xFFFFF</span></span><br><span class="line">DESC_LIMIT_DATA2  <span class="built_in">equ</span>     DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2 <span class="built_in">equ</span>      <span class="number">0000_000000000000000b</span></span><br><span class="line">DESC_P			  <span class="built_in">equ</span>         <span class="number">1_000000000000000b</span></span><br><span class="line">DESC_DPL_0        <span class="built_in">equ</span>          <span class="number">00_0000000000000b</span></span><br><span class="line">DESC_DPL_1		  <span class="built_in">equ</span>          <span class="number">01_0000000000000b</span></span><br><span class="line">DESC_DPL_2        <span class="built_in">equ</span>		   <span class="number">10_0000000000000b</span></span><br><span class="line">DESC_DPL_3        <span class="built_in">equ</span>          <span class="number">11_0000000000000b</span></span><br><span class="line">DESC_S_CODE		  <span class="built_in">equ</span>            <span class="number">1_000000000000b</span></span><br><span class="line">DESC_S_DATA       <span class="built_in">equ</span>            DESC_S_CODE</span><br><span class="line">DESC_S_sys        <span class="built_in">equ</span>            <span class="number">0_000000000000b</span></span><br><span class="line">DESC_TYPE_CODE    <span class="built_in">equ</span>             <span class="number">1000_00000000b</span>		<span class="comment">;x=1,c=0,r=0,a=0 代码段是可执行的,非一致性,不可读,已访问位a清0.  </span></span><br><span class="line">DESC_TYPE_DATA    <span class="built_in">equ</span>             <span class="number">0010_00000000b</span>		<span class="comment">;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写,已访问位a清0.</span></span><br><span class="line"></span><br><span class="line">DESC_CODE_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + <span class="number">0x00</span> <span class="comment">;定义代码段的高四字节，(0x00 &lt;&lt; 24)表示"段基址的24~31"字段，该字段位于段描述符高四字节24~31位，平坦模式段基址为0，所以这里用0填充，最后的0x00也是</span></span><br><span class="line">DESC_DATA_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + <span class="number">0x00</span></span><br><span class="line">DESC_VIDEO_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + <span class="number">0x0b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;--------------   选择子属性  ---------------</span></span><br><span class="line">RPL0  <span class="built_in">equ</span>   <span class="number">00b</span></span><br><span class="line">RPL1  <span class="built_in">equ</span>   <span class="number">01b</span></span><br><span class="line">RPL2  <span class="built_in">equ</span>   <span class="number">10b</span></span><br><span class="line">RPL3  <span class="built_in">equ</span>   <span class="number">11b</span></span><br><span class="line">TI_GDT	 <span class="built_in">equ</span>   <span class="number">000b</span></span><br><span class="line">TI_LDT	 <span class="built_in">equ</span>   <span class="number">100b</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改loader.S</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line">   <span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line">   LOADER_STACK_TOP <span class="built_in">equ</span> LOADER_BASE_ADDR</span><br><span class="line">   <span class="keyword">jmp</span> loader_start					<span class="comment">; 此处的物理地址是:</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">;构建gdt及其内部的描述符</span></span><br><span class="line"><span class="symbol">   GDT_BASE:</span>   <span class="built_in">dd</span>    <span class="number">0x00000000</span> </span><br><span class="line">	       <span class="built_in">dd</span>    <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   CODE_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span> </span><br><span class="line">	       <span class="built_in">dd</span>    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   DATA_STACK_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span></span><br><span class="line">		     <span class="built_in">dd</span>    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   VIDEO_DESC:</span> <span class="built_in">dd</span>    <span class="number">0x80000007</span>	       <span class="comment">;limit=(0xbffff-0xb8000)/4k=0x7</span></span><br><span class="line">	       <span class="built_in">dd</span>    DESC_VIDEO_HIGH4  <span class="comment">; 此时dpl已改为0</span></span><br><span class="line"></span><br><span class="line">   GDT_SIZE   <span class="built_in">equ</span>   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   <span class="built_in">equ</span>   GDT_SIZE -	<span class="number">1</span> </span><br><span class="line">   <span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span>					 <span class="comment">; 此处预留60个描述符的slot</span></span><br><span class="line">   SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0         <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">   SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上</span></span><br><span class="line">   SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span></span><br><span class="line"></span><br><span class="line">   gdt_ptr  <span class="built_in">dw</span>  GDT_LIMIT </span><br><span class="line">	    <span class="built_in">dd</span>  GDT_BASE</span><br><span class="line">   loadermsg <span class="built_in">db</span> <span class="string">'2 loader in real.'</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   loader_start:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10    功能号:0x13    功能描述:打印字符串</span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入:</span></span><br><span class="line"><span class="comment">;AH 子功能号=13H</span></span><br><span class="line"><span class="comment">;BH = 页码</span></span><br><span class="line"><span class="comment">;BL = 属性(若AL=00H或01H)</span></span><br><span class="line"><span class="comment">;CX＝字符串长度</span></span><br><span class="line"><span class="comment">;(DH、DL)＝坐标(行、列)</span></span><br><span class="line"><span class="comment">;ES:BP＝字符串地址 </span></span><br><span class="line"><span class="comment">;AL＝显示输出方式</span></span><br><span class="line"><span class="comment">;   0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变</span></span><br><span class="line"><span class="comment">;   1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变</span></span><br><span class="line"><span class="comment">;   2——字符串中含显示字符和显示属性。显示后，光标位置不变</span></span><br><span class="line"><span class="comment">;   3——字符串中含显示字符和显示属性。显示后，光标位置改变</span></span><br><span class="line"><span class="comment">;无返回值</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">sp</span>, LOADER_BASE_ADDR</span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">bp</span>, loadermsg           <span class="comment">; ES:BP = 字符串地址</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">cx</span>, <span class="number">17</span>			 <span class="comment">; CX = 字符串长度</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">ax</span>, <span class="number">0x1301</span>		 <span class="comment">; AH = 13,  AL = 01h</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">bx</span>, <span class="number">0x001f</span>		 <span class="comment">; 页号为0(BH = 0) 蓝底粉红字(BL = 1fh)</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">dx</span>, <span class="number">0x1800</span>		 <span class="comment">;</span></span><br><span class="line">   <span class="keyword">int</span>	 <span class="number">0x10</span>                    <span class="comment">; 10h 号中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------------------------------------   准备进入保护模式   ------------------------------------------</span></span><br><span class="line">									<span class="comment">;1 打开A20</span></span><br><span class="line">									<span class="comment">;2 加载gdt</span></span><br><span class="line">									<span class="comment">;3 将cr0的pe位置1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line">   <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">   <span class="keyword">jmp</span>  SELECTOR_CODE:p_mode_start	     <span class="comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">					     <span class="comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>,LOADER_STACK_TOP</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">160</span>], <span class="string">'P'</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> $</span><br></pre></td></tr></table></figure></li>
<li><p>修改mbr.S<br>因为现在要读入的是4个扇区</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">52</span> <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">4</span>         <span class="comment">; 带读入的扇区数</span></span><br><span class="line"><span class="number">53</span> <span class="keyword">call</span> rd_disk_m_16 <span class="comment">; 以下读取程序的起始部分(一个扇区)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nasm -I include&#x2F; -o mbr.bin mbr.S</span><br><span class="line">sudo dd if&#x3D;mbr.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line">nasm -I include&#x2F; -o loader.bin loader.S</span><br><span class="line">sudo dd if&#x3D;loader.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;2 seek&#x3D;2 conv&#x3D;notrunc</span><br><span class="line">sudo .&#x2F;bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-094553.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-100151.png" alt=""></p>
</li>
<li><p>内存段的保护<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-101706.png" alt=""></p>
</li>
</ul>
<h3 id="loader-启用分页机制"><a href="#loader-启用分页机制" class="headerlink" title="loader-启用分页机制"></a>loader-启用分页机制</h3><p>由于分段时使用的线性地址会被直接用作物理地址，所以为了实现虚拟地址这一层抽象，需要提供分页机制。</p>
<p>其实关于分页，要记住的最重要的就是，这个东西是为了把线性地址转物理地址的时候再加一层抽象，让<strong>不同进程</strong>，<strong>相同的线性地址</strong>被转成不同的物理地址，所以不同的进程，它的页表其实是不同的。</p>
<ol>
<li><p>准备好页目录表及页表<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-144639.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-150310.png" alt=""><br>只有第 12<del>31 位才是物理 地址，这才 20 位。按理说 32 位地址应该用 32 位来表示啊，否则不就误差严重了吗。是这样的，因为页目录项和页表项中的都是物理页地址，标准页大小是 4KB，故地址都是 4K 的倍数，也就是地址的低 12 位是 0，所以只需要记录物理地址高 20 位就可以啦。这样省出来的 12 位(第 0</del>11 位)可以用来添加其 他属性，下面对这些属性从低到高逐位介绍。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-150440.png" alt=""><br>页目录表的位置，我们就放在物理地址 0x100000 处。为了让页表和页目录表紧凑一些(这不是必须的)，咱们让页表紧挨着页目录表。页目录本身占 4KB，所以第一个页表的物理地址是 0x101000。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-155659.png" alt=""></p>
<ul>
<li>将第0和第786项页目录项都指向第一个页表</li>
<li>将最后一个目录项指向页目录表自己的地址,<strong>这其实是出于一个自映射的目的，将最高页表项指向页目录表自己的基地址，就可以用0xfffffxxx这样的虚拟地址来访问每个页目录表项了:因为高20位都是1，所以会先根据前10位来选到最高的页目录项，其指向页目录表基地址，然后再根据后10位又选到了最高的页目录项，其指向页目录表基地址，最后xxx是12位，可以在4KB的偏移里随意访问，这样就可以访问每个页目录表项</strong></li>
<li>创建第一个页表，紧邻页目录表，里面有1024个页表项，但只使用256个页表项，每个页表项表示4KB内存，其将表示最低的1MB内存</li>
<li>创建代表内核空间的其他页目录项<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-16-065554.jpg" alt=""><br>这个768很好算，其实是这样的，首先每个页目录项代表4MB，从3GB开始是内核空间，所以3GB/4MB=786，从786开始都是内核地址空间。</li>
</ul>
</li>
<li><p>将页表的物理地址写入控制寄存器cr3<br>控制寄存器 cr3 用于存储页表物理地址，所以cr3寄存器又称为页目录基址寄存器(Page Directory Base Register，PDBR)。</p>
</li>
</ol>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-15-151035.png" alt=""></p>
<p>在将PG位置1之前，系统都是在内存分段机制下工作，段部件输出的线性地址便直接是物理地址，也就意味着在第2步中，cr3寄存器中的页表地址是真实的物理地址。</p>
<ol start="3">
<li>寄存器cr0的PG位置1</li>
<li>测试</li>
</ol>
<ul>
<li>loader.S<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line">   <span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line">   LOADER_STACK_TOP <span class="built_in">equ</span> LOADER_BASE_ADDR</span><br><span class="line">   </span><br><span class="line"><span class="comment">;构建gdt及其内部的描述符</span></span><br><span class="line"><span class="symbol">   GDT_BASE:</span>   <span class="built_in">dd</span>    <span class="number">0x00000000</span> </span><br><span class="line">	       <span class="built_in">dd</span>    <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   CODE_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span> </span><br><span class="line">	       <span class="built_in">dd</span>    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   DATA_STACK_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span></span><br><span class="line">		     <span class="built_in">dd</span>    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   VIDEO_DESC:</span> <span class="built_in">dd</span>    <span class="number">0x80000007</span>	       <span class="comment">; limit=(0xbffff-0xb8000)/4k=0x7</span></span><br><span class="line">	       <span class="built_in">dd</span>    DESC_VIDEO_HIGH4  <span class="comment">; 此时dpl为0</span></span><br><span class="line"></span><br><span class="line">   GDT_SIZE   <span class="built_in">equ</span>   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   <span class="built_in">equ</span>   GDT_SIZE -	<span class="number">1</span> </span><br><span class="line">   <span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span>					 <span class="comment">; 此处预留60个描述符的空位(slot)</span></span><br><span class="line">   SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0         <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">   SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上</span></span><br><span class="line">   SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span></span><br><span class="line">   <span class="comment">; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span></span><br><span class="line">   <span class="comment">; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span></span><br><span class="line">   total_mem_bytes <span class="built_in">dd</span> <span class="number">0</span>					 </span><br><span class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span></span><br><span class="line">   gdt_ptr  <span class="built_in">dw</span>  GDT_LIMIT </span><br><span class="line">	    <span class="built_in">dd</span>  GDT_BASE</span><br><span class="line"></span><br><span class="line">   <span class="comment">;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span></span><br><span class="line">   ards_buf <span class="built_in">times</span> <span class="number">244</span> <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   ards_nr <span class="built_in">dw</span> <span class="number">0</span>		      <span class="comment">;用于记录ards结构体数量</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   loader_start:</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		      <span class="comment">;第一次调用时，ebx值要为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0x534d4150</span>	      <span class="comment">;edx只赋值一次，循环体中不会改变</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">di</span>, ards_buf	      <span class="comment">;ards结构缓冲区</span></span><br><span class="line"><span class="symbol">.e820_mem_get_loop:</span>	      <span class="comment">;循环获取每个ARDS内存范围描述结构</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0x0000e820</span>	      <span class="comment">;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">20</span>		      <span class="comment">;ARDS地址范围描述符结构大小是20字节</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e820_failed_so_try_e801   <span class="comment">;若cf位为1则有错误发生，尝试0xe801子功能</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>, <span class="built_in">cx</span>		      <span class="comment">;使di增加20字节指向缓冲区中新的ARDS结构位置</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">word</span> [ards_nr]	      <span class="comment">;记录ARDS数量</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">ebx</span>, <span class="number">0</span>		      <span class="comment">;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span></span><br><span class="line">   <span class="keyword">jnz</span> .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line"><span class="comment">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [ards_nr]	      <span class="comment">;遍历每一个ARDS结构体,循环次数是ARDS的数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, ards_buf </span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		      <span class="comment">;edx为最大的内存容量,在此先清0</span></span><br><span class="line"><span class="symbol">.find_max_mem_area:</span>	      <span class="comment">;无须判断type是否为1,最大的内存块一定是可被使用</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]	      <span class="comment">;base_add_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+<span class="number">8</span>]	      <span class="comment">;length_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">20</span>		      <span class="comment">;指向缓冲区中下一个ARDS结构</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span></span><br><span class="line">   <span class="keyword">jge</span> .next_ards</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;edx为总内存大小</span></span><br><span class="line"><span class="symbol">.next_ards:</span></span><br><span class="line">   <span class="keyword">loop</span> .find_max_mem_area</span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span></span><br><span class="line"><span class="comment">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span></span><br><span class="line"><span class="comment">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span></span><br><span class="line"><span class="symbol">.e820_failed_so_try_e801:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xe801</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e801_failed_so_try88   <span class="comment">;若当前e801方法失败,就尝试0x88方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0x400</span>	     <span class="comment">;cx和ax值一样,cx用做乘数</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span> </span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>, <span class="number">0x100000</span> <span class="comment">;ax只是15MB,故要加1MB</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">edx</span>	     <span class="comment">;先把低15MB的内存容量存入esi寄存器备份</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>		</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">0x10000</span>	<span class="comment">;0x10000十进制为64KB</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">ecx</span>		<span class="comment">;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>		<span class="comment">;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">esi</span>		<span class="comment">;edx为总内存大小</span></span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span></span><br><span class="line"><span class="symbol">.e801_failed_so_try88:</span> </span><br><span class="line">   <span class="comment">;int 15后，ax存入的是以kb为单位的内存容量</span></span><br><span class="line">   <span class="keyword">mov</span>  <span class="number">ah</span>, <span class="number">0x88</span></span><br><span class="line">   <span class="keyword">int</span>  <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .error_hlt</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x400</span>     <span class="comment">;0x400等于1024,将ax中的内存容量换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span></span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>, <span class="number">16</span>	     <span class="comment">;把dx移到高16位</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>	     <span class="comment">;把积的低16位组合到edx,为32位的积</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">0x100000</span>  <span class="comment">;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.mem_get_ok:</span></span><br><span class="line">   <span class="keyword">mov</span> [total_mem_bytes], <span class="built_in">edx</span>	 <span class="comment">;将内存换为byte单位后存入total_mem_bytes处。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   准备进入保护模式   -------------------</span></span><br><span class="line"><span class="comment">;1 打开A20</span></span><br><span class="line"><span class="comment">;2 加载gdt</span></span><br><span class="line"><span class="comment">;3 将cr0的pe位置1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line">   <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> <span class="built_in">dword</span> SELECTOR_CODE:p_mode_start	     <span class="comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">					     <span class="comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span></span><br><span class="line"><span class="symbol">.error_hlt:</span>		      <span class="comment">;出错则挂起</span></span><br><span class="line">   <span class="keyword">hlt</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>,LOADER_STACK_TOP</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 创建页目录及页表并初始化页内存位图</span></span><br><span class="line">   <span class="keyword">call</span> setup_page</span><br><span class="line"></span><br><span class="line">   <span class="comment">;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span></span><br><span class="line">   <span class="keyword">sgdt</span> [gdt_ptr]	      <span class="comment">; 存储到原来gdt所有的位置</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt描述符中视频段描述符中的段基址+0xc0000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [gdt_ptr + <span class="number">2</span>]  </span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">0x18</span> + <span class="number">4</span>], <span class="number">0xc0000000</span>      <span class="comment">;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span></span><br><span class="line">					      <span class="comment">;段描述符的高4字节的最高位是段基址的31~24位</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">dword</span> [gdt_ptr + <span class="number">2</span>], <span class="number">0xc0000000</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">0xc0000000</span>        <span class="comment">; 将栈指针同样映射到内核地址</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 把页目录地址赋给cr3</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr3</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 打开cr0的pg位(第31位)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x80000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;在开启分页后,用gdt新的地址重新加载</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]             <span class="comment">; 重新加载</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">160</span>], <span class="string">'V'</span>     <span class="comment">;视频段段基址已经被更新,用字符v表示virtual addr</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> $</span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------   创建页目录及页表   ---------------</span></span><br><span class="line"><span class="symbol">setup_page:</span></span><br><span class="line"><span class="comment">;先把页目录占用的空间逐字节清0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">4096</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">.clear_page_dir:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="built_in">esi</span>], <span class="number">0</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .clear_page_dir</span><br><span class="line"></span><br><span class="line"><span class="comment">;开始创建页目录项(PDE)</span></span><br><span class="line"><span class="symbol">.create_pde:</span>				     <span class="comment">; 创建Page Directory Entry</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span> 			     <span class="comment">; 此时eax为第一个页表的位置及属性</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>				     <span class="comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span></span><br><span class="line"><span class="comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span></span><br><span class="line"><span class="comment">;   这是为将地址映射为内核地址做准备</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0x0</span>], <span class="built_in">eax</span>       <span class="comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0xc00</span>], <span class="built_in">eax</span>     <span class="comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span></span><br><span class="line">					     <span class="comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span></span><br><span class="line">   <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">4092</span>], <span class="built_in">eax</span>	     <span class="comment">; 使最后一个目录项指向页目录表自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;下面创建页表项(PTE)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">256</span>				     <span class="comment">; 1M低端内存 / 每页大小4k = 256</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 属性为7,US=1,RW=1,P=1</span></span><br><span class="line"><span class="symbol">.create_pte:</span>				     <span class="comment">; 创建Page Table Entry</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>],<span class="built_in">edx</span>			     <span class="comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">4096</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .create_pte</span><br><span class="line"></span><br><span class="line"><span class="comment">;创建内核其它页表的PDE</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x2000</span> 		     <span class="comment">; 此时eax为第二个页表的位置</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P  <span class="comment">; 页目录项的属性US,RW和P位都为1</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">254</span>			     <span class="comment">; 范围为第769~1022的所有目录项数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">769</span></span><br><span class="line"><span class="symbol">.create_kernel_pde:</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">loop</span> .create_kernel_pde</span><br><span class="line">   <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></li>
<li>boot.inc<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;-------------	 loader和kernel   ----------</span></span><br><span class="line"></span><br><span class="line">LOADER_BASE_ADDR <span class="built_in">equ</span> <span class="number">0x900</span> </span><br><span class="line">LOADER_START_SECTOR <span class="built_in">equ</span> <span class="number">0x2</span></span><br><span class="line">KERNEL_BIN_BASE_ADDR <span class="built_in">equ</span> <span class="number">0x70000</span></span><br><span class="line">KERNEL_IMAGE_BASE_ADDR  <span class="built_in">equ</span>   <span class="number">0x1500</span></span><br><span class="line">KERNEL_START_SECTOR <span class="built_in">equ</span> <span class="number">0x9</span></span><br><span class="line"></span><br><span class="line">PAGE_DIR_TABLE_POS <span class="built_in">equ</span> <span class="number">0x100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;--------------   gdt描述符属性  -------------</span></span><br><span class="line">DESC_G_4K   <span class="built_in">equ</span>	  <span class="number">1_00000000000000000000000b</span>   </span><br><span class="line">DESC_D_32   <span class="built_in">equ</span>	   <span class="number">1_0000000000000000000000b</span></span><br><span class="line">DESC_L	    <span class="built_in">equ</span>	    <span class="number">0_000000000000000000000b</span>	<span class="comment">;  64位代码标记，此处标记为0便可。</span></span><br><span class="line">DESC_AVL    <span class="built_in">equ</span>	     <span class="number">0_00000000000000000000b</span>	<span class="comment">;  cpu不用此位，暂置为0  </span></span><br><span class="line">DESC_LIMIT_CODE2  <span class="built_in">equ</span> <span class="number">1111_0000000000000000b</span></span><br><span class="line">DESC_LIMIT_DATA2  <span class="built_in">equ</span> DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2  <span class="built_in">equ</span> <span class="number">0000_000000000000000b</span></span><br><span class="line">DESC_P	    <span class="built_in">equ</span>		  <span class="number">1_000000000000000b</span></span><br><span class="line">DESC_DPL_0  <span class="built_in">equ</span>		   <span class="number">00_0000000000000b</span></span><br><span class="line">DESC_DPL_1  <span class="built_in">equ</span>		   <span class="number">01_0000000000000b</span></span><br><span class="line">DESC_DPL_2  <span class="built_in">equ</span>		   <span class="number">10_0000000000000b</span></span><br><span class="line">DESC_DPL_3  <span class="built_in">equ</span>		   <span class="number">11_0000000000000b</span></span><br><span class="line">DESC_S_CODE <span class="built_in">equ</span>		     <span class="number">1_000000000000b</span></span><br><span class="line">DESC_S_DATA <span class="built_in">equ</span>	  DESC_S_CODE</span><br><span class="line">DESC_S_sys  <span class="built_in">equ</span>		     <span class="number">0_000000000000b</span></span><br><span class="line">DESC_TYPE_CODE  <span class="built_in">equ</span>	      <span class="number">1000_00000000b</span>	<span class="comment">;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  </span></span><br><span class="line">DESC_TYPE_DATA  <span class="built_in">equ</span>	      <span class="number">0010_00000000b</span>	<span class="comment">;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span></span><br><span class="line"></span><br><span class="line">DESC_CODE_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + <span class="number">0x00</span></span><br><span class="line">DESC_DATA_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + <span class="number">0x00</span></span><br><span class="line">DESC_VIDEO_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + <span class="number">0x0b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;--------------   选择子属性  ---------------</span></span><br><span class="line">RPL0  <span class="built_in">equ</span>   <span class="number">00b</span></span><br><span class="line">RPL1  <span class="built_in">equ</span>   <span class="number">01b</span></span><br><span class="line">RPL2  <span class="built_in">equ</span>   <span class="number">10b</span></span><br><span class="line">RPL3  <span class="built_in">equ</span>   <span class="number">11b</span></span><br><span class="line">TI_GDT	 <span class="built_in">equ</span>   <span class="number">000b</span></span><br><span class="line">TI_LDT	 <span class="built_in">equ</span>   <span class="number">100b</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------------   页表相关属性    --------------</span></span><br><span class="line">PG_P  <span class="built_in">equ</span>   <span class="number">1b</span></span><br><span class="line">PG_RW_R	 <span class="built_in">equ</span>  <span class="number">00b</span> </span><br><span class="line">PG_RW_W	 <span class="built_in">equ</span>  <span class="number">10b</span> </span><br><span class="line">PG_US_S	 <span class="built_in">equ</span>  <span class="number">000b</span> </span><br><span class="line">PG_US_U	 <span class="built_in">equ</span>  <span class="number">100b</span></span><br></pre></td></tr></table></figure></li>
<li>mbr.S<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;主引导程序 </span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line"><span class="meta">SECTION</span> MBR vstart=<span class="number">0x7c00</span>         </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>      </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">fs</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0x7c00</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xb800</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清屏</span></span><br><span class="line"><span class="comment">;利用0x06号功能，上卷全部行，则可清屏。</span></span><br><span class="line"><span class="comment">; -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span></span><br><span class="line"><span class="comment">;------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入：</span></span><br><span class="line"><span class="comment">;AH 功能号= 0x06</span></span><br><span class="line"><span class="comment">;AL = 上卷的行数(如果为0,表示全部)</span></span><br><span class="line"><span class="comment">;BH = 上卷行属性</span></span><br><span class="line"><span class="comment">;(CL,CH) = 窗口左上角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;(DL,DH) = 窗口右下角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;无返回值：</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">ax</span>, <span class="number">0600h</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">bx</span>, <span class="number">0700h</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">cx</span>, <span class="number">0</span>                   <span class="comment">; 左上角: (0, 0)</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">dx</span>, <span class="number">184fh</span>		   <span class="comment">; 右下角: (80,25),</span></span><br><span class="line">				   <span class="comment">; 因为VGA文本模式中，一行只能容纳80个字符,共25行。</span></span><br><span class="line">				   <span class="comment">; 下标从0开始，所以0x18=24,0x4f=79</span></span><br><span class="line">   <span class="keyword">int</span>     <span class="number">10h</span>                     <span class="comment">; int 10h</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 输出字符串:MBR</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x00</span>],<span class="string">'1'</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x01</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x02</span>],<span class="string">' '</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x03</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x04</span>],<span class="string">'M'</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x05</span>],<span class="number">0xA4</span>	   <span class="comment">;A表示绿色背景闪烁，4表示前景色为红色</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x06</span>],<span class="string">'B'</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x07</span>],<span class="number">0xA4</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x08</span>],<span class="string">'R'</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x09</span>],<span class="number">0xA4</span></span><br><span class="line">	 </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>,LOADER_START_SECTOR	 <span class="comment">; 起始扇区lba地址</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>,LOADER_BASE_ADDR       <span class="comment">; 写入的地址</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span>			 <span class="comment">; 待读入的扇区数</span></span><br><span class="line">   <span class="keyword">call</span> rd_disk_m_16		 <span class="comment">; 以下读取程序的起始部分（一个扇区）</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">jmp</span> LOADER_BASE_ADDR + <span class="number">0x300</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;功能:读取硬盘n个扇区</span></span><br><span class="line"><span class="symbol">rd_disk_m_16:</span>	   </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">				       <span class="comment">; eax=LBA扇区号</span></span><br><span class="line">				       <span class="comment">; ebx=将数据写入的内存地址</span></span><br><span class="line">				       <span class="comment">; ecx=读入的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>	  <span class="comment">;备份eax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">cx</span>		  <span class="comment">;备份cx</span></span><br><span class="line"><span class="comment">;读写硬盘:</span></span><br><span class="line"><span class="comment">;第1步：设置要读取的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f2</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>            <span class="comment">;读取的扇区数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">esi</span>	   <span class="comment">;恢复ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址7~0位写入端口0x1f3</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f3</span>                       </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>                          </span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址15~8位写入端口0x1f4</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">8</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f4</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址23~16位写入端口0x1f5</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f5</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x0f</span>	   <span class="comment">;lba第24~27位</span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xe0</span>	   <span class="comment">; 设置7～4位为1110,表示lba模式</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f6</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第3步：向0x1f7端口写入读命令，0x20 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f7</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x20</span>                        </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第4步：检测硬盘状态</span></span><br><span class="line"><span class="symbol">  .not_ready:</span></span><br><span class="line">      <span class="comment">;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x88</span>	   <span class="comment">;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x08</span></span><br><span class="line">      <span class="keyword">jnz</span> .not_ready	   <span class="comment">;若未准备好，继续等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第5步：从0x1f0端口读数据</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">di</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">256</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span>	   <span class="comment">; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span></span><br><span class="line">			   <span class="comment">; 共需di*512/2次，所以di*256</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f0</span></span><br><span class="line"><span class="symbol">  .go_on_read:</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">ax</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span>		  </span><br><span class="line">      <span class="keyword">loop</span> .go_on_read</span><br><span class="line">      <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   <span class="built_in">db</span> <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure></li>
<li>编译和写入硬盘<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nasm -I include&#x2F; -o loader.bin loader.S</span><br><span class="line">nasm -I include&#x2F; -o mbr.bin mbr.S</span><br><span class="line">sudo dd if&#x3D;loader.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;3 seek&#x3D;2 conv&#x3D;notrunc</span><br><span class="line">sudo dd if&#x3D;mbr.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br></pre></td></tr></table></figure>
<img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-16-074306.png" alt=""></li>
</ul>
<p><strong>这里需要注意的是，现在loader.bin的大小是1189字节了，2个扇区不够了，所以写入的count为3.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:2&gt; info tab</span><br><span class="line">cr3: 0x000000100000</span><br><span class="line">0x00000000-0x000fffff -&gt; 0x000000000000-0x0000000fffff</span><br><span class="line">0xc0000000-0xc00fffff -&gt; 0x000000000000-0x0000000fffff</span><br><span class="line">0xffc00000-0xffc00fff -&gt; 0x000000101000-0x000000101fff</span><br><span class="line">0xfff00000-0xffffefff -&gt; 0x000000101000-0x0000001fffff</span><br><span class="line">0xfffff000-0xffffffff -&gt; 0x000000100000-0x000000100fff</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-16-074936.png" alt=""><br>可以看出虚拟地址已经和物理地址映射好了，3G的虚拟地址被映射到0x0的物理地址处了。</p>
<h3 id="loader-加载内核"><a href="#loader-加载内核" class="headerlink" title="loader-加载内核"></a>loader-加载内核</h3><p>对于编译出来的obj文件，其是没有被重定位的，也就是符号(变量名，函数名)的地址尚未确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ gcc -m32 -c -o kernel&#x2F;main.o kernel&#x2F;main.c</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ cd kernel&#x2F;</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin&#x2F;kernel$ ls</span><br><span class="line">main.c  main.o</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin&#x2F;kernel$ file main.o</span><br><span class="line">main.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin&#x2F;kernel$ nm main.o</span><br><span class="line">00000000 T main</span><br></pre></td></tr></table></figure>
<p>经过链接之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ ld kernel&#x2F;main.o -m elf_i386 -Ttext 0xc0001500 -e main -o kernel&#x2F;kernel.bin</span><br><span class="line">...</span><br><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ nm kernel&#x2F;kernel.bin </span><br><span class="line">c000253c R __bss_start</span><br><span class="line">c000253c R _edata</span><br><span class="line">c000253c R _end</span><br><span class="line">c0001500 T main</span><br></pre></td></tr></table></figure>
<p>内核其实也是一个elf文件，要加载一个elf文件，我们就要先理解elf文件的格式</p>
<h4 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h4><p>可执行程序的elf文件包括elf文件头/程序头/段体/节头/节体等<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163533.png" alt=""></p>
<ul>
<li>elf文件头</li>
</ul>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163702.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163843.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163820.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163925.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163942.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-163744.png" alt=""></p>
<ul>
<li>program header</li>
</ul>
<p>程序头主要保存segment信息<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-164032.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-164112.png" alt=""></p>
<h4 id="内核加载步骤"><a href="#内核加载步骤" class="headerlink" title="内核加载步骤"></a>内核加载步骤</h4><ul>
<li><p>加载内核:需要把内核文件加载到内存缓冲区。</p>
<ul>
<li>这是因为elf在载入内存不是需要对每个段都进行加载，所以要先读出到缓冲区</li>
</ul>
</li>
<li><p>初始化内核:需要在分页后，将加载进来的elf内核文件安置到相应的虚拟内存地址，然后跳过去执行，从此loader的工作结束。</p>
<ul>
<li>根据elf文件头<ul>
<li>找到程序头表在文件里的偏移，记录程序头表地址</li>
<li>读出程序头表中的program header数量</li>
<li>读出程序头表中的每个program header表项的大小，即e_phentsize</li>
</ul>
</li>
<li>根据程序头表<ul>
<li>从程序头表基地址，循环读取每个程序头</li>
<li>读取p_filesz，找到本段在文件中的大小</li>
<li>读取p_offset，找到在文件中的起始偏移</li>
<li>读取p_vaddr，找到写入到内存的起始虚拟地址</li>
</ul>
</li>
</ul>
</li>
<li><p>最终的内存布局（物理内存角度）</p>
<p> <img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-165042.png" alt=""></p>
</li>
<li><p>最终的loader.S和boot.inc</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line">   <span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line"><span class="comment">;构建gdt及其内部的描述符</span></span><br><span class="line"><span class="symbol">   GDT_BASE:</span>   <span class="built_in">dd</span>    <span class="number">0x00000000</span> </span><br><span class="line">	       <span class="built_in">dd</span>    <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   CODE_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span> </span><br><span class="line">	       <span class="built_in">dd</span>    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   DATA_STACK_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span></span><br><span class="line">		     <span class="built_in">dd</span>    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   VIDEO_DESC:</span> <span class="built_in">dd</span>    <span class="number">0x80000007</span>	       <span class="comment">; limit=(0xbffff-0xb8000)/4k=0x7</span></span><br><span class="line">	       <span class="built_in">dd</span>    DESC_VIDEO_HIGH4  <span class="comment">; 此时dpl为0</span></span><br><span class="line"></span><br><span class="line">   GDT_SIZE   <span class="built_in">equ</span>   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   <span class="built_in">equ</span>   GDT_SIZE -	<span class="number">1</span> </span><br><span class="line">   <span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span>					 <span class="comment">; 此处预留60个描述符的空位(slot)</span></span><br><span class="line">   SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0         <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">   SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上</span></span><br><span class="line">   SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span></span><br><span class="line">   <span class="comment">; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span></span><br><span class="line">   <span class="comment">; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span></span><br><span class="line">   total_mem_bytes <span class="built_in">dd</span> <span class="number">0</span>					 </span><br><span class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span></span><br><span class="line">   gdt_ptr  <span class="built_in">dw</span>  GDT_LIMIT </span><br><span class="line">	    <span class="built_in">dd</span>  GDT_BASE</span><br><span class="line"></span><br><span class="line">   <span class="comment">;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span></span><br><span class="line">   ards_buf <span class="built_in">times</span> <span class="number">244</span> <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   ards_nr <span class="built_in">dw</span> <span class="number">0</span>		      <span class="comment">;用于记录ards结构体数量</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   loader_start:</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		      <span class="comment">;第一次调用时，ebx值要为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0x534d4150</span>	      <span class="comment">;edx只赋值一次，循环体中不会改变</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">di</span>, ards_buf	      <span class="comment">;ards结构缓冲区</span></span><br><span class="line"><span class="symbol">.e820_mem_get_loop:</span>	      <span class="comment">;循环获取每个ARDS内存范围描述结构</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0x0000e820</span>	      <span class="comment">;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">20</span>		      <span class="comment">;ARDS地址范围描述符结构大小是20字节</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e820_failed_so_try_e801   <span class="comment">;若cf位为1则有错误发生，尝试0xe801子功能</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>, <span class="built_in">cx</span>		      <span class="comment">;使di增加20字节指向缓冲区中新的ARDS结构位置</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">word</span> [ards_nr]	      <span class="comment">;记录ARDS数量</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">ebx</span>, <span class="number">0</span>		      <span class="comment">;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span></span><br><span class="line">   <span class="keyword">jnz</span> .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line"><span class="comment">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [ards_nr]	      <span class="comment">;遍历每一个ARDS结构体,循环次数是ARDS的数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, ards_buf </span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		      <span class="comment">;edx为最大的内存容量,在此先清0</span></span><br><span class="line"><span class="symbol">.find_max_mem_area:</span>	      <span class="comment">;无须判断type是否为1,最大的内存块一定是可被使用</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]	      <span class="comment">;base_add_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+<span class="number">8</span>]	      <span class="comment">;length_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">20</span>		      <span class="comment">;指向缓冲区中下一个ARDS结构</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span></span><br><span class="line">   <span class="keyword">jge</span> .next_ards</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;edx为总内存大小</span></span><br><span class="line"><span class="symbol">.next_ards:</span></span><br><span class="line">   <span class="keyword">loop</span> .find_max_mem_area</span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span></span><br><span class="line"><span class="comment">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span></span><br><span class="line"><span class="comment">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span></span><br><span class="line"><span class="symbol">.e820_failed_so_try_e801:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xe801</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e801_failed_so_try88   <span class="comment">;若当前e801方法失败,就尝试0x88方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0x400</span>	     <span class="comment">;cx和ax值一样,cx用做乘数</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span> </span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>, <span class="number">0x100000</span> <span class="comment">;ax只是15MB,故要加1MB</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">edx</span>	     <span class="comment">;先把低15MB的内存容量存入esi寄存器备份</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>		</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">0x10000</span>	<span class="comment">;0x10000十进制为64KB</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">ecx</span>		<span class="comment">;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>		<span class="comment">;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">esi</span>		<span class="comment">;edx为总内存大小</span></span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span></span><br><span class="line"><span class="symbol">.e801_failed_so_try88:</span> </span><br><span class="line">   <span class="comment">;int 15后，ax存入的是以kb为单位的内存容量</span></span><br><span class="line">   <span class="keyword">mov</span>  <span class="number">ah</span>, <span class="number">0x88</span></span><br><span class="line">   <span class="keyword">int</span>  <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .error_hlt</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x400</span>     <span class="comment">;0x400等于1024,将ax中的内存容量换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span></span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>, <span class="number">16</span>	     <span class="comment">;把dx移到高16位</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>	     <span class="comment">;把积的低16位组合到edx,为32位的积</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">0x100000</span>  <span class="comment">;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.mem_get_ok:</span></span><br><span class="line">   <span class="keyword">mov</span> [total_mem_bytes], <span class="built_in">edx</span>	 <span class="comment">;将内存换为byte单位后存入total_mem_bytes处。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   准备进入保护模式   -------------------</span></span><br><span class="line"><span class="comment">;1 打开A20</span></span><br><span class="line"><span class="comment">;2 加载gdt</span></span><br><span class="line"><span class="comment">;3 将cr0的pe位置1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line">   <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> <span class="built_in">dword</span> SELECTOR_CODE:p_mode_start	     <span class="comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">					     <span class="comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span></span><br><span class="line"><span class="symbol">.error_hlt:</span>		      <span class="comment">;出错则挂起</span></span><br><span class="line">   <span class="keyword">hlt</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>,LOADER_STACK_TOP</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------------   加载kernel  ----------------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, KERNEL_START_SECTOR        <span class="comment">; kernel.bin所在的扇区号</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, KERNEL_BIN_BASE_ADDR       <span class="comment">; 从磁盘读出后，写入到ebx指定的地址</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">200</span>			       <span class="comment">; 读入的扇区数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">call</span> rd_disk_m_32</span><br><span class="line"></span><br><span class="line">   <span class="comment">; 创建页目录及页表并初始化页内存位图</span></span><br><span class="line">   <span class="keyword">call</span> setup_page</span><br><span class="line"></span><br><span class="line">   <span class="comment">;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span></span><br><span class="line">   <span class="keyword">sgdt</span> [gdt_ptr]	      <span class="comment">; 存储到原来gdt所有的位置</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt描述符中视频段描述符中的段基址+0xc0000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [gdt_ptr + <span class="number">2</span>]  </span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">0x18</span> + <span class="number">4</span>], <span class="number">0xc0000000</span>      <span class="comment">;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span></span><br><span class="line">					      <span class="comment">;段描述符的高4字节的最高位是段基址的31~24位</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">dword</span> [gdt_ptr + <span class="number">2</span>], <span class="number">0xc0000000</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">0xc0000000</span>        <span class="comment">; 将栈指针同样映射到内核地址</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 把页目录地址赋给cr3</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr3</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 打开cr0的pg位(第31位)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x80000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;在开启分页后,用gdt新的地址重新加载</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]             <span class="comment">; 重新加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="comment">;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.</span></span><br><span class="line"><span class="comment">;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.</span></span><br><span class="line">   <span class="keyword">jmp</span> SELECTOR_CODE:enter_kernel	  <span class="comment">;强制刷新流水线,更新gdt</span></span><br><span class="line"><span class="symbol">enter_kernel:</span>    </span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line">   <span class="keyword">call</span> kernel_init</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>, <span class="number">0xc009f000</span></span><br><span class="line">   <span class="keyword">jmp</span> KERNEL_ENTRY_POINT                 <span class="comment">; 用地址0x1500访问测试，结果ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span></span><br><span class="line"><span class="symbol">kernel_init:</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		<span class="comment">;ebx记录程序头表地址</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span>		<span class="comment">;cx记录程序头表中的program header数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		<span class="comment">;dx 记录program header尺寸,即e_phentsize</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">dx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">42</span>]	  <span class="comment">; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">28</span>]   <span class="comment">; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, KERNEL_BIN_BASE_ADDR</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">44</span>]    <span class="comment">; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span></span><br><span class="line"><span class="symbol">.each_segment:</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">byte</span> [<span class="built_in">ebx</span> + <span class="number">0</span>], PT_NULL		  <span class="comment">; 若p_type等于 PT_NULL,说明此program header未使用。</span></span><br><span class="line">   <span class="keyword">je</span> .PTNULL</span><br><span class="line"></span><br><span class="line">   <span class="comment">;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">16</span>]		  <span class="comment">; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span> + <span class="number">4</span>]			  <span class="comment">; 距程序头偏移量为4字节的位置是p_offset</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, KERNEL_BIN_BASE_ADDR	  <span class="comment">; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">eax</span>				  <span class="comment">; 压入函数memcpy的第二个参数:源地址</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">8</span>]			  <span class="comment">; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span></span><br><span class="line">   <span class="keyword">call</span> mem_cpy				  <span class="comment">; 调用mem_cpy完成段复制</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">12</span>				  <span class="comment">; 清理栈中压入的三个参数</span></span><br><span class="line"><span class="symbol">.PTNULL:</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">edx</span>				  <span class="comment">; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span></span><br><span class="line">   <span class="keyword">loop</span> .each_segment</span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span></span><br><span class="line"><span class="comment">;输入:栈中三个参数(dst,src,size)</span></span><br><span class="line"><span class="comment">;输出:无</span></span><br><span class="line"><span class="comment">;---------------------------------------------------------</span></span><br><span class="line"><span class="symbol">mem_cpy:</span>		      </span><br><span class="line">   <span class="keyword">cld</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ecx</span>		   <span class="comment">; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edi</span>, [<span class="built_in">ebp</span> + <span class="number">8</span>]	   <span class="comment">; dst</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span> + <span class="number">12</span>]	   <span class="comment">; src</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, [<span class="built_in">ebp</span> + <span class="number">16</span>]	   <span class="comment">; size</span></span><br><span class="line">   <span class="keyword">rep</span> <span class="keyword">movsb</span>		   <span class="comment">; 逐字节拷贝</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;恢复环境</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ecx</span>		</span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------   创建页目录及页表   ---------------</span></span><br><span class="line"><span class="symbol">setup_page:</span></span><br><span class="line"><span class="comment">;先把页目录占用的空间逐字节清0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">4096</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">.clear_page_dir:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="built_in">esi</span>], <span class="number">0</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .clear_page_dir</span><br><span class="line"></span><br><span class="line"><span class="comment">;开始创建页目录项(PDE)</span></span><br><span class="line"><span class="symbol">.create_pde:</span>				     <span class="comment">; 创建Page Directory Entry</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span> 			     <span class="comment">; 此时eax为第一个页表的位置及属性</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>				     <span class="comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span></span><br><span class="line"><span class="comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span></span><br><span class="line"><span class="comment">;   这是为将地址映射为内核地址做准备</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0x0</span>], <span class="built_in">eax</span>       <span class="comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0xc00</span>], <span class="built_in">eax</span>     <span class="comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span></span><br><span class="line">					     <span class="comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span></span><br><span class="line">   <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">4092</span>], <span class="built_in">eax</span>	     <span class="comment">; 使最后一个目录项指向页目录表自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;下面创建页表项(PTE)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">256</span>				     <span class="comment">; 1M低端内存 / 每页大小4k = 256</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 属性为7,US=1,RW=1,P=1</span></span><br><span class="line"><span class="symbol">.create_pte:</span>				     <span class="comment">; 创建Page Table Entry</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>],<span class="built_in">edx</span>			     <span class="comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">4096</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .create_pte</span><br><span class="line"></span><br><span class="line"><span class="comment">;创建内核其它页表的PDE</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x2000</span> 		     <span class="comment">; 此时eax为第二个页表的位置</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P  <span class="comment">; 页目录项的属性RW和P位为1,US为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">254</span>			     <span class="comment">; 范围为第769~1022的所有目录项数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">769</span></span><br><span class="line"><span class="symbol">.create_kernel_pde:</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">loop</span> .create_kernel_pde</span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">			   <span class="comment">;功能:读取硬盘n个扇区</span></span><br><span class="line"><span class="symbol">rd_disk_m_32:</span>	   </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">							 <span class="comment">; eax=LBA扇区号</span></span><br><span class="line">							 <span class="comment">; ebx=将数据写入的内存地址</span></span><br><span class="line">							 <span class="comment">; ecx=读入的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>	   <span class="comment">; 备份eax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">cx</span>		   <span class="comment">; 备份扇区数到di</span></span><br><span class="line"><span class="comment">;读写硬盘:</span></span><br><span class="line"><span class="comment">;第1步：设置要读取的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f2</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>            <span class="comment">;读取的扇区数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">esi</span>	   <span class="comment">;恢复ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址7~0位写入端口0x1f3</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f3</span>                       </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>                          </span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址15~8位写入端口0x1f4</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">8</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f4</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址23~16位写入端口0x1f5</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f5</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x0f</span>	   <span class="comment">;lba第24~27位</span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xe0</span>	   <span class="comment">; 设置7～4位为1110,表示lba模式</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f6</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第3步：向0x1f7端口写入读命令，0x20 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f7</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x20</span>                        </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第4步：检测硬盘状态</span></span><br><span class="line"><span class="symbol">  .not_ready:</span>		   <span class="comment">;测试0x1f7端口(status寄存器)的的BSY位</span></span><br><span class="line">      <span class="comment">;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x88</span>	   <span class="comment">;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x08</span></span><br><span class="line">      <span class="keyword">jnz</span> .not_ready	   <span class="comment">;若未准备好,继续等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第5步：从0x1f0端口读数据</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">di</span>	   <span class="comment">;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,</span></span><br><span class="line">			   <span class="comment">;在此先用这种方法,在后面内容会用到insw和outsw等</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">256</span>	   <span class="comment">;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span>	   </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f0</span></span><br><span class="line"><span class="symbol">  .go_on_read:</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">ax</span>,<span class="built_in">dx</span>		</span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">ebx</span>], <span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">2</span></span><br><span class="line">			  <span class="comment">; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。</span></span><br><span class="line">			  <span class="comment">; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，</span></span><br><span class="line">			  <span class="comment">; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，</span></span><br><span class="line">			  <span class="comment">; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，</span></span><br><span class="line">			  <span class="comment">; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,</span></span><br><span class="line">			  <span class="comment">; 故程序出会错,不知道会跑到哪里去。</span></span><br><span class="line">			  <span class="comment">; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。</span></span><br><span class="line">			  <span class="comment">; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.</span></span><br><span class="line">			  <span class="comment">; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,</span></span><br><span class="line">			  <span class="comment">; 也会认为要执行的指令是32位.</span></span><br><span class="line">			  <span class="comment">; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，</span></span><br><span class="line">			  <span class="comment">; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，</span></span><br><span class="line">			  <span class="comment">; 临时改变当前cpu模式到另外的模式下.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">loop</span> .go_on_read</span><br><span class="line">      <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;-------------	 loader和kernel   ----------</span></span><br><span class="line"></span><br><span class="line">LOADER_BASE_ADDR <span class="built_in">equ</span> <span class="number">0x900</span> </span><br><span class="line">LOADER_STACK_TOP <span class="built_in">equ</span> LOADER_BASE_ADDR</span><br><span class="line">LOADER_START_SECTOR <span class="built_in">equ</span> <span class="number">0x2</span></span><br><span class="line"></span><br><span class="line">KERNEL_BIN_BASE_ADDR <span class="built_in">equ</span> <span class="number">0x70000</span></span><br><span class="line">KERNEL_START_SECTOR <span class="built_in">equ</span> <span class="number">0x9</span></span><br><span class="line">KERNEL_ENTRY_POINT <span class="built_in">equ</span> <span class="number">0xc0001500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------   页表配置   ----------------</span></span><br><span class="line">PAGE_DIR_TABLE_POS <span class="built_in">equ</span> <span class="number">0x100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;--------------   gdt描述符属性  -----------</span></span><br><span class="line">DESC_G_4K   <span class="built_in">equ</span>	  <span class="number">1_00000000000000000000000b</span>   </span><br><span class="line">DESC_D_32   <span class="built_in">equ</span>	   <span class="number">1_0000000000000000000000b</span></span><br><span class="line">DESC_L	    <span class="built_in">equ</span>	    <span class="number">0_000000000000000000000b</span>	<span class="comment">;  64位代码标记，此处标记为0便可。</span></span><br><span class="line">DESC_AVL    <span class="built_in">equ</span>	     <span class="number">0_00000000000000000000b</span>	<span class="comment">;  cpu不用此位，暂置为0  </span></span><br><span class="line">DESC_LIMIT_CODE2  <span class="built_in">equ</span> <span class="number">1111_0000000000000000b</span></span><br><span class="line">DESC_LIMIT_DATA2  <span class="built_in">equ</span> DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2  <span class="built_in">equ</span> <span class="number">0000_000000000000000b</span></span><br><span class="line">DESC_P	    <span class="built_in">equ</span>		  <span class="number">1_000000000000000b</span></span><br><span class="line">DESC_DPL_0  <span class="built_in">equ</span>		   <span class="number">00_0000000000000b</span></span><br><span class="line">DESC_DPL_1  <span class="built_in">equ</span>		   <span class="number">01_0000000000000b</span></span><br><span class="line">DESC_DPL_2  <span class="built_in">equ</span>		   <span class="number">10_0000000000000b</span></span><br><span class="line">DESC_DPL_3  <span class="built_in">equ</span>		   <span class="number">11_0000000000000b</span></span><br><span class="line">DESC_S_CODE <span class="built_in">equ</span>		     <span class="number">1_000000000000b</span></span><br><span class="line">DESC_S_DATA <span class="built_in">equ</span>	  DESC_S_CODE</span><br><span class="line">DESC_S_sys  <span class="built_in">equ</span>		     <span class="number">0_000000000000b</span></span><br><span class="line">DESC_TYPE_CODE  <span class="built_in">equ</span>	      <span class="number">1000_00000000b</span>	<span class="comment">;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  </span></span><br><span class="line">DESC_TYPE_DATA  <span class="built_in">equ</span>	      <span class="number">0010_00000000b</span>	<span class="comment">;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span></span><br><span class="line"></span><br><span class="line">DESC_CODE_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + <span class="number">0x00</span></span><br><span class="line">DESC_DATA_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + <span class="number">0x00</span></span><br><span class="line">DESC_VIDEO_HIGH4 <span class="built_in">equ</span> (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + <span class="number">0x0b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;--------------   选择子属性  ---------------</span></span><br><span class="line">RPL0  <span class="built_in">equ</span>   <span class="number">00b</span></span><br><span class="line">RPL1  <span class="built_in">equ</span>   <span class="number">01b</span></span><br><span class="line">RPL2  <span class="built_in">equ</span>   <span class="number">10b</span></span><br><span class="line">RPL3  <span class="built_in">equ</span>   <span class="number">11b</span></span><br><span class="line">TI_GDT	 <span class="built_in">equ</span>   <span class="number">000b</span></span><br><span class="line">TI_LDT	 <span class="built_in">equ</span>   <span class="number">100b</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------------   页表相关属性    --------------</span></span><br><span class="line">PG_P  <span class="built_in">equ</span>   <span class="number">1b</span></span><br><span class="line">PG_RW_R	 <span class="built_in">equ</span>  <span class="number">00b</span> </span><br><span class="line">PG_RW_W	 <span class="built_in">equ</span>  <span class="number">10b</span> </span><br><span class="line">PG_US_S	 <span class="built_in">equ</span>  <span class="number">000b</span> </span><br><span class="line">PG_US_U	 <span class="built_in">equ</span>  <span class="number">100b</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------  program type 定义   --------------</span></span><br><span class="line">PT_NULL <span class="built_in">equ</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>编译并运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nasm -I include&#x2F; -o mbr.bin mbr.S</span><br><span class="line">sudo dd if&#x3D;mbr.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line">nasm -I include&#x2F; -o loader.bin loader.S</span><br><span class="line">sudo dd if&#x3D;loader.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;4 seek&#x3D;2 conv&#x3D;notrunc</span><br><span class="line">gcc -m32 -c -o kernel&#x2F;main.o kernel&#x2F;main.c</span><br><span class="line">ld kernel&#x2F;main.o -m elf_i386 -Ttext 0xc0001500 -e main -o kernel.bin</span><br><span class="line">sudo dd if&#x3D;kernel.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;200 seek&#x3D;9 conv&#x3D;notrunc</span><br><span class="line">sudo .&#x2F;bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-171300.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-171321.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-17-171337.png" alt=""><br>最终可以看出确实加载了内核，并跳转到一个死循环执行了。</p>
</li>
</ul>
<h2 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h2><h3 id="特权级转移"><a href="#特权级转移" class="headerlink" title="特权级转移"></a>特权级转移</h3><p>任务是由处理器执行的，任务在特权级变换时，本质上是处理器的当前特权级在变换，由一个特权级变成了另外一个特权级。</p>
<p>特权级转移分为两类，一类是由中断门、调用门等手段实现低特权级转向高特权级，另一类则相反，是由调用返回指令从高特权级返回到低特权级，这是唯一一种能让处理器降低特权级的情况。</p>
<ol>
<li><p>对于第1种<strong>特权级由低到高的情况</strong></p>
<ul>
<li>由于不知道目标特权级对应的栈地址在哪里，所以要提前把目标栈的地址记录在某个地方，当处理器向高特权级转移时再从中取出来加载到SS和ESP中以更新栈，这个保存的地方就是TSS。处理器会自动地从TSS中找到对应的高特权级栈地址，这一点对开发人员是透明的，只需要在TSS中记录好高特权级的栈地址便可。</li>
</ul>
</li>
<li><p>对于第2种<strong>由高特权返回到低特权级的情况</strong></p>
<ul>
<li>处理器是不需要在TSS中去寻找低特权级目标栈的。当处理器由低向高特权级转移时，它自动地把当时低特权级的栈地址(SS 和 ESP)压入了转移后的高特权级所在的栈中。</li>
<li>所以，当用返回指令如retf或 iret从高特权级向低特权级返回时，处理器可以从当前使用的高特权级的栈中获取低特权级的栈段选择子及偏移量。由高特权级返回低特权级的过程称为“向外层转移”。</li>
</ul>
</li>
</ol>
<h3 id="CPL和DPL"><a href="#CPL和DPL" class="headerlink" title="CPL和DPL"></a>CPL和DPL</h3><p>计算机特权级的标签体现在DPL、CPL和RPL</p>
<ul>
<li><p>CPL</p>
<ul>
<li>位于CS寄存器中选择子低2位的值不仅称为请求特权级，又称为处理器的当前特权级，也就是说处理器的当前特权级是CS.RPL。</li>
<li>在CPU中运行的是指令，其运行过程中的指令总会属于某个代码段，该代码段的特权级，也就是代码段描述符中的 DPL，便是当前CPU所处的特权级，这个特权级称为当前特权级，即CPL(Current Privilege Level)，它表示处理器正在执行的代码的特权级别。除一致性代码段外，转移后的目标代码段的DPL是将来处理器的当前特权级CPL。</li>
<li><strong>在任意时刻，当前特权级CPL保存在CS选择子中的RPL部分</strong>。</li>
</ul>
</li>
<li><p>DPL</p>
<ul>
<li>DPL，即Descriptor Privilege Level，描述符特权级</li>
</ul>
</li>
<li><p>门描述符</p>
<ul>
<li>用于处理器从<strong>低特权级转移到高特权级</strong></li>
<li>门描述符所对应的代码段的DPL &lt;= CPL &lt;= 门描述符的DPL<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-105049.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="RPL"><a href="#RPL" class="headerlink" title="RPL"></a>RPL</h3><p><strong>如果仅通过CPL和DPL(满足CPL&lt;=DPL)来判断能否访问数据</strong>，如果通过门描述符进入了0特权级，则就可以访问任意数据，因为对于被访问的数据来说，请求访问的是最高特权级。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-153257.png" alt=""><br>如图，通过调用门后，是操作系统通过用户提供的数据段选择子在读取磁盘和写入数据，本意应该是写入用户缓冲区，但如果用户提供的是内核数据段，则写入了内核缓冲区，这就出问题了。</p>
<p>所以数据必须知道请求访问数据的真正请求对象的特权级是多少。</p>
<ul>
<li>RPL<ul>
<li>Request Privilege Level，即<strong>实际请求者的特权级，而不是代理请求者的特权级</strong></li>
<li>在请求某特权级为DPL级别的资源时，参与特权检查的不只是CPL，还要加上RPL。CPL和RPL的特权必须同时大于等于受访者的特权DPL。</li>
<li>下面这个例子很生动<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-155326.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-155659.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-155713.png" alt=""></p>
<p><em>当用户程序请求操作系统服务，如果需要提交选择子作为参数，为安全起见，操作系统会把选择子中的RPL改为用户程序的CPL，原理实际上是用户请求系统服务时肯定会进行一个特权级的变更，这就涉及到保存上下文和栈切换，这时就可以从栈里获取到真实的用户程序的CPL了。</em></p>
<p>事实上上面说的这些乱七八糟的特权级和门，在平坦模型下都很简单，因为平坦模型只需要两个特权级为3的用户数据/代码段描述符即可访问4GB用户数据/代码。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><h4 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h4><ul>
<li>参数的传递方式<ul>
<li>寄存器传递还是栈传递</li>
</ul>
</li>
<li>参数的传递顺序<ul>
<li>从左到右还是从右到左</li>
</ul>
</li>
<li>寄存器环境保存<ul>
<li>调用者保存寄存器环境，还是被调用者保存</li>
<li>保存哪些寄存器</li>
</ul>
</li>
<li>栈清理</li>
</ul>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-26-040146.png" alt=""></p>
<p>这里介绍x86平台上的两种调用约定:</p>
<ul>
<li>cdecl(C declaration)<ul>
<li>参数从右往左入栈</li>
<li>参数在栈中传递</li>
<li>eax/ecx/edx寄存器由调用者保存，其余由被调用者保存，返回值存储在eax里</li>
<li>调用者清理栈空间</li>
</ul>
</li>
<li>stdcall<ul>
<li>和cdecl基本一致，只是由被调用者清理栈空间</li>
</ul>
</li>
</ul>
<p>看一个stdcall的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; <span class="comment">//被调用者</span></span><br><span class="line"><span class="keyword">int</span> sub = subtract (<span class="number">3</span>,<span class="number">2</span>); <span class="comment">//主调用者</span></span><br></pre></td></tr></table></figure>
<ul>
<li>主调用者:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 从右到左将参数入栈 </span><br><span class="line">push <span class="number">2</span> ;压入参数b</span><br><span class="line">push <span class="number">3</span> ;压入参数a</span><br><span class="line">call subtract ;调用函数subtract</span><br></pre></td></tr></table></figure></li>
<li>被调用者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push ebp ;压入ebp备份</span><br><span class="line">mov ebp,esp ;将esp赋值给ebp</span><br><span class="line">mov eax,[ebp+0x8] ;用 ebp 作为基址来访问栈中参数,偏移8字节处为第1个参数a</span><br><span class="line">add eax,[ebp+0xc] ;偏移0xc字节处是第2个参数b,参数 a 和 b 相加后存入 eax </span><br><span class="line">mov esp,ebp ;为防止中间有入栈操作,用ebp恢复esp </span><br><span class="line">pop ebp ;将ebp恢复</span><br><span class="line">ret 8 ;数字8表示返回后使esp+8 ;函数返回时由被调函数清理了栈中参数</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="系统调用-syscall-传递参数的方式-x86"><a href="#系统调用-syscall-传递参数的方式-x86" class="headerlink" title="系统调用(syscall)传递参数的方式(x86)"></a>系统调用(syscall)传递参数的方式(x86)</h4><p>当输入的参数小于等于5个时，Linux用寄存器传递参数。当参数个数大于5个时，把参数按照顺序放入连续的内存区域，并将该区域的首地址放到ebx寄存器。</p>
<p>eax寄存器用来存储子功能号</p>
<p>5个参数存放在以下寄存器中，传送参数的顺序如下。</p>
<ul>
<li>ebx存储第1个参数。</li>
<li>ecx存储第2个参数。 </li>
<li>edx存储第3个参数。 </li>
<li>esi存储第4个参数。 </li>
<li>edi存储第5个参数。</li>
</ul>
<h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><p>中断就是发生了某种事件需要通知CPU处理，把中断按事件来源分类，来自CPU外部的中断就称为外部中断，来自CPU内部的中断称为内部中断。</p>
<ul>
<li>外部中断(按是否导致宕机)<ul>
<li>可屏蔽中断</li>
<li>不可屏蔽中断</li>
</ul>
</li>
<li>内部中断(按中断是否正常)<ul>
<li>软中断</li>
<li>异常</li>
</ul>
</li>
</ul>
<h4 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h4><p>CPU需要获得每个外部设备的中断信号,所以CPU中有两条接收中断的信号线，外部设备的中断信息都通过信号线通知CPU。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-022428.png" alt=""><br>CPU收到中断后，得知道发生了什么事情才能执行相应的处理办法。这是通过中断向量表或中断描述 符表(中断向量表是实模式下的中断处理程序数组，在保护模式下已经被中断描述符表代替)来实现的。</p>
<p>导致宕机的各种原因分配一个中断向量号就足够了，所以不可屏蔽中断的中断向量号为2。</p>
<h4 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h4><ul>
<li>软中断<ul>
<li>软中断，就是由软件主动发起的中断，因为它来自于软件，所以称之为软中断。由于该中断是软件运行中主动发起的，所以它是主观上的，并不是客观上的某种内部错误。</li>
<li>int 8位立即数(0-255)<ul>
<li>8位立即数可表示256种中断，这与处理器所支持的中断数是相吻合的。</li>
</ul>
</li>
</ul>
</li>
<li>异常<ul>
<li>int3(注意没有空格)<ul>
<li>bochs调试程序时，实际上就是调试器fork了一个子进程，子进程用于运行被调试的程序。调试器中经常要设置断点，其原理就是父进程修改了子进程的指令，将其用int3指令替换，从而子进程调用了int3指令触发中断。用此指令实现调试的原理是int3指令的机器码是0xcc，断点本质上是指令的地址，调试器(父进程)将被调试进程(子进程)断点起始地址的第1个字节备份好之后在原地将该指令的第1字节修改为0xcc。这样指令执行到断点处时，会去执行机器码为0xcc的int3指令，该指令会触发3号中断，从而会去执行3号中断对应的中断处理程序，由于中断处理程序在运行时也要用到寄存器，为了保存所调试进程的现场，该中断处理程序必须先将当前的寄存器和相关内存单元压栈保存(提醒，当前寄存器和相关内存都属于那个被调试的进程)，用户在查看寄存器和变量时就是从栈中获取的。当恢复执行所调试的进程时，中断处理程序需要将之前备份的1字节还原至断点处，然后恢复各寄存器和内存单元的值，修改返回地址为断点地址，用iret指令退出中断，返回到用户进程继续执行。</li>
<li>可以参考这篇，<a href="http://researchcomplete.blogspot.com/2016/08/on-subject-of-debuggers-and-tracers_5.html" target="_blank" rel="noopener">十分钟实现一个简单调试器</a></li>
</ul>
</li>
<li>into<ul>
<li>这是中断溢出指令，它所触发的中断向量号是4。不过，能否引发4号中断是要看eflags标志寄存器中的OF位是否为1，如果是1才会引发中断</li>
</ul>
</li>
<li>bound<ul>
<li>这是检查数组索引越界指令，它可以触发5号中断，用于检查数组的索引下标是否在上下边界之内。</li>
</ul>
</li>
<li>ud2<ul>
<li>未定义指令，这会触发第6号中断。该指令表示指令无效，CPU无法识别。主动使用它发起中断，常用于软件测试中，无实际用途。</li>
</ul>
</li>
<li>异常按照轻重程度，可以分为以下三种。<ul>
<li>Fault，也称为故障。这种错误是可以被修复的一种类型，属于最轻的一种异常，它给软件一次“改过自新”的机会。当发生此类异常时CPU将机器状态恢复到异常之前的状态，之后调用中断处理程序时，CPU将返回地址依然指向导致fault异常的那条指令。通常中断处理程序中会将此问题修复，待中断处理程序返回后便能重试。最典型的例子就是操作系统课程中所说的缺页异常page fault，话说Linux的虚拟内存就是基于page fault的，这充分说明这种异常是极易被修复的，甚至是有益的。</li>
<li>Trap，也称为陷阱，这一名称很形象地说明软件掉进了CPU设下的陷阱，导致停了下来。此异常通常用在调试中，比如int3指令便引发此类异常，为了让中断处理程序返回后能够继续向下执行，CPU将中断处理程序的返回地址指向导致异常指令的下一个指令地址。</li>
<li>Abort，也称为终止，从名字上看，这是最严重的异常类型，一旦出现，由于错误无法修复，程序将无法继续运行，操作系统为了自保，只能将此程序从进程表中去掉。导致此异常的错误通常是硬件错误，或者某些系统数据结构出错。某些异常会有单独的错误码，即error code，进入中断时CPU会把它们压在栈中，这是在压入eip之后做的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h3><h4 id="中断向量和中断向量表-IVT"><a href="#中断向量和中断向量表-IVT" class="headerlink" title="中断向量和中断向量表(IVT)"></a>中断向量和中断向量表(IVT)</h4><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-072144.png" alt=""></p>
<p>中断机制的本质是来了一个中断信号后，调用相应的中断处理程序。</p>
<p>所以，CPU不管有多少种类型的中断，为了统一中断管理，把来自外部设备、内部指令的各种中断类型统统归结为一种管理方式，即为每个中断信号分配一个整数，用此整数作为中断的ID，而这个整数就是所谓的中断向量，然后用此ID作为中断描述符表中的索引，这样就能找到对应的表项，进而从中找到对应的中断处理程序。</p>
<p>中断向量的作用和选择子类似，它们都用来在描述符表中索引一个描述符，只不过选择子用于在GDT或LDT中检索段描述符，而中断向量专用于中断描述符表。</p>
<p><strong>异常和不可屏蔽中断的中断向量号是由CPU自动提供的，而来自外部设备的可屏蔽中断号是由中断代理提供的，软中断是由软件提供的</strong></p>
<p>一个中断源就会产生一个中断向量，每个中断向量都对应中断描述符表中的一个门描述符，任何中断 源都通过中断向量对应到中断描述符表中的门描述符，通过该门描述符就找到了对应的中断处理程序。可见，中断发生后，采取什么样的动作是由中断处理程序决定的。</p>
<p>在实模式下，IVT位于地址0~0x3ff，它是实模式下用于存储中断处理程序入口的表。</p>
<p>由于实模式下功能有限，运行机制比较“死板”，所以它的位置是固定的，必须位于最低端。</p>
<p>已知0~0x3ff共1024个字节，又知IVT可容纳256个中断向量，所以每个中断向量用4字节描述。</p>
<h4 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h4><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-085846.jpg" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-085529.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-085548.png" alt=""></p>
<ol>
<li>任务门<br>任务门和任务状态段(Task Status Segment，TSS)是Intel处理器在硬件一级提供的任务切换机制，所以任务门需要和TSS配合在一起使用，在任务门中记录的是TSS选择子，偏移量未使用。任务门可以存在于全局描述符表GDT、局部描述符表LDT、中断描述符表IDT中。描述符中任务门的type值为二进制0101，其结构如图7-2所示。顺便说一句大多数操作系统(包括Linux)都未用TSS实现任务切换，咱们这里也不讨论啦。</li>
<li>中断门<br>中断门包含了<strong>中断处理程序所在段的段选择子</strong>和<strong>段内偏移地址</strong>。当通过此方式进入中断后，<strong>标志寄存器eflags中的IF位自动置0</strong>，也就是在进入中断后，自动把中断关闭，<strong>避免中断嵌套</strong>。Linux就是利用中断门实现的系统调用，就是那个著名的int0x80。中断门只允许存在于IDT中。描述符中中断门的type值为二进制1110，其结构如图7-3所示。</li>
<li>陷阱门<br>陷阱门和中断门非常相似，区别是由陷阱门进入中断后，标志寄存器eflags中的IF位不会自动置0。陷阱门只允许存在于IDT中。描述符中陷阱门的type值为二进制1111。其结构如图7-4所示。</li>
<li>调用门<br>调用门是提供给用户进程进入特权0级的方式，其DPL为3。调用门中记录例程的地址，它不能用int指令调用，只能用call和jmp指令。调用门可以安装在GDT和LDT中。描述符中调用门的type值为二进制1100。其结构如图7-5所示。</li>
</ol>
<p>这里提到了关于eflags的if标志位，if代表的是中断启用flag，如果为0就不接受中断。<br>但是中断可以无视eflags中的IF位，可以这么理解: </p>
<p>(1)首先，只要是导致运行错误的中断类型都会无视IF位，不受IF位的管束，如 NMI、异常。 </p>
<p>(2)其次，由于int n型的软中断用于实现系统调用功能，不能因为IF位为 0 就不顾用户请求，所以为了用户功能正常，软中断必须也无视IF位。</p>
<p>总结:只要中断关系到“正常”运行，就不受IF位影响。</p>
<p>对比中断向量表，中断描述符表有两个区别。 </p>
<ol>
<li>中断描述符表地址不限制，在哪里都可以。</li>
<li>中断描述符表中的每个描述符用8字节描述。</li>
</ol>
<p>IDTR(Interrupt Descriptor Table Register)寄存器保存中断描述符表的地址。</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-090904.png" alt=""><br>通过<code>lidt 48位内存数据</code>, 前16位是IDT表界限，后32位是IDT线性基地址。</p>
<p>处理器只支持256个中断，即0~255，中断描述符中其余的描述符不可用。</p>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><h4 id="中断处理的过程和权限检查"><a href="#中断处理的过程和权限检查" class="headerlink" title="中断处理的过程和权限检查"></a>中断处理的过程和权限检查</h4><ol>
<li>根据中断向量号定位中断描述符。</li>
<li>处理器进行特权级检查<ul>
<li>由于中断是通过中断向量号通知到处理器的，中断向量号只是个整数，其中并没有 RPL，所以在对由中断引起的特权级转移做特权级检查中，并不涉及到 RPL。</li>
<li>如果是由软中断int n、int3和into引发的中断<ul>
<li><strong>目标代码段DPL(门框) &lt;= CPL &lt;= 门描述符DPL(门槛)</strong></li>
<li>解释一下，之所以特权级要小于目标代码段的DPL，是因为如果当前特权级已经大于门处理程序的特权级了，那也就等于是高特权级向低特权级转移，这是不允许的。</li>
<li>之所以特权级要大于门描述符DPL，是因为指定的门描述符可能不开放给用户程序使用，只是限定给内核的，所以这就是个门槛。</li>
<li>所以之所以叫门，就是因为要特权级能超过门槛，但是不超过门框。</li>
</ul>
</li>
<li>若中断是由外部设备和异常引起的，只直接检查CPL和目标代码段的 DPL</li>
</ul>
</li>
<li>执行中断处理程序<ul>
<li>特权级检查通过后，将门描述符目标代码段选择子加载到代码段寄存器CS中，把门描述符中中断处理程序的偏移地址加载到EIP，开始执行中断处理程序。</li>
</ul>
</li>
</ol>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-160520.png" alt=""></p>
<h4 id="中断处理程序执行时的栈变化和上下文保存"><a href="#中断处理程序执行时的栈变化和上下文保存" class="headerlink" title="中断处理程序执行时的栈变化和上下文保存"></a>中断处理程序执行时的栈变化和上下文保存</h4><ul>
<li><p>特权级由低到高<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-161949.png" alt=""></p>
</li>
<li><p>特权级不变<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-27-162015.png" alt=""></p>
</li>
<li><p>从中断中返回</p>
<ul>
<li>注意ERROR_CODE需要中断处理程序自己去处理，即手动弹出</li>
<li>iret<ul>
<li>在执行iret时，sp应指向<code>eip_old</code>，此指令依次从栈中还原ip和寄存器环境，切换回之前的特权级，即中断门结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h4><p>错误码其实也是保存了一个描述符的选择子，只是它可以选择的表有很多种；<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-28-020347.png" alt=""><br>根据TI来决定是LDT还是GDT，根据IDT决定是否是选择中断描述符表。</p>
<p>EXT表示EXTernal event，即外部事件，用来指明中断源是否来自处理器外部，如果中断源是不可屏蔽中断NMI或外部设备，EXT为1，否则为0。</p>
<h3 id="实现中断"><a href="#实现中断" class="headerlink" title="实现中断"></a>实现中断</h3><p>先将预先实现好的打印函数放在lib/kernel目录下，将函数声明放在<code>print.h</code>里，如果需要使用就导入<code>print.h</code>并链接好即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ tree</span><br><span class="line">.</span><br><span class="line">├── bochs</span><br><span class="line">├── bochs.out</span><br><span class="line">├── bochsrc.disk</span><br><span class="line">├── boot</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── boot.inc</span><br><span class="line">│   ├── loader.S</span><br><span class="line">│   └── mbr.S</span><br><span class="line">├── bxcommit</span><br><span class="line">├── bximage</span><br><span class="line">├── hd60M.img</span><br><span class="line">├── kernel</span><br><span class="line">│   ├── main.c</span><br><span class="line">│   └── main.o</span><br><span class="line">├── kernel.bin</span><br><span class="line">├── lib</span><br><span class="line">│   ├── kernel</span><br><span class="line">│   │   ├── print.h</span><br><span class="line">│   │   ├── print.o</span><br><span class="line">│   │   └── print.S</span><br><span class="line">│   └── user</span><br><span class="line">├── loader.bin</span><br><span class="line">└── mbr.bin</span><br></pre></td></tr></table></figure>
<p>先测试一下效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf -o lib&#x2F;kernel&#x2F;print.o lib&#x2F;kernel&#x2F;print.S</span><br><span class="line">gcc -m32 -I lib&#x2F;kernel&#x2F; -c -o kernel&#x2F;main.o kernel&#x2F;main.c</span><br><span class="line">ld kernel&#x2F;main.o lib&#x2F;kernel&#x2F;print.o -m elf_i386 -Ttext 0xc0001500 -e main -o kernel.bin</span><br><span class="line">sudo dd if&#x3D;kernel.bin of&#x3D;hd60M.img bs&#x3D;512 count&#x3D;200 seek&#x3D;9 conv&#x3D;notrunc</span><br><span class="line">sudo .&#x2F;bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-28-140953.png" alt=""></p>
<ul>
<li>init_all<ul>
<li>idt_init<ul>
<li>idt_desc_init<ul>
<li>准备中断处理函数</li>
<li>准备中断描述符表</li>
</ul>
</li>
</ul>
</li>
<li>加载idt</li>
</ul>
</li>
</ul>
<ol>
<li><p>首先定义中断处理函数，因为这里每个中断处理函数都只是简单的打印出”interrupt occur!”，所以我使用一个宏来实现这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">%define ERROR_CODE nop		 ; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.</span><br><span class="line">%define ZERO push 0		 ; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0</span><br><span class="line"></span><br><span class="line">extern put_str			 ;声明外部函数</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">intr_str db &quot;interrupt occur!&quot;, 0xa, 0</span><br><span class="line">global intr_entry_table</span><br><span class="line">intr_entry_table:</span><br><span class="line"></span><br><span class="line">%macro VECTOR 2</span><br><span class="line">section .text</span><br><span class="line">intr%1entry:		 ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少</span><br><span class="line">   %2</span><br><span class="line">   push intr_str</span><br><span class="line">   call put_str</span><br><span class="line">   add esp,4			 ; 跳过参数</span><br><span class="line"></span><br><span class="line">   add esp,4			 ; 跨过error_code</span><br><span class="line">   iret				 ; 从中断返回,32位下等同指令iretd</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">   dd    intr%1entry	 ; 存储各个中断入口程序的地址，形成intr_entry_table数组</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">VECTOR 0x00,ZERO</span><br><span class="line">VECTOR 0x01,ZERO</span><br><span class="line">VECTOR 0x02,ZERO</span><br><span class="line">VECTOR 0x03,ZERO </span><br><span class="line">VECTOR 0x04,ZERO</span><br><span class="line">VECTOR 0x05,ZERO</span><br><span class="line">VECTOR 0x06,ZERO</span><br><span class="line">VECTOR 0x07,ZERO </span><br><span class="line">VECTOR 0x08,ERROR_CODE</span><br><span class="line">VECTOR 0x09,ZERO</span><br><span class="line">VECTOR 0x0a,ERROR_CODE</span><br><span class="line">VECTOR 0x0b,ERROR_CODE </span><br><span class="line">VECTOR 0x0c,ZERO</span><br><span class="line">VECTOR 0x0d,ERROR_CODE</span><br><span class="line">VECTOR 0x0e,ERROR_CODE</span><br><span class="line">VECTOR 0x0f,ZERO </span><br><span class="line">VECTOR 0x10,ZERO</span><br><span class="line">VECTOR 0x11,ERROR_CODE</span><br><span class="line">VECTOR 0x12,ZERO</span><br><span class="line">VECTOR 0x13,ZERO </span><br><span class="line">VECTOR 0x14,ZERO</span><br><span class="line">VECTOR 0x15,ZERO</span><br><span class="line">VECTOR 0x16,ZERO</span><br><span class="line">VECTOR 0x17,ZERO </span><br><span class="line">VECTOR 0x18,ERROR_CODE</span><br><span class="line">VECTOR 0x19,ZERO</span><br><span class="line">VECTOR 0x1a,ERROR_CODE</span><br><span class="line">VECTOR 0x1b,ERROR_CODE </span><br><span class="line">VECTOR 0x1c,ZERO</span><br><span class="line">VECTOR 0x1d,ERROR_CODE</span><br><span class="line">VECTOR 0x1e,ERROR_CODE</span><br><span class="line">VECTOR 0x1f,ZERO </span><br><span class="line">VECTOR 0x20,ZERO</span><br></pre></td></tr></table></figure>
<p>编译器会将属性相同的section合并到同一个大的segment中，<strong>所以最终我们可以得到一个函数指针数组intr_entry_table</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intr_entry_table:</span><br><span class="line">   dd    intr00entry(中断处理函数0的地址)</span><br><span class="line">   dd    intr01entry</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>汇编里<code>label:</code>这种形式，label代表的就是一个地址。</p>
</li>
<li><p>创建中断描述符表IDT</p>
</li>
</ol>
<p>中断描述符表就是如图的中断描述符连续放在一起，每个四字节。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-28-145521.png" alt=""><br>于是我们可以创建一个结构体数组来表示一个中断描述符表,并依次给每个字段赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"interrupt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"global.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDT_DESC_CNT 0x21	 <span class="comment">// 目前总共支持的中断数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断门描述符结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint16_t</span>    func_offset_low_word;</span><br><span class="line">   <span class="keyword">uint16_t</span>    selector;</span><br><span class="line">   <span class="keyword">uint8_t</span>     dcount;   <span class="comment">//此项为双字计数字段，是门描述符中的第4字节。此项固定值，不用考虑</span></span><br><span class="line">   <span class="keyword">uint8_t</span>     attribute;</span><br><span class="line">   <span class="keyword">uint16_t</span>    func_offset_high_word;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数声明,非必须</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_idt_desc</span><span class="params">(struct gate_desc* p_gdesc, <span class="keyword">uint8_t</span> attr, intr_handler function)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span> <span class="title">idt</span>[<span class="title">IDT_DESC_CNT</span>];</span>   <span class="comment">// idt是中断描述符表,本质上就是个中断门描述符数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> intr_handler intr_entry_table[IDT_DESC_CNT];	    <span class="comment">// 声明引用定义在kernel.S中的中断处理函数入口数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建中断门描述符 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_idt_desc</span><span class="params">(struct gate_desc* p_gdesc, <span class="keyword">uint8_t</span> attr, intr_handler function)</span> </span>&#123; </span><br><span class="line">   p_gdesc-&gt;func_offset_low_word = (<span class="keyword">uint32_t</span>)function &amp; <span class="number">0x0000FFFF</span>;</span><br><span class="line">   p_gdesc-&gt;selector = SELECTOR_K_CODE;</span><br><span class="line">   p_gdesc-&gt;dcount = <span class="number">0</span>;</span><br><span class="line">   p_gdesc-&gt;attribute = attr;</span><br><span class="line">   p_gdesc-&gt;func_offset_high_word = ((<span class="keyword">uint32_t</span>)function &amp; <span class="number">0xFFFF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化中断描述符表*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">idt_desc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++) &#123;</span><br><span class="line">      make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); </span><br><span class="line">   &#125;</span><br><span class="line">   put_str(<span class="string">"   idt_desc_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>加载idt</li>
</ol>
<p>通过汇编<code>lidt 48位数据</code>来将我们初始化好的中断门描述符数组的地址加载到idt寄存器里，这样中段描述符表的基地址就有了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 加载idt */</span></span><br><span class="line"><span class="keyword">uint64_t</span> idt_operand = ((<span class="keyword">sizeof</span>(idt) - <span class="number">1</span>) | ((<span class="keyword">uint64_t</span>)(<span class="keyword">uint32_t</span>)idt &lt;&lt; <span class="number">16</span>));</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lidt %0"</span> : : <span class="string">"m"</span> (idt_operand))</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-09-28-152958.png" alt=""></p>
<h2 id="内存管理系统"><a href="#内存管理系统" class="headerlink" title="内存管理系统"></a>内存管理系统</h2><h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><p><a href="https://seisman.github.io/how-to-write-makefile/" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/</a></p>
<h3 id="实现assert和字符串处理函数"><a href="#实现assert和字符串处理函数" class="headerlink" title="实现assert和字符串处理函数"></a>实现assert和字符串处理函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = str;</span><br><span class="line">    <span class="keyword">while</span> (*p++);</span><br><span class="line">    <span class="keyword">return</span> p - <span class="number">1</span> - str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意<code>*p</code>解引用得到<code>&#39;\0&#39;</code>的时候while循环终止，但是p++还是会执行，所以指向的是<code>&#39;\0&#39;+1</code>的位置。</p>
<h3 id="位图bitmap"><a href="#位图bitmap" class="headerlink" title="位图bitmap"></a>位图bitmap</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-08-091322.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *bits;<span class="comment">//整体上以字节为单位，细节上以位为单位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> btmp_bytes_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_init</span><span class="params">(struct bitmap *btmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bitmap_scan_test</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> bit_idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> cnt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_set</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> bit_idx, <span class="keyword">int8_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化bitmap为全0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_init</span><span class="params">(struct bitmap *btmp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(btmp-&gt;bits, <span class="number">0</span>, btmp-&gt;btmp_bytes_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断bit_idx位是否为1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bitmap_scan_test</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> bit_idx)</span> </span>&#123;<span class="comment">//bit_idx从0开始计数</span></span><br><span class="line">    assert(bit_idx &lt; btmp-&gt;btmp_bytes_len * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> bit_odd = bit_idx % <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请连续cnt个位，如果成功则返回起始下标，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> idx_byte = <span class="number">0</span>; <span class="comment">//用于记录空闲位所在的字节</span></span><br><span class="line">    <span class="comment">//先逐字节比较</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len)) &#123;</span><br><span class="line">        <span class="comment">//若该字节全1，则代表没有空闲位，到下一字节继续找</span></span><br><span class="line">        idx_byte++;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len) &#123;<span class="comment">//若该内存池找不到可用空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若在位图数组范围内的某字节内找到了空闲位，在该字节内逐位对比，返回空闲位的索引</span></span><br><span class="line">    <span class="keyword">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 和btmp-&gt;bits[idx_byte]这个字节逐位对比,即从第0位开始在字节内依次比较是不是1，如果不是就停止，即遇到空闲位就停止。</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">uint8_t</span>) (BITMAP_MASK &lt;&lt; idx_bit) &amp; btmp-&gt;bits[idx_byte]) &#123;</span><br><span class="line">        idx_bit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit;<span class="comment">//空闲位在位图的下标</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start);<span class="comment">//记录还有多少位可以判断</span></span><br><span class="line">    <span class="comment">//从下一位开始继续判断</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">1</span>;<span class="comment">//记录找到的空闲位的个数</span></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>;<span class="comment">//先将其置为-1，如果找不到连续的位就返回</span></span><br><span class="line">    <span class="comment">// 这个实现其实有个越界</span></span><br><span class="line">    <span class="comment">// 例如，bit_left初始是7，next_bit初始是2</span></span><br><span class="line">    <span class="comment">// 循环共循环7次，每次循环结束的时候next_bit加一，所以next_bit在最后一次开始</span></span><br><span class="line">    <span class="comment">// 时值为2+6=8，这就越界了，因为一共有8位，next_bit为8，就代表第9位了。</span></span><br><span class="line">    <span class="comment">//0 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="comment">//1 0 | 1 1 1 1 1 1</span></span><br><span class="line">    <span class="comment">//所以应该是uint32_t bit_left = (btmp-&gt;btmp_bytes_len * 8 - bit_idx_start) - 1</span></span><br><span class="line">    <span class="keyword">while</span> (bit_left-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bitmap_scan_test(btmp, next_bit))) &#123;<span class="comment">//若next_bit为0</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == cnt) &#123;<span class="comment">//若找到连续的cnt个空位</span></span><br><span class="line">            bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_bit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将位图btmp的bit_idx位设置为value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_set</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> bit_idx, <span class="keyword">int8_t</span> value)</span> </span>&#123;</span><br><span class="line">    assert(value == <span class="number">0</span> || value == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> bit_odd = bit_idx % <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">bm</span>;</span></span><br><span class="line">    bm.btmp_bytes_len = <span class="number">1</span>;</span><br><span class="line">    bitmap_init(&amp;bm);</span><br><span class="line">    bm.bits[<span class="number">0</span>] |= <span class="number">0xfd</span>;</span><br><span class="line">    bitmap_scan(&amp;bm, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存池的规划"><a href="#内存池的规划" class="headerlink" title="内存池的规划"></a>内存池的规划</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-08-125633.png" alt=""><br>内核也通过内存管理系统申请内存，为此，它也要有个虚拟地址池，当它申请内存时，从内核自己的虚拟地址池中分配虚 拟地址，再从内核物理内存池(内核专用)中分配物理内存，然后在内核自己的页表将这两种地址建立好映射关系。</p>
<p>对用户进程来说，它向内存管理系统，即操作系统，申请内存时，操作系统先从用户进程自己的虚拟地址池中分配空闲虚拟地址，然后再从用户物理内存池(所有用户进程共享)中分配空闲的物理内存，然 后在该用户进程自己的页表将这两种地址建立好映射关系。</p>
<p>为方便管理，虚拟地址池中的地址单位也是4KB，这样虚拟地址便于和物理地址做完整页的映射。</p>
<ul>
<li>内存池的实现<ul>
<li>定义好<strong>内核虚拟地址池</strong>和<strong>内核/用户物理地址池</strong>两种数据结构</li>
<li>初始化其bitmap保存的地址，以及其从哪里开始分配<strong>内核堆虚拟内存</strong>/<strong>内核/用户堆物理内存</strong><ul>
<li>从总的物理内存里除去被页表和页目录表以及内核占用的内存，就是剩下可用来分配的物理内存。</li>
<li>从3GB开始是内核虚拟地址空间，其首1MB字节保存内核，再往上就是可以分配的堆虚拟地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *bits;<span class="comment">//整体上以字节为单位，细节上以位为单位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> btmp_bytes_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_init</span><span class="params">(struct bitmap *btmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bitmap_scan_test</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> bit_idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> cnt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_set</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> bit_idx, <span class="keyword">int8_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span><span class="comment">//虚拟地址池，用于虚拟地址管理</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span><span class="comment">//虚拟地址用到的位图结构</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr_start; <span class="comment">//虚拟地址起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_SIZE 4096 <span class="comment">//表示页的尺寸</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************ 位图地址 *****************************</span></span><br><span class="line"><span class="comment">因为 0xc009f000 是内核主线程栈顶，0xc009e000 是内核主线程的 pcb。</span></span><br><span class="line"><span class="comment">一个页框大小（4KB)的位图可表示 128MB 内存(4KB*8*4KB=128MB)，位图位置安排在地址 0xc009a000，</span></span><br><span class="line"><span class="comment">这样本系统最大支持 4 个页框的位图，即 512MB */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0xc0000000是内核从虚拟地址3G起。</span></span><br><span class="line"><span class="comment">0x100000 意指跨过低端 1MB 内存，使虚拟地址在逻辑上连续 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 loader 中我们已经通过设置页表把虚拟地址 0xc0000000~0xc00fffff 映射到了物理地址</span></span><br><span class="line"><span class="comment">//0x00000000~ 0x000fffff(低端 1MB 的内存)，故我们为了让虚拟地址连续，</span></span><br><span class="line"><span class="comment">//将堆的起始虚拟地址设为 0xc0100000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K_HEAP_START 0xc0100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存池结构，生成两个实例用于管理内核内存池和用户内存池 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span><span class="comment">//本内存池用到的位图结构，用于管理物理内存</span></span><br><span class="line">    <span class="keyword">uint32_t</span> phy_addr_start; <span class="comment">//本内存池所管理的物理内存的起始地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pool_size;<span class="comment">//本内存池字节容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span><span class="comment">//生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span><span class="comment">//此结构用来给内核分配虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化内存池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mem_pool_init</span><span class="params">(<span class="keyword">uint32_t</span> all_mem)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"mem pool init start\n"</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> page_table_size = PG_SIZE * <span class="number">256</span>;<span class="comment">//记录页目录表和页表占用的字节大小</span></span><br><span class="line">    <span class="comment">//页表大小=1页的页目录表+0/768页目录项指向同一个页表 + 769-1022个页目录项共254个页表，</span></span><br><span class="line">    <span class="comment">// 共要256个页框，因为1023页目录项指向页目录表自己，所以不重复算空间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> used_mem = page_table_size + <span class="number">0x100000</span>;<span class="comment">//低端1MB内存包括bootloader和kernel等都保存在这里，所以我们认为它已经被使用了</span></span><br><span class="line">    <span class="keyword">uint32_t</span> free_mem = all_mem - used_mem;</span><br><span class="line">    <span class="keyword">uint16_t</span> all_free_pages = free_mem / PG_SIZE;</span><br><span class="line">    <span class="keyword">uint16_t</span> kernel_free_pages = all_free_pages / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为简化位图操作，余数不处理</span></span><br><span class="line">    <span class="keyword">uint32_t</span> kbm_length = kernel_free_pages / <span class="number">8</span>; <span class="comment">//kernel bitmap的长度，位图中的一位表示一页，以字节为单位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ubm_length = user_free_pages / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> kp_start = used_mem;<span class="comment">//内核内存池的起始地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE;<span class="comment">//用户内存池的起始地址</span></span><br><span class="line"></span><br><span class="line">    kernel_pool.phy_addr_start = kp_start;</span><br><span class="line">    user_pool.phy_addr_start = up_start;</span><br><span class="line">    kernel_pool.pool_size = kernel_free_pages * PG_SIZE;</span><br><span class="line">    user_pool.pool_size = user_free_pages * PG_SIZE;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line">    user_pool.pool_bitmap.btmp_bytes_len = ubm_length;</span><br><span class="line">    <span class="comment">/********* 内核内存池和用户内存池位图 *********** * 位图是全局的数据，长度不固定。</span></span><br><span class="line"><span class="comment">    * 全局或静态的数组需要在编译时知道其长度，</span></span><br><span class="line"><span class="comment">    * 而我们需要根据总内存大小算出需要多少字节，</span></span><br><span class="line"><span class="comment">    * 所以改为指定一块内存来生成位图。</span></span><br><span class="line"><span class="comment">    * ************************************************/</span></span><br><span class="line">    <span class="comment">// 内核使用的最高地址是 0xc009f000，这是主线程的栈地址</span></span><br><span class="line">    <span class="comment">//(内核的大小预计为 70KB 左右) // 32MB内存占用的位图是2KB</span></span><br><span class="line">    <span class="comment">//内核内存池的位图先定在 MEM_BITMAP_BASE(0xc009a000)处</span></span><br><span class="line">    kernel_pool.pool_bitmap.bits = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span> *&gt;((<span class="keyword">void</span> *) MEM_BITMAP_BASE);</span><br><span class="line">    user_pool.pool_bitmap.bits = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span> *&gt;((<span class="keyword">void</span> *) (MEM_BITMAP_BASE + kbm_length));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"kernel_pool bitmap_start:"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, kernel_pool.pool_bitmap.bits);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"kernel_pool phy_addr_start:"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, kernel_pool.phy_addr_start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"user_pool bitmap_start:"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, user_pool.pool_bitmap.bits);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"user_pool phy_addr_start:"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, user_pool.phy_addr_start);</span><br><span class="line">    <span class="comment">//将位图置为0</span></span><br><span class="line">    bitmap_init(&amp;kernel_pool.pool_bitmap);</span><br><span class="line">    bitmap_init(&amp;user_pool.pool_bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面初始化内核虚拟地址的位图，按实际物理内存大小生成数组。*/</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;<span class="comment">// 用于维护内核堆的虚拟地址，所以要和内核内存池大小一致</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.bits = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span> *&gt;((<span class="keyword">void</span> *) (MEM_BITMAP_BASE + kbm_length + ubm_length));</span><br><span class="line"></span><br><span class="line">    kernel_vaddr.vaddr_start = K_HEAP_START;</span><br><span class="line">    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"mem_pool init done\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"mem_init start\n"</span>);</span><br><span class="line"><span class="comment">//    uint32_t mem_bytes_total = *(uint32_t *) (0xb00);</span></span><br><span class="line">    mem_pool_init(<span class="number">33554432</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"mem_init done\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mem_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-09-083104.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ tree</span><br><span class="line">.</span><br><span class="line">├── bochs</span><br><span class="line">├── bochs.out</span><br><span class="line">├── bochsrc.disk</span><br><span class="line">├── boot</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── boot.inc</span><br><span class="line">│   ├── loader.S</span><br><span class="line">│   └── mbr.S</span><br><span class="line">├── build</span><br><span class="line">│   ├── bitmap.o</span><br><span class="line">│   ├── debug.o</span><br><span class="line">│   ├── init.o</span><br><span class="line">│   ├── interrupt.o</span><br><span class="line">│   ├── kernel.bin</span><br><span class="line">│   ├── kernel.map</span><br><span class="line">│   ├── kernel.o</span><br><span class="line">│   ├── main.o</span><br><span class="line">│   ├── memory.o</span><br><span class="line">│   ├── print.o</span><br><span class="line">│   ├── string.o</span><br><span class="line">│   └── timer.o</span><br><span class="line">├── bxcommit</span><br><span class="line">├── bximage</span><br><span class="line">├── device</span><br><span class="line">│   ├── timer.c</span><br><span class="line">│   └── timer.h</span><br><span class="line">├── hd60M.img</span><br><span class="line">├── kernel</span><br><span class="line">│   ├── debug.c</span><br><span class="line">│   ├── debug.h</span><br><span class="line">│   ├── global.h</span><br><span class="line">│   ├── init.c</span><br><span class="line">│   ├── init.h</span><br><span class="line">│   ├── interrupt.c</span><br><span class="line">│   ├── interrupt.h</span><br><span class="line">│   ├── kernel.S</span><br><span class="line">│   ├── main.c</span><br><span class="line">│   ├── memory.c</span><br><span class="line">│   └── memory.h</span><br><span class="line">├── lib</span><br><span class="line">│   ├── kernel</span><br><span class="line">│   │   ├── bitmap.c</span><br><span class="line">│   │   ├── bitmap.h</span><br><span class="line">│   │   ├── io.h</span><br><span class="line">│   │   ├── print.h</span><br><span class="line">│   │   └── print.S</span><br><span class="line">│   ├── stdint.h</span><br><span class="line">│   ├── string.c</span><br><span class="line">│   ├── string.h</span><br><span class="line">│   └── user</span><br><span class="line">└── makefile</span><br></pre></td></tr></table></figure>

<h3 id="分配页内存"><a href="#分配页内存" class="headerlink" title="分配页内存"></a>分配页内存</h3><p>页表的作用是将虚拟地址转换成物理地址，此工作表面虚幻，但内心真实，其 转换过程中涉及访问的页目录表、页目录项及页表项，都是通过真实物理地址访问的，否则若用虚拟地址访问它们的话，会陷入转换的死循环中不可自拔。</p>
<p>我们的主要目的是整页分配，比如分配n个页，步骤如下</p>
<ul>
<li>分配虚拟地址<ul>
<li>找到空闲的连续的虚拟地址，并分配出来，对于内核虚拟地址空间，可分配内存的起点是0xc0100000(因为0xc0000000-0xc0100000之间是分配给内核的)</li>
</ul>
</li>
<li>连续分配物理页并建立好页表项(pte)，直到分配完指定的页数n,可分配内存的起点是0x200000(包括内核和给内核的页表)<ul>
<li>找到空闲的物理页，不需要连续</li>
<li>给<strong>该页</strong>建立一个虚拟地址和物理页的映射，即页表项</li>
<li>虚拟地址指向下一页</li>
</ul>
</li>
<li><strong>注意只有pte被建立，才能说这块内存已经被分配出去了</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22) <span class="comment">//取得addr的高10位，页目录表中对应的pde的index</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12) <span class="comment">//取得addr的中间10位，页表中对应的pte的index</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> pool_flags &#123;</span><br><span class="line">    PF_KERNEL = <span class="number">1</span>, <span class="comment">//内核内存池</span></span><br><span class="line">    PF_USER = <span class="number">2</span> <span class="comment">//用户内存池</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_P_1 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_P_0 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_RW_R 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_RW_W 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_US_S 0 <span class="comment">// U/S 属性位值，系统级</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_US_U 4 <span class="comment">// U/S 属性位值，用户级</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在pf所属的虚拟内存池里申请pg_cnt个虚拟页，如果成功则返回虚拟页的起始地址，否则返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pf == PF_KERNEL) &#123;</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);<span class="comment">//通过bitmap_scan函数去找连续的空闲内存页</span></span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; pg_cnt) &#123;</span><br><span class="line">            bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//用户内存池，以后补充</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到虚拟地址vaddr对应的pte指针，其是一个能访问到pte的值的地址</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> *<span class="title">pte_addr</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 高10位全1，因为自映射，所以其取的页表地址，还是页目录表基地址，</span></span><br><span class="line">    <span class="comment">// 中间10位用vaddr的高10位，所以其取的物理块地址，是原本的页表基地址</span></span><br><span class="line">    <span class="comment">// 低12位用vaddr的中间10位，寻址到pte项，取内容，这里左移2是因为是12位，按字节，而10位是按index，需乘以4</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *pte = (<span class="keyword">uint32_t</span> *) (<span class="number">0xffc00000</span> + ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + (PTE_IDX(vaddr) &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到虚拟地址vaddr对应的pde的指针，其是一个能访问到pde的值的地址</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> *<span class="title">pde_addr</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *pde = (<span class="keyword">uint32_t</span> *) (<span class="number">0xfffff000</span> + (PDE_IDX(vaddr) &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> pde;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在m_pool指向的物理内存池分配一个物理页</span></span><br><span class="line"><span class="comment">// 成功则返回页框的物理地址，失败则返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">palloc</span><span class="params">(struct pool *m_pool)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//扫描或设置位图要保证原子操作</span></span><br><span class="line">    <span class="keyword">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);<span class="comment">//找一个物理页</span></span><br><span class="line">    <span class="keyword">if</span> (bit_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);<span class="comment">//将此位置为1，表示已经分配</span></span><br><span class="line">    <span class="keyword">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE)) + m_pool-&gt;phy_addr_start;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) page_phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有了虚拟地址和物理地址，我们需要用页表项来建立两者之间的映射关系，注意在创建页表项之前，要先创建页目录项</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_add</span><span class="params">(<span class="keyword">void</span> *_vaddr, <span class="keyword">void</span> *_page_phyaddr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>) _vaddr;</span><br><span class="line">    <span class="keyword">uint32_t</span> page_phyaddr = (<span class="keyword">uint32_t</span>) _page_phyaddr;</span><br><span class="line">    <span class="keyword">uint32_t</span> *pde = pde_addr(vaddr);</span><br><span class="line">    <span class="keyword">uint32_t</span> *pte = pte_addr(vaddr);</span><br><span class="line">    <span class="comment">//访问页目录项，判断P位，如果为1，代表该表已经存在，注意内核的页目录是我们在loader的时候就已经创建好了的</span></span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>) &#123;</span><br><span class="line">        <span class="comment">// 页表项需不存在，才有创建的必要</span></span><br><span class="line">        assert(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; <span class="number">0x00000001</span>)) &#123;</span><br><span class="line">            *pte = (page_phyaddr | PG_US_U, PG_RW_W | PG_P_1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//如果页目录项不存在，那么我们要先创建页目录项和对应的页表</span></span><br><span class="line">        <span class="comment">//所以就先分配一个4kb的物理地址出来，用来保存页表</span></span><br><span class="line">        <span class="comment">//将这个地址写入页目录表里的页目录项</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> pde_phyaddr = (<span class="keyword">uint32_t</span>) palloc(&amp;kernel_pool);</span><br><span class="line">        *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        <span class="comment">/* 分配到的物理页地址 pde_phyaddr 对应的物理内存清 0，</span></span><br><span class="line"><span class="comment">        * 避免里面的陈旧数据变成了页表项，从而让页表混乱。*/</span></span><br><span class="line">        <span class="comment">//注意，memset这种函数的参数都是虚拟地址，所以不能直接用pde_phyaddr，而是用其对应的虚拟地址</span></span><br><span class="line">        <span class="comment">//pde_phyaddr代表的是页表的基地址，所以用之前找页表项的方法就行，这里省事一下，直接把低12位置0就得到了。</span></span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span> *) ((<span class="keyword">int</span>) pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);</span><br><span class="line">        <span class="comment">//判断p位是否为0，为0才能写入</span></span><br><span class="line">        assert(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合起来，分配pg_cnt个页，如果成功则返回起始虚拟地址，失败则返回NULL</span></span><br><span class="line"><span class="comment">//通过vaddr_get在虚拟内存池申请虚拟内存</span></span><br><span class="line"><span class="comment">//通过palloc在物理内存池中申请物理页</span></span><br><span class="line"><span class="comment">//通过page_table_add将以上得到的虚拟地址和物理地址在页表里完成映射</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vaddr_start = vaddr_get(pf, pg_cnt);<span class="comment">//在pf所属的虚拟内存池里找到连续的内存</span></span><br><span class="line">    <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>) vaddr_start, cnt = pg_cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span> *<span class="title">mem_pool</span> = <span class="title">pf</span> &amp; <span class="title">PF_KERNEL</span> ? &amp;<span class="title">kernel_pool</span> :</span> &amp;user_pool;<span class="comment">//找到pf所属的物理内存池</span></span><br><span class="line">    <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *page_phyaddr = palloc(mem_pool);</span><br><span class="line">        <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>) &#123; <span class="comment">//失败时要将已经申请的虚拟地址和物理页全部回滚</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        page_table_add((<span class="keyword">void</span> *) vaddr, page_phyaddr);</span><br><span class="line">        vaddr += PG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从内核物理地址池申请一页内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_kernel_pages</span><span class="params">(<span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vaddr = malloc_page(PF_KERNEL, pg_cnt);</span><br><span class="line">    <span class="keyword">if</span> (vaddr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* addr = get_kernel_pages(<span class="number">3</span>);</span><br><span class="line">put_str(<span class="string">"\n get_kernel_page start vaddr is "</span>);</span><br><span class="line">put_int((<span class="keyword">uint32_t</span>)addr);</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-024803.png" alt=""></p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-025318.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-031120.png" alt=""><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-031255.png" alt=""></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="执行流"><a href="#执行流" class="headerlink" title="执行流"></a>执行流</h3><p>如果有四个任务A、B、C、D，对于单任务操作系统，它只能依次执行，A执行完才能执行B，以此类推。</p>
<p>如果是多任务操作系统，则由软件模拟出来一个任务调度器。</p>
<p>任务调度器就是操作系统中用于把任务轮流调度上处理器运行的一个软件模块，它是操作系统的一部分。调度器在内核中维护一个任务表(也称进程表、线程表或调度表)，然后按照一定的算法，从任务表中选择一个任务，然后把该任务放到处理器上运行，<strong>当任务运行的时间片到期后</strong>，再从任务表中找另外一个任务放到处理器上运行，周而复始，让任务表中的所有任务都有机会运行。正是因为有了调度器，多任务操作系统才能得以实现，它是多任务系统的核心，它的好坏直接影响了系统的效率。</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-091535.png" alt=""></p>
<p>任务并行这是用软件来切换任务模拟出来的假象，处理器只知道加电后按照程序计数器中的地址不断地执行下去， 在不断执行的过程中，我们把程序计数器中的下一条指令地址所组成的执行轨迹称为程序的控制执行流。</p>
<p><strong>执行流对应于代码，大到可以是整个程序文件，即进程，小到可以是一个功能独立的代码块，即函数，而线程本质上就是函数。</strong></p>
<p><strong>执行流是独立的，它的独立性体现在每个执行流都有自己的栈、一套自己的寄存器映像和内存资源，这是Intel处理器在硬件上规定的，其实这正是执行流的上下文环境。</strong></p>
<p>所以要切换任务就要保存上下文环境，这就引入了一定的性能开销。</p>
<p>说了这么多，我们软件中所做的任务切换，本质上就是改变了处理器中程序计数器的指向，即改变了处理器的“执行流”。</p>
<p>任务只是人为划分的、逻辑上的概念，人们把一个个的执行单元称为任务，我们所说的执行单元就是这些彼此独立的执行流，因此，独立的执行流成了调度器的调度单元，并使之成为了处理器的基本执行单位。</p>
<h3 id="线程的作用"><a href="#线程的作用" class="headerlink" title="线程的作用"></a>线程的作用</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-092415.png" alt=""><br>在线程中调用函数是让所运行的函数能够以调度单元的身份独立上处理器运行，当函数可以独立运行时，就会有更大的好处，那就是可以让程序中的多个函数(执行流)以并行(伪并行,实际并发)的方式运行。</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-093325.png" alt=""></p>
<h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><p>程序是指静态的、存储在文件系统上、尚未运行的指令代码，它是实际运行时程序的映像。</p>
<p>进程是指正在运行的程序，即进行中的程序，程序必须在获得运行所需要的各类资源后才能成为进程，<strong>资源包括进程所使用的栈，使用的寄存器等</strong>。</p>
<p>对于处理器来说，线程是一种控制流集合，集合中至少包含一条执行流，执行流之间是相互独立的，但它们共享进程的所有资源，<strong>它们是处理器的执行单位，或者称为调度单位，它们就是线程。</strong></p>
<p>按照进程中线程数量划分，进程分为单线程进程和多线程进程两种。我们平时所写的程序，如果其中未“显式”创建线程，它就属于单线程进程。</p>
<p><strong>线程仅仅是个执行流。</strong></p>
<p><strong>因为线程必然属于某一进程，线程要运行必须要有相应的资源，而进程就是这个资源的提供者，因此线程存在于进程之中</strong></p>
<p><strong>任务其实就是执行流，要么是大的执行流，单线程的进程，要么是小的执行流线程。</strong><br>进程采用多个执行流和其他进程抢处理器资源，这样就节省了单个进程的总执行时间。</p>
<p><strong>进程拥有整个地址空间</strong>，其中包括各种资源，<strong>而进程中的所有线程共享同一个地址空间</strong>，原因很简单，因为这个地址空间中有线程运行所需要的资源。</p>
<p>由于各个进程都拥有自己的虚拟地址空间，正常情况下它们彼此无法访问到对方的内部，因为进程之间的安全性是由操作系统的分页机制来保证的，只要操作系统不要把相同的物理页分配给多个进程就行了。</p>
<p>但进程内的线程可都是共享这同一地址空间的，也就意味着任意一个线程都可以去访问同一进程内其他线程的数据。</p>
<p>强调下，<strong>只有线程才具备能动性，它才是处理器的执行单元，因此它是调度器眼中的调度单位。</strong></p>
<p><strong>进程只是个资源整合体</strong>，它将进程中所有线程运行时用到资源收集在一起，供进程中的所有线程使用，真正上处理器上运行的其实都叫线程，进程中的线程才是一个个的执行实体、执行流，因此，<strong>经调度器送上处理器执行的程序都是线程。</strong></p>
<h3 id="进程-线程的状态"><a href="#进程-线程的状态" class="headerlink" title="进程/线程的状态"></a>进程/线程的状态</h3><p>把上述需要等待外界条件的状态称为“阻塞态”，把外界条件成立时，进程可以随时准备运行的状态称为“就绪态”，把正在处理器上运行的进程的状态称为“运行态”。</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-094929.png" alt=""></p>
<h3 id="PCB-程序控制块"><a href="#PCB-程序控制块" class="headerlink" title="PCB(程序控制块)"></a>PCB(程序控制块)</h3><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-10-105644.png" alt=""><br><strong>PCB中的栈是0特权级下的内核栈</strong>，而不是一般的用户栈。通常PCB以页为单位划分。</p>
<h3 id="线程的两种实现方式"><a href="#线程的两种实现方式" class="headerlink" title="线程的两种实现方式"></a>线程的两种实现方式</h3><ul>
<li>内核来实现线程，用户通过系统调用来使用线程。</li>
<li>用户实现线程，进程自己维护线程表</li>
</ul>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-022723.png" alt=""></p>
<p>在用户进程中实现线程有以下优点。</p>
<ul>
<li>线程的调度算法是由用户程序自己实现的，可以根据实现应用情况为某些线程加权调度。</li>
<li>将线程的寄存器映像装载到CPU时，可以在用户空间完成，即不用陷入到内核态，这样就免去了进入内核时的入栈及出栈操作。</li>
</ul>
<p>用户级线程也会有以下缺点。</p>
<ul>
<li>进程中的某个线程若出现了阻塞(通常是由于系统调用造成的)，操作系统不知道进程中存在线程，它以为此进程是传统型进程(单线程进程)，因此会将整个进程挂起，即进程中的全部线程都无法运行。</li>
<li>线程未在内核空间中实现，因此对于操作系统来说，调度器的调度单元是整个进程，并不是进程中的线程，所以时钟中断只能影响进程一级的执行流。当时钟中断发生后，操作系统的调度器只能感知到进程一级的调度实体，它要么把处理器交给进程A，要么交给进程B，绝不可能交给进程中的某个线程，也就是说，要想让操作系统调度，操作系统得知道它的存在才行，但由于线程在用户空间中实现，线程属于进程自己的“家务事”，操作系统根本不知道它的存在。这就导致了:如果在用户空间中实现线程，但凡进程中的某个线程开始在处理器上执行后，只要该线程不主动让出处理器，此进程中的其他线程都没机会运行。也就是说，没有保险的机制使线程运行“适时”，即避免单一线程过度使用处理器，而其他线程没有调度的机会。这只能凭借开发人员“人为”地在线程中调用类似pthread_yield或pthread_exit之类的方法使线程发扬“高风亮节”让出处理器使用权，此类方法通过回调方式触发进程内的线程调度器，让调度器有机会选择进程内的其他线程上处理器运行。重复强调:这里所说的“线程让出处理器使用权”，不是将整个进程的处理器使用权通过操作系统调度器交给其他进程，而是将控制权交给此进程自己的线程调度器，由自己的调度器将处理器使用权交给此进程中的下一个线程。</li>
<li>最后，线程在用户空间实现，和在内核空间实现相比，只是在内部调度时少了陷入内核的代价，确实相当于提速，但由于整个进程占据处理器的时间片是有限的，这有限的时间片还要再分给内部的线程，所以每个线程执行的时间片非常非常短暂，再加上进程内线程调度器维护线程表、运行调度算法的时间片消耗，反而抵销了内部调度带来的提速。</li>
</ul>
<p>在内核空间中实现线程，这里所说的“实现线程”是指由内核提供原生线程机制，用户进程中不再单独实现。个人觉得，线程由内核来实现，进程才真正得到了较大幅度的提速，这是最大的优点，这体现在以下方面。</p>
<ul>
<li>相比在用户空间中实现线程，内核提供的线程相当于让进程多占了处理器资源，比如系统中运行有进程A和一传统型进程B，此时进程A中显式创建了3个线程，这样一来，进程A加上主线程便有了4个线程，加上进程B，内核调度器眼中便有了5个独立的执行流，尽管其中4个都属于进程A，但对调度器来说这4个线程和进程一样被调度，因此调度器调度完一圈后，进程A使用了80%的处理器资源，这才是真正的提速。</li>
<li>另一方面的优点是当进程中的某一线程阻塞后，由于线程是由内核空间实现的，操作系统认识线程，所以就只会阻塞这一个线程，此线程所在进程内的其他线程将不受影响，这又相当于提速了。</li>
</ul>
<p>缺点是用户进程需要通过系统调用陷入内核，这多少增加了一些现场保护的栈操作，这还是会消耗一些处理器时间，但和上面的大幅度提速相比，这不算什么大事。</p>
<h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>回顾一下中断处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">%define ERROR_CODE nop		 ; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.</span><br><span class="line">%define ZERO push 0		 ; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0</span><br><span class="line"></span><br><span class="line">extern idt_table		 ;idt_table是C中注册的中断处理程序数组</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">global intr_entry_table</span><br><span class="line">intr_entry_table:</span><br><span class="line"></span><br><span class="line">%macro VECTOR 2</span><br><span class="line">section .text</span><br><span class="line">intr%1entry:		 ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少</span><br><span class="line"></span><br><span class="line">   %2				 ; 中断若有错误码会压在eip后面 </span><br><span class="line">; 以下是保存上下文环境</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad			 ; PUSHAD指令压入32位寄存器,其入栈顺序是: EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</span><br><span class="line"></span><br><span class="line">   ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI </span><br><span class="line">   mov al,0x20                   ; 中断结束命令EOI</span><br><span class="line">   out 0xa0,al                   ; 向从片发送</span><br><span class="line">   out 0x20,al                   ; 向主片发送</span><br><span class="line"></span><br><span class="line">   push %1			 ; 不管idt_table中的目标程序是否需要参数,都一律压入中断向量号,调试时很方便</span><br><span class="line">   call [idt_table + %1*4]       ; 调用idt_table中的C版本中断处理函数</span><br><span class="line">   jmp intr_exit</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">   dd    intr%1entry	 ; 存储各个中断入口程序的地址，形成intr_entry_table数组</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global intr_exit</span><br><span class="line">intr_exit:	     </span><br><span class="line">; 以下是恢复上下文环境</span><br><span class="line">   add esp, 4			   ; 跳过中断号</span><br><span class="line">   popad</span><br><span class="line">   pop gs</span><br><span class="line">   pop fs</span><br><span class="line">   pop es</span><br><span class="line">   pop ds</span><br><span class="line">   add esp, 4			   ; 跳过error_code</span><br><span class="line">   iretd</span><br></pre></td></tr></table></figure>

<ol>
<li>实现PCB里的栈，主要是中断栈和线程栈，其数据结构如下<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-081948.png" alt=""><!-- - 中断栈的作用是在线程进入中断后，会通过此栈来保存上下文 --></li>
</ol>
<ul>
<li>线程栈的作用主要是体现在其eip字段上，这个字段保存的是函数地址，可以通过它来进行控制流跳转</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程或者线程的状态</span></span><br><span class="line"><span class="keyword">enum</span> task_status &#123;</span><br><span class="line">    TASK_RUNNING,</span><br><span class="line">    TASK_READY,</span><br><span class="line">    TASK_BLOCKED,</span><br><span class="line">    TASK_WAITING,</span><br><span class="line">    TASK_HANGING,</span><br><span class="line">    TASK_DIED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断栈intr_stack</span></span><br><span class="line"><span class="comment">//用于中断发生时保护程序（线程或者进程）的上下文环境:</span></span><br><span class="line"><span class="comment">//进程或者线程被外部中断或者软中断打断时，会按照此结构压入上下文寄存器</span></span><br><span class="line"><span class="comment">//intr_exit中的出栈操作是此结构的逆操作</span></span><br><span class="line"><span class="comment">//初始时此栈在线程自己的内核栈中位置固定，所在页的最顶端</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vec_no; <span class="comment">//kernel.S宏VECTOR中push %1压入的中断号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp_dummp; <span class="comment">//虽然pushad会把esp也压入，但是esp是不断变化的，所以会被popad忽略</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> eax;</span><br><span class="line">    <span class="keyword">uint32_t</span> gs;</span><br><span class="line">    <span class="keyword">uint32_t</span> fs;</span><br><span class="line">    <span class="keyword">uint32_t</span> es;</span><br><span class="line">    <span class="keyword">uint32_t</span> ds;</span><br><span class="line">    <span class="comment">//以下是cpu从低特权级进入高特权级时压入</span></span><br><span class="line">    <span class="keyword">uint32_t</span> err_code; <span class="comment">//error_code会被压入到eip之后</span></span><br><span class="line">    <span class="keyword">void</span> (*eip)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> cs;</span><br><span class="line">    <span class="keyword">uint32_t</span> eflags;</span><br><span class="line">    <span class="keyword">void</span> *esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程栈 thread_stack</span></span><br><span class="line"><span class="comment">//线程自己的栈，用于存储线程中待执行的函数</span></span><br><span class="line"><span class="comment">//此结构在线程自己的内核栈中位置不固定，仅用在switch_to时保存线程环境</span></span><br><span class="line"><span class="comment">//实际位置取决于实际运行情况</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程第一次执行时，eip指向待调用的函数kernel_thread，其他时候，eip指向的是swich_to的返回地址</span></span><br><span class="line">    <span class="keyword">void</span> (*eip)(thread_func *func, <span class="keyword">void</span> *func_arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下仅供第一次被调度上cpu时使用</span></span><br><span class="line">    <span class="keyword">void</span> (*unused_retaddr);</span><br><span class="line">    thread_func *function; <span class="comment">//由kernel_thread所调用的函数名</span></span><br><span class="line">    <span class="keyword">void</span> *func_arg;<span class="comment">//由kernel_thread所调用的函数所需的参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程或者线程的pcb，程序控制块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *self_kstack; <span class="comment">//各线程都用自己的内核栈</span></span><br><span class="line">    <span class="keyword">enum</span> task_status status;</span><br><span class="line">    <span class="keyword">uint8_t</span> priority;<span class="comment">//线程优先级</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> stack_magic;<span class="comment">//栈的边界标记，用于检测栈的溢出</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kernel_thread</span><span class="params">(thread_func *function, <span class="keyword">void</span> *func_arg)</span> </span>&#123;</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>线程PCB分配，初始化PCB，并运行线程</li>
</ol>
<ul>
<li>thread_start<ul>
<li>get_kernel_pages<ul>
<li>不论是内核还是用户进程的pcb，都处于内核地址空间，所以分配一页内核空间</li>
</ul>
</li>
<li>init_thread<ul>
<li>清空分配出来的页内存，防止有垃圾数据残留</li>
<li>初始化线程基本信息，包括线程名、线程状态，线程在内核态使用的栈地址等，<strong>这里的栈地址就是我们分配出来的一页内存的最高地址，此后我们叫它内核栈</strong></li>
</ul>
</li>
<li>thread_create<ul>
<li>在内核栈里预留出顶部的空间保存inst_stack，线程进入中断后，会通过此栈来保存上下文</li>
<li>在内核栈里分配空间保存thread_stack，<strong>线程的目的就是并发的运行控制流，这里线程执行的控制流单元我们认为是一个函数，所以我们需要能运行这个函数</strong>，thread_stack里保存kernel_thread函数的地址和真正要执行的函数的地址和它的参数，以及一些寄存器信息。kernel_thread就是一层wrapper,用来调用线程真正要执行的函数</li>
</ul>
</li>
<li>将esp指向thread_stack的最低处，依次pop ebp,ebx,edi,esi使之前初始化的0弹入到相应的寄存器里，ret把栈顶的数据，即kthread_stack-&gt;eip所赋的值kernel_thread装入到eip，跳转过去执行。</li>
<li>此时我们将执行到eip指向的函数，线程初始化时其值为kernel_thread函数的地址，这个函数的定义如下，它就是调用<code>function(func_arg)</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kernel_thread</span><span class="params">(thread_func *function, <span class="keyword">void</span> *func_arg)</span> </span>&#123;</span><br><span class="line">   function(func_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-12-081933.png" alt=""></li>
<li>还是解释下最后一点,当跳转到kernel_thread之后，就等价于我们在执行一个正常的函数，那么这个函数要使用参数就要通过访问<code>ebp+0x8(放返回地址)+0x?</code>,所以为了占位置，我们有一个字段unused_retaddr，因为我们并不会从kernel_threa函数返回，我们会一直执行function，所以这个地址从不会被用到。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFun1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FunType)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallMyFun</span><span class="params">(FunType fp,<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CallMyFun(MyFun1,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallMyFun</span><span class="params">(FunType fp,<span class="keyword">int</span> x)</span> <span class="comment">//参数fp的类型是FunType。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fp(x);<span class="comment">//通过fp的指针执行传递进来的函数，注意fp所指的函数是有一个参数的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFun1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"函数MyFun1中输出：%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="number">0000000100000f</span>30 _CallMyFun:</span><br><span class="line">; &#123;</span><br><span class="line"><span class="number">100000f</span>30: <span class="number">55</span>                          	pushq	%rbp</span><br><span class="line"><span class="number">100000f</span>31: <span class="number">48</span> <span class="number">89</span> e5                    	movq	%rsp, %rbp</span><br><span class="line"><span class="number">100000f</span>34: <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>                 	subq	$<span class="number">16</span>, %rsp</span><br><span class="line"><span class="number">100000f</span>38: <span class="number">48</span> <span class="number">89</span> <span class="number">7</span>d f8                 	movq	%rdi, <span class="number">-8</span>(%rbp)</span><br><span class="line"><span class="number">100000f</span>3c: <span class="number">89</span> <span class="number">75</span> f4                    	movl	%esi, <span class="number">-12</span>(%rbp)</span><br><span class="line">;     fp(x);<span class="comment">//通过fp的指针执行传递进来的函数，注意fp所指的函数是有一个参数的</span></span><br><span class="line"><span class="number">100000f</span>3f: <span class="number">48</span> <span class="number">8b</span> <span class="number">45</span> f8                 	movq	<span class="number">-8</span>(%rbp), %rax</span><br><span class="line"><span class="number">100000f</span>43: <span class="number">8b</span> <span class="number">7</span>d f4                    	movl	<span class="number">-12</span>(%rbp), %edi</span><br><span class="line"><span class="number">100000f</span>46: ff d0                       	callq	*%rax</span><br><span class="line">; &#125;</span><br><span class="line"><span class="number">100000f</span>48: <span class="number">48</span> <span class="number">83</span> c4 <span class="number">10</span>                 	addq	$<span class="number">16</span>, %rsp</span><br><span class="line"><span class="number">100000f</span>4c: <span class="number">5</span>d                          	popq	%rbp</span><br><span class="line"><span class="number">100000f</span>4d: c3                          	retq</span><br><span class="line"><span class="number">100000f</span>4e: <span class="number">66</span> <span class="number">90</span>                       	nop</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//初始化线程栈thread_stack</span></span><br><span class="line"><span class="comment">//将待执行的函数和参数放到thread_stack中相应的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_create</span><span class="params">(struct task_struct *pthread, thread_func function, <span class="keyword">void</span> *func_arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先预留中断使用栈的空间</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(struct intr_stack);</span><br><span class="line">    <span class="comment">//再留出线程栈空间</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(struct thread_stack);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span> *<span class="title">kthread_stack</span> = (<span class="title">struct</span> <span class="title">thread_stack</span> *) <span class="title">pthread</span>-&gt;<span class="title">self_kstack</span>;</span></span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_thread</span><span class="params">(struct task_struct *pthread, <span class="keyword">char</span> *name, <span class="keyword">int</span> prio)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line">    pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    <span class="comment">//self_kstack是线程自己在内核态下使用的栈顶地址</span></span><br><span class="line">    pthread-&gt;self_kstack = (<span class="keyword">uint32_t</span> *) ((<span class="keyword">uint32_t</span>) pthread + PG_SIZE);</span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;<span class="comment">//随意定义的magic number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建优先级为prio的线程，线程名为name，线程所执行的函数是function(func_arg)</span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">thread_start</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">int</span> prio, thread_func function, <span class="keyword">void</span> *func_arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pcb都位于内核空间，包括用户进程的pcb也在内核空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span> = <span class="title">static_cast</span>&lt;task_struct *&gt;(<span class="title">get_kernel_pages</span>(1));</span></span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="comment">// 将esp指向thread-&gt;self_kstack，即线程栈的最低处（低地址）</span></span><br><span class="line">    <span class="comment">// 依次pop ebp,ebx,edi,esi使之前初始化的0弹入到相应的寄存器里</span></span><br><span class="line">    <span class="comment">// ret把栈顶的数据，即kthread_stack-&gt;eip所赋的值kernel_thread装入到eip，跳转过去执行</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret"</span>: : <span class="string">"g"</span> (thread-&gt;self_kstack) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核数据结构，双向链表"><a href="#内核数据结构，双向链表" class="headerlink" title="内核数据结构，双向链表"></a>内核数据结构，双向链表</h3><p><a href="https://www.cnblogs.com/skywang12345/p/3562146.html" target="_blank" rel="noopener">linux内核双向链表的经典实现</a></p>
<p>Linux中双向链表的使用思想:它是将双向链表节点嵌套在其它的结构体中；在遍历链表的时候，根据双链表节点的指针获取”它所在结构体的指针”，从而再获取数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offset(struct_type, member) (int)(&amp;((struct_type*)0)-&gt;member)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> elem2entry(struct_type, struct_member_name, elem_ptr) (struct_type*)((int)elem_ptr - offset(struct_type, struct_member_name))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">prev</span>;</span><span class="comment">//前驱</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">next</span>;</span><span class="comment">//后继</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//head不保存元素，第一个元素是head.next</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">//tail</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(function)</span><span class="params">(struct list_elem *, <span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_init</span><span class="params">(struct <span class="built_in">list</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_insert_before</span><span class="params">(struct list_elem *before, struct list_elem *elem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_push</span><span class="params">(struct <span class="built_in">list</span> *plist, struct list_elem *elem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_remove</span><span class="params">(struct list_elem *pelem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct list_elem *<span class="title">list_pop</span><span class="params">(struct <span class="built_in">list</span> *plist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">elem_find</span><span class="params">(struct <span class="built_in">list</span> *plist, struct list_elem *obj_elem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_empty</span><span class="params">(struct <span class="built_in">list</span> *plist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct list_elem *<span class="title">list_traversal</span><span class="params">(struct <span class="built_in">list</span> *plist, function func, <span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">list_len</span><span class="params">(struct <span class="built_in">list</span> *plist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化双向链表 list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_init</span><span class="params">(struct <span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.next = &amp;<span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.prev = &amp;<span class="built_in">list</span>-&gt;head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把链表元素 elem 插入在元素 before 之前 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_insert_before</span><span class="params">(struct list_elem *before, struct list_elem *elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">    before-&gt;prev-&gt;next = elem;</span><br><span class="line">    elem-&gt;prev = before-&gt;prev;</span><br><span class="line"></span><br><span class="line">    elem-&gt;next = before;</span><br><span class="line">    before-&gt;prev = elem;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加元素到列表队首，类似栈 push 操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_push</span><span class="params">(struct <span class="built_in">list</span> *plist, struct list_elem *elem)</span> </span>&#123;</span><br><span class="line">    list_insert_before(plist-&gt;head.next, elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 追加元素到链表队尾，类似队列的先进先出操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_append</span><span class="params">(struct <span class="built_in">list</span> *plist, struct list_elem *elem)</span> </span>&#123;</span><br><span class="line">    list_insert_before(&amp;plist-&gt;tail, elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使元素 pelem 脱离链表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_remove</span><span class="params">(struct list_elem *pelem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">    pelem-&gt;prev-&gt;next = pelem-&gt;next;</span><br><span class="line">    pelem-&gt;next-&gt;prev = pelem-&gt;prev;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将链表第一个元素弹出并返回，类似栈的pop操作 */</span></span><br><span class="line"><span class="function">struct list_elem *<span class="title">list_pop</span><span class="params">(struct <span class="built_in">list</span> *plist)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">elem</span> = <span class="title">plist</span>-&gt;<span class="title">head</span>.<span class="title">next</span>;</span></span><br><span class="line">    list_remove(elem);</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从链表中查找元素 obj_elem，成功时返回 true，失败时返回 false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">elem_find</span><span class="params">(struct <span class="built_in">list</span> *plist, struct list_elem *obj_elem)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">elem</span> = <span class="title">plist</span>-&gt;<span class="title">head</span>.<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem == obj_elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断链表是否为空，空时返回 true，否则返回 false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_empty</span><span class="params">(struct <span class="built_in">list</span> *plist)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (plist-&gt;head.next == &amp;plist-&gt;tail) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回链表的长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">list_len</span><span class="params">(struct <span class="built_in">list</span> *plist)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">elem</span> = <span class="title">plist</span>-&gt;<span class="title">head</span>.<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem-&gt;next != &amp;plist-&gt;tail) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把列表 plist 中的每个元素 elem 和 arg 传给回调函数 func，</span></span><br><span class="line"><span class="comment">* arg给func用来判断elem是否符合条件.</span></span><br><span class="line"><span class="comment">* 本函数的功能是遍历列表内所有元素，逐个判断是否有符合条件的元素。</span></span><br><span class="line"><span class="comment"> * * 找到符合条件的元素返回元素指针，否则返回 NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct list_elem *<span class="title">list_traversal</span><span class="params">(struct <span class="built_in">list</span> *plist, function func, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">elem</span> = <span class="title">plist</span>-&gt;<span class="title">head</span>.<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (list_empty(plist)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail) &#123;</span><br><span class="line">        <span class="keyword">if</span> (func(elem, arg)) &#123;</span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        &#125;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单优先级调度的准备"><a href="#简单优先级调度的准备" class="headerlink" title="简单优先级调度的准备"></a>简单优先级调度的准备</h3><ul>
<li><p>为了支持多线程调度，我们需要修改pcb的定义。</p>
<ul>
<li><p>general_tag: 类型是struct list_elem，也就是general_tag是双向链表中的结点。它是线程的标签，当线程被加入到就绪队列 thread_ready_list或其他等待队列中时，就把该线程PCB中 general_tag的地址加入队列。</p>
</li>
<li><p>all_list_tag: 的类型也是struct list_elem，它专用于线程被加入全部线程队列时使用。</p>
</li>
<li><p>pgdir: 是任务自己的页表。线程与进程的最大区别就是进程独享自己的地址空间，即进程有自己的页表，而线程共享所在进程的地址空间，即线程无页表。如果该任务为线程，pgdir则为NULL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="comment">/* 进程或线程的pcb,程序控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* self_kstack;	 <span class="comment">// 各内核线程都用自己的内核栈</span></span><br><span class="line">   <span class="keyword">enum</span> task_status status;</span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">   <span class="keyword">uint8_t</span> priority;</span><br><span class="line">   <span class="keyword">uint8_t</span> ticks;	   <span class="comment">// 每次在处理器上执行的时间嘀嗒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此任务自上cpu运行后至今占用了多少cpu嘀嗒数,</span></span><br><span class="line"><span class="comment"> * 也就是此任务执行了多久*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> elapsed_ticks;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* general_tag的作用是用于线程在一般的队列中的结点 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span>				    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* all_list_tag的作用是用于线程队列thread_all_list中的结点 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span>* pgdir;              <span class="comment">// 进程自己页表的虚拟地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> stack_magic;	 <span class="comment">// 用这串数字做栈的边界标记,用于检测栈的溢出</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>区分主线程和其他线程</p>
<ul>
<li>定义就绪队列和所有任务队列，以及主线程pcb</li>
<li>init_thread<ul>
<li>区分main_thread和其他线程，区别在于main_thread在init的时候已经在运行了，它的状态是TASK_RUNNING，而其他线程则是TASK_READY，等待被调度到CPU执行。</li>
</ul>
</li>
<li>thread_start和之前的逻辑区别不大，主要增加的部分在于<ul>
<li>增加对时间片和页表的初始化</li>
<li>在start里把当前thread加到就绪队列和所有任务队列里</li>
<li>移除start里的跳转到function执行</li>
</ul>
</li>
<li>定义make_main_thread函数，其作用是<ul>
<li>因为main线程早已运行,咱们在loader.S中进入内核时的mov esp,0xc009f000,就是为其预留了tcb,地址为0xc009e000,因此不需要通过get_kernel_page另分配一页，直接将<code>esp&amp;0xfffff000</code>找到当前页的基地址就是pcb的地址。</li>
<li>通过init_thread来初始化主线程pcb的基本信息即可。</li>
<li>main函数是当前线程,当前线程不在thread_ready_list中，所以只将其加在thread_all_list中.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">main_thread</span>;</span> <span class="comment">//主线程PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span> <span class="comment">//就绪队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span><span class="comment">//所有任务队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">thread_tag</span>;</span><span class="comment">//用于保存队列中的线程节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">switch_to</span><span class="params">(struct task_struct *cur, struct task_struct *next)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前线程的pcb指针</span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">running_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"mov %%esp, %%0"</span> : <span class="string">"=g"</span>(esp));</span><br><span class="line">    <span class="comment">//取esp的整数部分，即pcb的起始地址</span></span><br><span class="line">    <span class="keyword">return</span> (struct task_struct *) (esp &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kernel_thread</span><span class="params">(thread_func *function, <span class="keyword">void</span> *func_arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */</span></span><br><span class="line">    intr_enable();</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程基本信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_thread</span><span class="params">(struct task_struct* pthread, <span class="keyword">char</span>* name, <span class="keyword">int</span> prio)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread == main_thread) &#123;</span><br><span class="line"><span class="comment">/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */</span></span><br><span class="line">        pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* self_kstack是线程自己在内核态下使用的栈顶地址 */</span></span><br><span class="line">    pthread-&gt;self_kstack = (<span class="keyword">uint32_t</span>*)((<span class="keyword">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;ticks = prio;</span><br><span class="line">    pthread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">    pthread-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;	  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程栈thread_stack</span></span><br><span class="line"><span class="comment">//将待执行的函数和参数放到thread_stack中相应的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_create</span><span class="params">(struct task_struct *pthread, thread_func function, <span class="keyword">void</span> *func_arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先预留中断使用栈的空间</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(struct intr_stack);</span><br><span class="line">    <span class="comment">//再留出线程栈空间</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(struct thread_stack);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span> *<span class="title">kthread_stack</span> = (<span class="title">struct</span> <span class="title">thread_stack</span> *) <span class="title">pthread</span>-&gt;<span class="title">self_kstack</span>;</span></span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建优先级为prio的线程，线程名为name，线程所执行的函数是function(func_arg)</span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">thread_start</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">int</span> prio, thread_func function, <span class="keyword">void</span> *func_arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pcb都位于内核空间，包括用户进程的pcb也在内核空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span> = <span class="title">static_cast</span>&lt;task_struct *&gt;(<span class="title">get_kernel_pages</span>(1));</span></span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="comment">// 确保之前不在队列中</span></span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    <span class="comment">// 加入就绪线程队列</span></span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    <span class="comment">// 确保之前不在队列里</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    <span class="comment">// 加入全部线程队列</span></span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将kernel中的main函数完善为主线程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_main_thread</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp,0xc009f000,</span></span><br><span class="line"><span class="comment">就是为其预留了tcb,地址为0xc009e000,因此不需要通过get_kernel_page另分配一页*/</span></span><br><span class="line">    main_thread = running_thread();</span><br><span class="line">    init_thread(main_thread, <span class="string">"main"</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main函数是当前线程,当前线程不在thread_ready_list中,</span></span><br><span class="line"><span class="comment"> * 所以只将其加在thread_all_list中. */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-030932.png" alt=""></p>
<h3 id="任务调度器和任务切换"><a href="#任务调度器和任务切换" class="headerlink" title="任务调度器和任务切换"></a>任务调度器和任务切换</h3><p>调度器的工作就是根据任务的状态将其从处理器上换上换下，调度器主要任务就是读写就绪队列，增删里面的结点，结点是线程PCB中的general_tag，相当于”线程的PCB。</p>
<p>线程每次在处理器上的执行时间是由其ticks决定的，我们在初始化线程的时候，已经将线程PCB中的ticks赋值为prio，优先级越高，ticks越大。每发生一次时钟中断，时钟中断的处理程序便将当前运行线程的ticks减1。</p>
<p>当ticks为0时，时钟的中断处理程序调用调度器schedule，这说明时间片到期了，将其ticks重新赋值为它的优先级prio，将其状态由TASK_RUNNING置为TASK_READY，并将其加入到就绪队列的末尾，让调度器选择另一个线程上处理器。</p>
<p>调度器是从就绪队列thread_ready_list中“取出”上处理器运行的线程，所有待执行的线程都在thread_ready_list中，让候选线程按顺序一个一个地执行，咱们就是按先进先出的顺序始终调度队头的线程。</p>
<p>调度器按照队列先进先出的顺序，把就绪队列中的第1个结点作为下一个要运行的新线程，将该线程的状态置为TASK_RUNNING，之后通过函数switch_to将新线程的寄存器环境恢复，这样新线程便开始执行。</p>
<p>因此，完整的调度过程需要三部分的配合。</p>
<ul>
<li>时钟中断处理函数</li>
<li>调度器schedule</li>
<li>任务切换函数 switch_to</li>
</ul>
<h4 id="时钟中断处理函数"><a href="#时钟中断处理函数" class="headerlink" title="时钟中断处理函数"></a>时钟中断处理函数</h4><p>时钟中断函数主要的逻辑如下:</p>
<ul>
<li>检测栈是否溢出，因为内核栈是放在PCB上面的，栈不断向下增长，就可能覆盖掉PCB里保存的基本信息。</li>
<li>此线程总共占用的cpu时间加一</li>
<li>从内核第一次处理时间中断后开始至今的滴哒数加一</li>
<li>如果进程时间片用完就调度新的进程上CPU</li>
<li>否则，当前进程的时间片减一<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> ticks; <span class="comment">//ticks是内核自中断开启以来总共的嘀嗒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时钟的中断处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intr_timer_handler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> = <span class="title">running_thread</span>();</span></span><br><span class="line"></span><br><span class="line">   ASSERT(cur_thread-&gt;stack_magic == <span class="number">0x19870916</span>);         <span class="comment">// 检查栈是否溢出</span></span><br><span class="line"></span><br><span class="line">   cur_thread-&gt;elapsed_ticks++;	  <span class="comment">// 记录此线程占用的cpu时间嘀</span></span><br><span class="line">   ticks++;	  <span class="comment">//从内核第一次处理时间中断后开始至今的滴哒数,内核态和用户态总共的嘀哒数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cur_thread-&gt;ticks == <span class="number">0</span>) &#123;	  <span class="comment">// 若进程时间片用完就开始调度新的进程上cpu</span></span><br><span class="line">      schedule(); </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;				  <span class="comment">// 将当前进程的时间片-1</span></span><br><span class="line">      cur_thread-&gt;ticks--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 初始化PIT8253 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"timer_init start\n"</span>);</span><br><span class="line">   <span class="comment">/* 设置8253的定时周期,也就是发中断的周期 */</span></span><br><span class="line">   frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);</span><br><span class="line">   register_handler(<span class="number">0x20</span>, intr_timer_handler);</span><br><span class="line">   put_str(<span class="string">"timer_init done\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_handler</span><span class="params">(<span class="keyword">uint8_t</span> vector_no, intr_handler function)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,</span></span><br><span class="line"><span class="comment"> * 见kernel/kernel.S的call [idt_table + %1*4] */</span></span><br><span class="line">   idt_table[vector_no] = function; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="实现调度器schedule"><a href="#实现调度器schedule" class="headerlink" title="实现调度器schedule"></a>实现调度器schedule</h4><ul>
<li><p>schedule可能在两种情况下被调用，一种是正在运行的进程的时间片用完，另外是进程可能需要一些资源，需要堵塞到这个资源被给了才能运行。</p>
<ul>
<li><p>如果此线程只是cpu时间片到了,将其加入到就绪队列尾，并重置时间片为priority的值</p>
</li>
<li><p>若此线程需要某事件发生后才能继续上cpu运行，不需要将其加入队列,因为当前线程不在就绪队列中。</p>
</li>
<li><p>将就绪队列中的第一个就绪线程弹出,准备将其调度上cpu.</p>
</li>
<li><p>注意切换线程使用的是switch_to函数，它的参数是当前线程和将要执行的线程的PCB(即task_struct)的地址，但是我们的pop返回的是一个<code>list_elem *</code>，它保存的是PCB里general_tag的地址，而不是PCB的首地址。</p>
</li>
<li><p><strong>但是因为general_tag是结构体task_struct里的一个字段，所以它在这个结构体里的偏移是始终固定的，就可以直接减去偏移拿到首地址</strong></p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-071244.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="comment">//实现任务调度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   ASSERT(intr_get_status() == INTR_OFF);</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span> </span><br><span class="line">   <span class="keyword">if</span> (cur-&gt;status == TASK_RUNNING) &#123; <span class="comment">// 若此线程只是cpu时间片到了,将其加入到就绪队列尾</span></span><br><span class="line">      ASSERT(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));</span><br><span class="line">      list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag);</span><br><span class="line">      cur-&gt;ticks = cur-&gt;priority;     <span class="comment">// 重新将当前线程的ticks再重置为其priority;</span></span><br><span class="line">      cur-&gt;status = TASK_READY;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">/* 若此线程需要某事件发生后才能继续上cpu运行,</span></span><br><span class="line"><span class="comment">      不需要将其加入队列,因为当前线程不在就绪队列中。*/</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ASSERT(!list_empty(&amp;thread_ready_list));</span><br><span class="line">   thread_tag = <span class="literal">NULL</span>;	  <span class="comment">// thread_tag清空</span></span><br><span class="line"><span class="comment">/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */</span></span><br><span class="line">   thread_tag = list_pop(&amp;thread_ready_list);   </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> = <span class="title">elem2entry</span>(<span class="title">struct</span> <span class="title">task_struct</span>, <span class="title">general_tag</span>, <span class="title">thread_tag</span>);</span></span><br><span class="line">   next-&gt;status = TASK_RUNNING;</span><br><span class="line">   switch_to(cur, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offset(struct_type,member) (int)(&amp;((struct_type*)0)-&gt;member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> elem2entry(struct_type, struct_member_name, elem_ptr) \</span></span><br><span class="line">(struct_type*)((<span class="keyword">int</span>)elem_ptr - offset(struct_type, struct_member_name))</span><br></pre></td></tr></table></figure>

<h4 id="实现任务切换函数switch-to"><a href="#实现任务切换函数switch-to" class="headerlink" title="实现任务切换函数switch_to"></a>实现任务切换函数switch_to</h4><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-071848.png" alt=""></p>
<p>程序所做的完整工作可以分为两部分，一部分是“重要工作”，这由操作系统代码来完成，另一部分是“普通工作”，这由用户代码完成。</p>
<p>实际上，完整的程序就也因此分为两部分，一部分是做重要工作的内核级码，另一部分就是做普通工作的用户级代码。所以，“完整的程序=用户代码+内核代码”。而这个完整的程序就是我们所说的任务，也就是线程或进程，也就是说，任务在执行过程中会执行用户代码和内核代码，当处理器处于低特权级下执行用户代码时我们称之为用户态，当处理器进入高特权级执行到内核代码时，我们称之为内核态，当处理器从用户代码所在的低特权级过渡到内核代码所在的高特权级时，这称为陷入内核。</p>
<p>因此一定要清楚，无论是执行用户代码，还是执行内核代码，这些代码都属于这个完整的程序，即属于当前任务，并不是说当前任务由用户态进入内核态后当前任务就切换成内核了，这样理解是不对的。任务与任务的区别在于执行流一整套的上下文资源，这包括寄存器映像、地址空间、IO位图等，在将来介绍任务状态段TSS之后，您就会了解这套上下文资源恰恰就是TSS结构中的内容，拥有这些资源才称得上是任务。</p>
<p><strong>因此，处理器只有被新的上下文资源重新装载后，当前任务才被替换为新的任务，这才叫任务切换。</strong> 当任务进入内核态时，其上下文资源并未完全替换，只是执行了“更厉害”的代码。这有点像咱们在游戏中打怪，用不同的武器打不同的怪，游戏的人物角色始终没有变。</p>
<p>每个任务都有个执行流，这都是事先规划好的执行路径，按道理应该是从头执行到结束。</p>
<p>不过实际的情况是执行流经常被临时改道，突然就执行了规划外的指令，这在多任务系统中是很正常的，因为操作系统是由中断驱动的，每一次中断都将使处理器放下手头的工作转去执行中断处理程序。</p>
<p>为了在中断处理完成后能够恢复任务原有的执行路径，必须在执行流被改变前，将任务的上下文保护好。执行流被改变后，在其后续的执行过程中还可能会再次发生被改变“流向”的情况，也就是说随着执行的深入，这种改变的深度很可能是多层的。</p>
<p><strong>如果希望将来能够返回到本层的执行流，依然要在改变前保护好本层的上下文</strong></p>
<p>总之，凡是涉及到执行流的改变，不管被改变了几层，为了将来能够恢复到本层继续执行，必须在改变发生前将本层执行流的上下文保护好。因此，执行流被改变了几层就要做几次上下文保护。</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-072315.png" alt=""></p>
<p>(1)上下文保护的第一部分负责保存任务进入中断前的全部寄存器，目的是能让任务恢复到中断前。</p>
<p>(2)上下文保护的第二部分负责保存这4个寄存器:esi、edi、ebx和ebp，目的是让任务恢复执行在任务切换发生时剩下尚未执行的内核代码，保证顺利走到退出中断的出口，利用第一部分保护的寄存器环境彻底恢复任务。(<strong>其实这4个寄存器主要是用来恢复主调函数的环境，只是当前我们在讨论内核函数</strong>）</p>
<p>最终switch_to的实现逻辑如下</p>
<ul>
<li>保存当前线程的上下文环境<ul>
<li>被调函数压栈保存4个寄存器:esi、edi、ebx和ebp</li>
<li>取switch_to的参数cur的值，cur保存当前线程的PCB的地址，<strong>因为self_kstack是task_struct(PCB)中的第一个字段，所以PCB的地址也就是self_kstack的地址</strong>。</li>
<li>将当前栈顶指针esp保存到当前线程PCB中的self_kstack成员中</li>
</ul>
</li>
<li>恢复下一个线程的环境<ul>
<li>得到栈中的参数next,pcb的第一个成员是self_kstack成员,用来记录0级栈顶指针,用来上cpu时恢复0级栈,0级栈中保存了进程或线程所有信息,包括3级栈指针</li>
<li>所以我们从self_kstack中取出<strong>之前保存的内核栈的esp</strong>，赋值给当前esp，<strong>从而从当前栈，切换到了内核栈</strong></li>
<li>ret返回到返回地址，如果此时的next线程之前尚未执行过，马上开始的是第一次执行，此时栈顶的值是函数kernel_thread的地址，这是由thread_create函数设置的，执行ret指令后处理器将去执行函数kernel_thread。如果next之前已经执行过了，这次是再次将其调度到处理器的话，此时栈顶的值是由调用函数switch_to的主调函数schedule留下的，这会继续执行schedule后面的流程。而switch_to是schedule最后一句代码，因此执行流程马上回到schedule的调用者intr_timer_handler中。schedule同样也是intr_timer_handler中最后一句代码，因此会完成intr_timer_handler，回到kernel.S中的jmpintr_exit，从而恢复任务的全部寄存器映像，之后通过iretd指令退出中断，任务被完全彻底地恢复。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;switch.S</span><br><span class="line">[bits 32]</span><br><span class="line">section .text</span><br><span class="line">global switch_to</span><br><span class="line">switch_to:</span><br><span class="line">   ;栈中此处是返回地址	       </span><br><span class="line">   push esi</span><br><span class="line">   push edi</span><br><span class="line">   push ebx</span><br><span class="line">   push ebp</span><br><span class="line"></span><br><span class="line">   mov eax, [esp + 20]		 ; 得到栈中的参数cur, cur &#x3D; [esp+20]</span><br><span class="line">   mov [eax], esp                ; 保存栈顶指针esp. task_struct的self_kstack字段,</span><br><span class="line">				 ; self_kstack在task_struct中的偏移为0,</span><br><span class="line">				 ; 所以直接往thread开头处存4字节便可。</span><br><span class="line">;------------------  以上是备份当前线程的环境，下面是恢复下一个线程的环境  ----------------</span><br><span class="line">   mov eax, [esp + 24]		 ; 得到栈中的参数next, next &#x3D; [esp+24]</span><br><span class="line">   mov esp, [eax]		 ; pcb的第一个成员是self_kstack成员,用来记录0级栈顶指针,</span><br><span class="line">				 ; 用来上cpu时恢复0级栈,0级栈中保存了进程或线程所有信息,包括3级栈指针</span><br><span class="line">   pop ebp</span><br><span class="line">   pop ebx</span><br><span class="line">   pop edi</span><br><span class="line">   pop esi</span><br><span class="line">   ret				 ; 返回到上面switch_to下面的那句注释的返回地址,</span><br><span class="line">				 ; 未由中断进入,第一次执行时会返回到kernel_thread</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-13-073140.png" alt=""></p>
<h4 id="启用线程调度用运行"><a href="#启用线程调度用运行" class="headerlink" title="启用线程调度用运行"></a>启用线程调度用运行</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="comment">/* 初始化线程环境 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"thread_init start\n"</span>);</span><br><span class="line">   list_init(&amp;thread_ready_list);</span><br><span class="line">   list_init(&amp;thread_all_list);</span><br><span class="line"><span class="comment">/* 将当前main函数创建为线程 */</span></span><br><span class="line">   make_main_thread();</span><br><span class="line">   put_str(<span class="string">"thread_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"init.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"interrupt.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread_a</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread_b</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"I am kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"></span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"argA "</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">8</span>, k_thread_b, <span class="string">"argB "</span>);</span><br><span class="line"></span><br><span class="line">   intr_enable();	<span class="comment">// 打开中断,使时钟中断起作用</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      put_str(<span class="string">"Main "</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread_a</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;     </span><br><span class="line"><span class="comment">/* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */</span></span><br><span class="line">   <span class="keyword">char</span>* para = arg;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      put_str(para);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread_b</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;     </span><br><span class="line"><span class="comment">/* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */</span></span><br><span class="line">   <span class="keyword">char</span>* para = arg;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      put_str(para);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接执行会崩溃，这其实是因为显存打印的时候，线程对进程内全局资源的条件竞争造成的，具体不述。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-020617.png" alt=""></p>
<p>我还是先记录一下整个main函数从启动到执行的过程</p>
<p>调试方法是先用nm找到符号地址，然后lb下断即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sakura@ubuntu:~&#x2F;kernel_learn&#x2F;bochs-2.6.2&#x2F;bin$ nm build&#x2F;kernel.bin</span><br><span class="line">c0001ef7 t intr0x20entry</span><br><span class="line">c0001ab1 t intr_timer_handler</span><br><span class="line">c0002f60 T schedule</span><br><span class="line">c00032b0 T switch_to</span><br><span class="line">c0002ce7 t kernel_thread</span><br></pre></td></tr></table></figure>

<p>首先内核启动就一直在执行main函数，我们通过make_main_thread调用init_thread在为内核进程预留的PCB地址0xc009e000创建一个task_struct，设置其时间片，然后将其加入thread_all_list队列里。</p>
<p>然后开启两个新线程k_thread_a和k_thread_b，然后打开中断。</p>
<p>然后当中断开启，则每次时钟滴答一次，就进入一次时钟中断，我们根据intr0x20entry的符号地址下断。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-023432.png" alt=""><br>main函数循环打印”Main”,并在时间片用完的时候被调度下CPU。</p>
<p>我们先观察一下进入中断时候的寄存器保存情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(0) [0x000000001ef9] 0008:c0001ef9 (unk. ctxt): push ds                   ; 1e</span><br><span class="line">&lt;bochs:4&gt; reg</span><br><span class="line">eax: 0x00000000 0</span><br><span class="line">ecx: 0xc00032f7 -1073728777</span><br><span class="line">edx: 0xc0101028 -1072689112</span><br><span class="line">ebx: 0x00070094 458900</span><br><span class="line">esp: 0xc009efc0 -1073090624</span><br><span class="line">ebp: 0xc009efe8 -1073090584</span><br><span class="line">esi: 0x00070000 458752</span><br><span class="line">edi: 0x00000000 0</span><br><span class="line">eip: 0xc0001ef9</span><br><span class="line">...</span><br><span class="line">&lt;bochs:5&gt; x&#x2F;10wx 0xc009e000</span><br><span class="line">[bochs]:</span><br><span class="line">0xc009e000 &lt;bogus+       0&gt;:	0xc009f000</span><br></pre></td></tr></table></figure>
<p>可见直接压栈，而不是保存到0xc009e000处。</p>
<p>然后我们再看一下内核栈顶是怎么变化的，这其实发生在switch_to上。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-025718.png" alt=""><br>此时就被调度下CPU，进入switch_to，它先保存一些寄存器到栈上，用于返回，然后将此时的栈顶保存到0xc009e000即kstack上，这就<strong>保存好了main的上下文。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(0) [0x0000000032b0] 0008:c00032b0 (unk. ctxt): push esi                  ; 56</span><br><span class="line">&lt;bochs:38&gt; x&#x2F;10wx 0xc009e000</span><br><span class="line">[bochs]:</span><br><span class="line">0xc009e000 &lt;bogus+       0&gt;:	0xc009f000	0x00000001	0x6e69616d	0x00000000</span><br><span class="line">0xc009e010 &lt;bogus+      16&gt;:	0x00000000	0x00000000	0x00001f1f	0x00000020</span><br><span class="line">0xc009e020 &lt;bogus+      32&gt;:	0xc0101020	0xc000557c</span><br><span class="line">&lt;bochs:39&gt; s</span><br><span class="line">Next at t&#x3D;18216965</span><br><span class="line">(0) [0x0000000032b1] 0008:c00032b1 (unk. ctxt): push edi                  ; 57</span><br><span class="line">&lt;bochs:40&gt; </span><br><span class="line">Next at t&#x3D;18216966</span><br><span class="line">(0) [0x0000000032b2] 0008:c00032b2 (unk. ctxt): push ebx                  ; 53</span><br><span class="line">&lt;bochs:41&gt; </span><br><span class="line">Next at t&#x3D;18216967</span><br><span class="line">(0) [0x0000000032b3] 0008:c00032b3 (unk. ctxt): push ebp                  ; 55</span><br><span class="line">&lt;bochs:42&gt; </span><br><span class="line">Next at t&#x3D;18216968</span><br><span class="line">(0) [0x0000000032b4] 0008:c00032b4 (unk. ctxt): mov eax, dword ptr ss:[esp+20] ; 8b442414</span><br><span class="line">&lt;bochs:43&gt; </span><br><span class="line">Next at t&#x3D;18216969</span><br><span class="line">(0) [0x0000000032b8] 0008:c00032b8 (unk. ctxt): mov dword ptr ds:[eax], esp ; 8920</span><br><span class="line">...</span><br><span class="line">&lt;bochs:46&gt; x&#x2F;10wx 0xc009e000</span><br><span class="line">[bochs]:</span><br><span class="line">0xc009e000 &lt;bogus+       0&gt;:	0xc009ef04	0x00000001	0x6e69616d	0x00000000</span><br><span class="line">0xc009e010 &lt;bogus+      16&gt;:	0x00000000	0x00000000	0x00001f1f	0x00000020</span><br><span class="line">0xc009e020 &lt;bogus+      32&gt;:	0xc0101020	0xc000557c</span><br><span class="line">&lt;bochs:47&gt; reg</span><br><span class="line">eax: 0xc009e000 -1073094656</span><br><span class="line">ecx: 0x00000061 97</span><br><span class="line">edx: 0xc0005574 -1073719948</span><br><span class="line">ebx: 0xc00032f8 -1073728776</span><br><span class="line">esp: 0xc009ef04 -1073090812</span><br><span class="line">ebp: 0xc009ef40 -1073090752</span><br><span class="line">esi: 0x00070000 458752</span><br><span class="line">edi: 0x00000000 0</span><br><span class="line">eip: 0xc00032ba</span><br></pre></td></tr></table></figure>
<p>然后我们要调度thread_a上CPU，这就要先把a的内核栈换上esp，然后pop一系列寄存器，<strong>恢复thread_a的上下文环境。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(0) [0x0000000032be] 0008:c00032be (unk. ctxt): mov esp, dword ptr ds:[eax] ; 8b20</span><br><span class="line"></span><br><span class="line">&lt;bochs:50&gt; reg</span><br><span class="line">eax: 0xc0100000 -1072693248</span><br><span class="line">ecx: 0x00000061 97</span><br><span class="line">edx: 0xc0005574 -1073719948</span><br><span class="line">ebx: 0xc00032f8 -1073728776</span><br><span class="line">esp: 0xc0100e50 -1072689584</span><br><span class="line">...</span><br><span class="line">&lt;bochs:51&gt; x&#x2F;10wx 0xc0100000</span><br><span class="line">[bochs]:</span><br><span class="line">0xc0100000 &lt;bogus+       0&gt;:	0xc0100e50	0x00000000	0x68745f6b	0x64616572</span><br><span class="line">0xc0100010 &lt;bogus+      16&gt;:	0x0000615f</span><br></pre></td></tr></table></figure>
<p>0xc0100000就是a的PCB表，它的第一个成员就是kstack，即内核栈指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xc0100e50 &lt;bogus+      32&gt;:	|0x00000000	0x00000000	0x00000000	0x00000000|-&gt;ebp ebx edi esi</span><br><span class="line">0xc0100e60 &lt;bogus+      48&gt;:	0xc0002ce7-&gt;返回地址，此时是kernel_thread的地址</span><br></pre></td></tr></table></figure>
<p>进入kernel_thread看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0) [0x000000002ce7] 0008:c0002ce7 (unk. ctxt): push ebp                  ; 55</span><br><span class="line">...</span><br><span class="line">&lt;bochs:60&gt; print-stack</span><br><span class="line">Stack address size 4</span><br><span class="line"> | STACK 0xc0100e64 [0x00000000]--&gt;不使用的返回地址</span><br><span class="line"> | STACK 0xc0100e68 [0xc000156f]--&gt;function地址</span><br><span class="line"> | STACK 0xc0100e6c [0xc00032d5]--&gt;function参数地址</span><br></pre></td></tr></table></figure>
<p>而这个function地址就是线程a要执行的函数k_thread_a了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kernel_thread</span><span class="params">(thread_func* function, <span class="keyword">void</span>* func_arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */</span></span><br><span class="line">   intr_enable();</span><br><span class="line">   function(func_arg); </span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">c000156f T k_thread_a</span><br><span class="line">...</span><br><span class="line">(<span class="number">0</span>) [<span class="number">0x000000002cf5</span>] <span class="number">0008</span>:c0002cf5 (unk. ctxt): push dword ptr ss:[ebp+<span class="number">12</span>] ; ff750c</span><br><span class="line">&lt;bochs:<span class="number">91</span>&gt; </span><br><span class="line">Next at t=<span class="number">18217008</span></span><br><span class="line">(<span class="number">0</span>) [<span class="number">0x000000002cf8</span>] <span class="number">0008</span>:c0002cf8 (unk. ctxt): mov eax, dword ptr ss:[ebp+<span class="number">8</span>] ; <span class="number">8b</span>4508</span><br><span class="line">&lt;bochs:<span class="number">92</span>&gt; </span><br><span class="line">Next at t=<span class="number">18217009</span></span><br><span class="line">(<span class="number">0</span>) [<span class="number">0x000000002cfb</span>] <span class="number">0008</span>:c0002cfb (unk. ctxt): call eax                  ; ffd0</span><br><span class="line">...</span><br><span class="line">(<span class="number">0</span>) [<span class="number">0x00000000156f</span>] <span class="number">0008</span>:c000156f (unk. ctxt): push ebp                  ; <span class="number">55</span></span><br></pre></td></tr></table></figure>
<p>这样就完成了一次线程调度。</p>
<h2 id="同步机制-锁"><a href="#同步机制-锁" class="headerlink" title="同步机制-锁"></a>同步机制-锁</h2><p>之前我们提到了，因为不同的线程竞争显存，导致了条件竞争崩溃。</p>
<p>一个“可能是问题”的“少字符”现象，它是由于对公共资源“显存”未实现互斥访问造成的。另一个就是GP异常，它是对公共资源“光标寄存器”未实现互斥访问造成 的。这两个现场过程就是竞争条件。处理器执行指令过程中，即使发生了中断，也会先把当前的指令执行完再处理中断，不会出现指令只执行部分的情况。因此，单条指令的执行具有原子性。</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-032445.png" alt=""><br>所以我们如果在put_str前后先关中断，再开中断，让put_str整体变成一个原子操作（即不会被打断），就不会出现这样的问题<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-032631.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread_a</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread_b</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"I am kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"></span><br><span class="line">   thread_start(<span class="string">"k_thread_a"</span>, <span class="number">31</span>, k_thread_a, <span class="string">"argA "</span>);</span><br><span class="line">   thread_start(<span class="string">"k_thread_b"</span>, <span class="number">8</span>, k_thread_b, <span class="string">"argB "</span>);</span><br><span class="line"></span><br><span class="line">   intr_enable();	<span class="comment">// 打开中断,使时钟中断起作用</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      intr_disable();</span><br><span class="line">      put_str(<span class="string">"Main "</span>);</span><br><span class="line">      intr_enable();</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread_a</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;     </span><br><span class="line"><span class="comment">/* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */</span></span><br><span class="line">   <span class="keyword">char</span>* para = arg;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      intr_disable();</span><br><span class="line">      put_str(para);</span><br><span class="line">      intr_enable();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread_b</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;     </span><br><span class="line"><span class="comment">/* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 */</span></span><br><span class="line">   <span class="keyword">char</span>* para = arg;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      intr_disable();</span><br><span class="line">      put_str(para);</span><br><span class="line">      intr_enable();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样直接在put_str前后加代码只是权宜之计，这就引出了锁的概念。</p>
<h3 id="代码中的临界区、互斥、竞争条件"><a href="#代码中的临界区、互斥、竞争条件" class="headerlink" title="代码中的临界区、互斥、竞争条件"></a>代码中的临界区、互斥、竞争条件</h3><ul>
<li>公共资源<ul>
<li>可以是公共内存、公共文件、公共硬件等，总之是被所有任务共享的一套资源。</li>
</ul>
</li>
<li>临界区<ul>
<li>程序要想使用某些资源，必然通过一些指令去访问这些资源，若多个任务都访问同一公共资源，那么各任务中访问公共资源的指令代码组成的区域就称为临界区。怕有同学看得不仔细，强调一下，<strong>临界区是指程序中那些访问公共资源的指令代码，即临界区是指令，并不是受访的静态公共资源。</strong></li>
</ul>
</li>
<li>互斥<ul>
<li>互斥也可称为排他，是指某一时刻公共资源只能被 1 个任务独享，即不允许多个任务同时出现在自己的临界区中。公共资源在任意时刻只能被一个任务访问，即只能有一个任务在自己的临界区中执行，其他任务想访问公 共资源时，必须等待当前公共资源的访问者完全执行完他自己的临界区代码后(使用完资源后)再开始访问。</li>
</ul>
</li>
<li>竞争条件<ul>
<li>竞争条件是指多个任务以非互斥的方式同时进入临界区，大家对公共资源的访问是以竞争的方式并行进行的，因此公共资源的最终状态依赖于这些任务的临界区中的微操作执行次序。</li>
</ul>
</li>
</ul>
<p>如上我们测试的，关中断是实现互斥最简单的方法，没有之一。</p>
<p>虽然关中断可以实现互斥，但关中断的操作应尽量靠近临界区，这样才更高效，毕竟临界区中的代码才用于访问公共资源，而访问公共资源的时候才需要互斥、排他，各任务临界区之外的代码并不会和其他任务有冲突。关中断操作离临界区越远，多任务调度越低效。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>我们的锁是用信号量来实现的，在计算机中，信号量就是个0以上的整数值，当为0时表示已无可用信号，或者说条件不再允许，因此它表示某种信号的累积“量”，故称为信号量。</p>
<p>虽然信号量听上去和信号相似，像是某种通信机制，但其实它和通信无关，信号量是种同步机制。</p>
<p>既然信号量是计数值，必然要有对计数增减的方法。</p>
<p>增加操作up包括两个微操作。</p>
<ol>
<li>将信号量的值加1。</li>
<li>唤醒在此信号量上等待的线程。</li>
</ol>
<p>减少操作down包括三个子操作。</p>
<ol>
<li>判断信号量是否大于0。</li>
<li>若信号量大于0，则将信号量减1。</li>
<li>若信号量等于0，当前线程将自己阻塞，以在此信号量上等待。</li>
</ol>
<p>信号量是个全局共享变量，up和down又都是读写这个全局变量的操作，而且它们都包含一系列的子操作，因此它们必须都是原子操作。</p>
<p>信号量的初值代表是信号资源的累积量，也就是剩余量，若初值为1的话，它的取值就只能为0和1，这便称为二元信号量，我们可以利用二元信号量来实现锁。</p>
<p>在二元信号量中，down操作就是获得锁，up操作就是释放锁。我们可以让线程通过锁进入临界区，可以借此保证只有一个线程可以进入临界区，从而做到互斥。大致流程为:</p>
<ol>
<li>线程A进入临界区前先通过down操作获得锁(我们有强制通过锁进入临界区的手段)，此时信号量的值便为0。</li>
<li>后续线程B再进入临界区时也通过down操作获得锁，由于信号量为0，线程B便在此信号量上等待，也就是相当于线程B进入了睡眠态。</li>
<li>当线程A从临界区出来后执行up操作释放锁，此时信号量的值重新变成1，之后线程A将线程B唤醒。</li>
<li>线程B醒来后获得了锁，进入临界区。</li>
</ol>
<h3 id="线程的阻塞与唤醒"><a href="#线程的阻塞与唤醒" class="headerlink" title="线程的阻塞与唤醒"></a>线程的阻塞与唤醒</h3><p>我们用函数 thread_block 实现了线程阻塞，用函数 thread_unblock 实现了线程唤醒。</p>
<ul>
<li>thread_block(task_status stat)<ul>
<li>将当前线程的状态置为stat，从而实现线程的阻塞</li>
<li>stat 取值范围是 TASK_BLOCKED、TASK_WAITING 和 TASK_HANGING</li>
<li>请求schedule将自己换下CPU</li>
<li>在调用 schedule 之后，下面的中断状态恢复代码 intr_set_status(old_status)本次便没机会执行了，只有在当前线程被唤醒后才会被执行到。</li>
</ul>
</li>
<li>thread_unblock(pthread)<ul>
<li>参数pthread指向的是目前已经被阻塞，又希望被唤醒的线程</li>
<li>通过list_push将这个被堵塞的线程重新添加到就绪队列最前面，从而保证其被优先调度</li>
<li>最后将线程的status置为TASK_READY。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前线程将自己阻塞,标志其状态为stat. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_block</span><span class="params">(<span class="keyword">enum</span> task_status stat)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/</span></span><br><span class="line">   ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));</span><br><span class="line">   <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   cur_thread-&gt;status = stat; <span class="comment">// 置其状态为stat </span></span><br><span class="line">   schedule();		      <span class="comment">// 将当前线程换下处理器</span></span><br><span class="line"><span class="comment">/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */</span></span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将线程pthread解除阻塞 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_unblock</span><span class="params">(struct task_struct* pthread)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">   ASSERT(((pthread-&gt;status == TASK_BLOCKED) || (pthread-&gt;status == TASK_WAITING) || (pthread-&gt;status == TASK_HANGING)));</span><br><span class="line">   <span class="keyword">if</span> (pthread-&gt;status != TASK_READY) &#123;</span><br><span class="line">      ASSERT(!elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag));</span><br><span class="line">      <span class="keyword">if</span> (elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag)) &#123;</span><br><span class="line">	 PANIC(<span class="string">"thread_unblock: blocked thread in ready_list\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      list_push(&amp;thread_ready_list, &amp;pthread-&gt;general_tag);    <span class="comment">// 放到队列的最前面,使其尽快得到调度</span></span><br><span class="line">      pthread-&gt;status = TASK_READY;</span><br><span class="line">   &#125; </span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h3><ul>
<li>struct semaphore<ul>
<li>信号量要有初值，因此该结构中包含了成员value，对信号量进行down操作时，若信号量值为0就会阻塞线程</li>
<li>waiters，用它来记录在此信号量上等待(阻塞)的所有线程。</li>
</ul>
</li>
<li>struct lock<ul>
<li>谁成功申请了锁，就应该记录锁被谁持有，这是用成员holder记录的，表示锁的持有者。</li>
<li>锁结构中必须包含一个信号量成员，这里就是semaphore，它就是信号量结构体struct semaphore实例。将来此信号量的初值会被赋值为1，也就是用二元信号量实现锁。</li>
<li>holder_repeat_nr用来累积锁的持有者重复申请锁的次数，释放锁的时候会参考此变量的值。原因是一般情况下我们应该在进入临界区之前加锁，但有时候可能持有了某临界区的锁后，在未释放锁之前，有可能会再次调用重复申请此锁的函数，这样一来，内外层函数在释放锁时会对同一个锁释放两次，为了避免这种情况的发生，用此变量来累积重复申请的次数，释放锁时会根据变量holder_repeat_nr的值来执行具体动作。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sync.h</span></span><br><span class="line"><span class="comment">/* 信号量结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  value;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">list</span> <span class="title">waiters</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 锁结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">task_struct</span>* <span class="title">holder</span>;</span>	    <span class="comment">// 锁的持有者</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">semaphore</span> <span class="title">semaphore</span>;</span>	    <span class="comment">// 用二元信号量实现锁</span></span><br><span class="line">   <span class="keyword">uint32_t</span> holder_repeat_nr;		    <span class="comment">// 锁的持有者重复申请锁的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span><span class="params">(struct semaphore* psema, <span class="keyword">uint8_t</span> value)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_down</span><span class="params">(struct semaphore* psema)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_up</span><span class="params">(struct semaphore* psema)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(struct lock* plock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_acquire</span><span class="params">(struct lock* plock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_release</span><span class="params">(struct lock* plock)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sema_init<ul>
<li>初始化信号量</li>
<li>为信号量赋初值</li>
<li>初始化信号量的等待队列</li>
</ul>
</li>
<li>sema_down<ul>
<li>信号量down操作</li>
<li>关中断来保证原子操作</li>
<li>当信号量的值为1时，down操作才会成功返回，否则就在该信号上阻塞。这里通过<code>while(psema-&gt;value == 0)</code>判断信号量是否为0，如果为0，就进入while的循环体做两件事。<ul>
<li>将自己添加到该信号量的等待队列中。</li>
<li>将自己阻塞，状态为TASK_BLOCKED</li>
<li>这里之所以用<code>while(psema-&gt;value == 0)</code>判断而不是<code>if(psema-&gt;value == 0)</code>是因为锁本身也是公共的资源，想要获得锁的线程不止一个，当阻塞的线程被唤醒后，也只是再次获得了去竞争锁的机会而已。</li>
</ul>
</li>
<li>恢复之前的中断状态</li>
</ul>
</li>
<li>sema_up<ul>
<li>关中断，保证原子操作</li>
<li>sema_up是使信号量加1，这表示有信号资源可用了，也就是其他线程可以申请锁了</li>
<li>从信号量的等待队列里弹出队首线程，并通过thread_unblock(thread_blocked)将此线程唤醒，提醒一下，所谓的唤醒并不是指马上就运行，而是重新加入到就绪队列，将来可以参与调度，运行是将来的事。而且当前是在关中断的情况下，所以调度器并不会被触发。因此不用担心线程已经加到就绪队列中，但value的值还没变成1会导致出错。</li>
</ul>
</li>
<li>lock_acquire(plock)<ul>
<li>plock是要获取的锁，函数功能是获取锁plock</li>
<li><strong>有时候，线程可能会嵌套申请同一把锁，这种情况下再申请锁，就会形成死锁，即自己在等待自己释放锁</strong></li>
<li>因此，在函数开头先判断自己是否已经是该锁的持有者，即代码<code>if(plock-&gt;holder != running_thread())</code>。如果持有者已经是自己，就将变量holder_repeat_nr++，除此之外什么都不做，然后函数返回。</li>
<li>如果自己尚未持有此锁的话，通过sema_down(&amp;plock-&gt;semaphore)将锁的信号量减1</li>
<li>成功后将当前线程记为锁的持有者，即 <code>plock-&gt;holder = running_thread()</code>，然后将holder_repeat_nr置为 1，表示第1次申请了该锁。</li>
</ul>
</li>
<li>lock_release(plock)<ul>
<li>plock指向待释放的锁,函数功能是释放锁 plock,当前线程应该是锁的持有者</li>
<li>如果持有者的变量holder_repeat_nr 大于 1，这说明自已多次申请该锁，此时还不能真正将锁释放，因此只是将holder_repeat_nr–，随后返回。</li>
<li>如果锁持有者的变量holder_repeat_nr为 1，说明现在可以释放锁了，通过代码 <code>plock-&gt;holder = NULL</code>将持有者置空，随后将holder_repeat_nr置为0</li>
<li>最后通过<code>sema_up(&amp;plock-&gt;semaphore)</code>将信号量加1</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sync.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化信号量 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span><span class="params">(struct semaphore* psema, <span class="keyword">uint8_t</span> value)</span> </span>&#123;</span><br><span class="line">   psema-&gt;value = value;       <span class="comment">// 为信号量赋初值</span></span><br><span class="line">   list_init(&amp;psema-&gt;waiters); <span class="comment">//初始化信号量的等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化锁plock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(struct lock* plock)</span> </span>&#123;</span><br><span class="line">   plock-&gt;holder = <span class="literal">NULL</span>;</span><br><span class="line">   plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">   sema_init(&amp;plock-&gt;semaphore, <span class="number">1</span>);  <span class="comment">// 信号量初值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量down操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_down</span><span class="params">(struct semaphore* psema)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 关中断来保证原子操作 */</span></span><br><span class="line">   <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">   <span class="keyword">while</span>(psema-&gt;value == <span class="number">0</span>) &#123;	<span class="comment">// 若value为0,表示已经被别人持有</span></span><br><span class="line">      ASSERT(!elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag));</span><br><span class="line">      <span class="comment">/* 当前线程不应该已在信号量的waiters队列中 */</span></span><br><span class="line">      <span class="keyword">if</span> (elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag)) &#123;</span><br><span class="line">	 PANIC(<span class="string">"sema_down: thread blocked has been in waiters_list\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */</span></span><br><span class="line">      list_append(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag); </span><br><span class="line">      thread_block(TASK_BLOCKED);    <span class="comment">// 阻塞线程,直到被唤醒</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/</span></span><br><span class="line">   psema-&gt;value--;</span><br><span class="line">   ASSERT(psema-&gt;value == <span class="number">0</span>);	    </span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量的up操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_up</span><span class="params">(struct semaphore* psema)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 关中断,保证原子操作 */</span></span><br><span class="line">   <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">   ASSERT(psema-&gt;value == <span class="number">0</span>);	    </span><br><span class="line">   <span class="keyword">if</span> (!list_empty(&amp;psema-&gt;waiters)) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread_blocked</span> = <span class="title">elem2entry</span>(<span class="title">struct</span> <span class="title">task_struct</span>, <span class="title">general_tag</span>, <span class="title">list_pop</span>(&amp;<span class="title">psema</span>-&gt;<span class="title">waiters</span>));</span></span><br><span class="line">      thread_unblock(thread_blocked);</span><br><span class="line">   &#125;</span><br><span class="line">   psema-&gt;value++;</span><br><span class="line">   ASSERT(psema-&gt;value == <span class="number">1</span>);	    </span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取锁plock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_acquire</span><span class="params">(struct lock* plock)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 排除曾经自己已经持有锁但还未将其释放的情况。*/</span></span><br><span class="line">   <span class="keyword">if</span> (plock-&gt;holder != running_thread()) &#123; </span><br><span class="line">      sema_down(&amp;plock-&gt;semaphore);    <span class="comment">// 对信号量P操作,原子操作</span></span><br><span class="line">      plock-&gt;holder = running_thread();</span><br><span class="line">      ASSERT(plock-&gt;holder_repeat_nr == <span class="number">0</span>);</span><br><span class="line">      plock-&gt;holder_repeat_nr = <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      plock-&gt;holder_repeat_nr++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放锁plock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_release</span><span class="params">(struct lock* plock)</span> </span>&#123;</span><br><span class="line">   ASSERT(plock-&gt;holder == running_thread());</span><br><span class="line">   <span class="keyword">if</span> (plock-&gt;holder_repeat_nr &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      plock-&gt;holder_repeat_nr--;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ASSERT(plock-&gt;holder_repeat_nr == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   plock-&gt;holder = <span class="literal">NULL</span>;	   <span class="comment">// 把锁的持有者置空放在V操作之前</span></span><br><span class="line">   plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">   sema_up(&amp;plock-&gt;semaphore);	   <span class="comment">// 信号量的V操作,也是原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们用我们实现的锁重写输出函数，让它变成原子的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"console.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sync.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread.h"</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">console_lock</span>;</span>    <span class="comment">// 控制台锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化终端 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">console_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lock_init(&amp;console_lock); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取终端 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">console_acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   lock_acquire(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放终端 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">console_release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   lock_release(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端中输出字符串 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">console_put_str</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">   console_acquire(); </span><br><span class="line">   put_str(str); </span><br><span class="line">   console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端中输出字符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">console_put_char</span><span class="params">(<span class="keyword">uint8_t</span> char_asci)</span> </span>&#123;</span><br><span class="line">   console_acquire(); </span><br><span class="line">   put_char(char_asci); </span><br><span class="line">   console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端中输出16进制整数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">console_put_int</span><span class="params">(<span class="keyword">uint32_t</span> num)</span> </span>&#123;</span><br><span class="line">   console_acquire(); </span><br><span class="line">   put_int(num); </span><br><span class="line">   console_release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-10-14-094754.png" alt=""></p>
<h2 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/23/afl/" rel="next" title="sakuraのAFL源码全注释">
                <i class="fa fa-chevron-left"></i> sakuraのAFL源码全注释
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2099/09/18/study/" rel="prev" title="Sakuraのdiary">
                Sakuraのdiary <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/sakura_heart.png"
                alt="sakura" />
            
              <p class="site-author-name" itemprop="name">sakura</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">101</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/eternalsakura" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:eternalsakura13@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/sakura1328/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/eternalsakura13" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://exp101t.blogspot.com/" title="Murasaki" target="_blank">Murasaki</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://elphet.blogspot.com" title="bobb" target="_blank">bobb</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://thunderjie.github.io/" title="Thunderj" target="_blank">Thunderj</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://dwfault.github.io/" title="dwfalut" target="_blank">dwfalut</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://p1umer.github.io/" title="P1umer" target="_blank">P1umer</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://pcat.cc/" title="pcat" target="_blank">pcat</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#环境配置"><span class="nav-number">1.</span> <span class="nav-text">环境配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写BootLoader"><span class="nav-number">2.</span> <span class="nav-text">编写BootLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识"><span class="nav-number">2.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MBR"><span class="nav-number">2.2.</span> <span class="nav-text">MBR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loader-进入保护模式"><span class="nav-number">2.3.</span> <span class="nav-text">loader-进入保护模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loader-启用分页机制"><span class="nav-number">2.4.</span> <span class="nav-text">loader-启用分页机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loader-加载内核"><span class="nav-number">2.5.</span> <span class="nav-text">loader-加载内核</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#elf文件格式"><span class="nav-number">2.5.1.</span> <span class="nav-text">elf文件格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核加载步骤"><span class="nav-number">2.5.2.</span> <span class="nav-text">内核加载步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特权级"><span class="nav-number">3.</span> <span class="nav-text">特权级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特权级转移"><span class="nav-number">3.1.</span> <span class="nav-text">特权级转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPL和DPL"><span class="nav-number">3.2.</span> <span class="nav-text">CPL和DPL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPL"><span class="nav-number">3.3.</span> <span class="nav-text">RPL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断"><span class="nav-number">4.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#汇编基础"><span class="nav-number">4.1.</span> <span class="nav-text">汇编基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数调用约定"><span class="nav-number">4.1.1.</span> <span class="nav-text">函数调用约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用-syscall-传递参数的方式-x86"><span class="nav-number">4.1.2.</span> <span class="nav-text">系统调用(syscall)传递参数的方式(x86)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断的分类"><span class="nav-number">4.2.</span> <span class="nav-text">中断的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外部中断"><span class="nav-number">4.2.1.</span> <span class="nav-text">外部中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部中断"><span class="nav-number">4.2.2.</span> <span class="nav-text">内部中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断向量"><span class="nav-number">4.3.</span> <span class="nav-text">中断向量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断向量和中断向量表-IVT"><span class="nav-number">4.3.1.</span> <span class="nav-text">中断向量和中断向量表(IVT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断描述符表"><span class="nav-number">4.3.2.</span> <span class="nav-text">中断描述符表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断处理"><span class="nav-number">4.4.</span> <span class="nav-text">中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断处理的过程和权限检查"><span class="nav-number">4.4.1.</span> <span class="nav-text">中断处理的过程和权限检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断处理程序执行时的栈变化和上下文保存"><span class="nav-number">4.4.2.</span> <span class="nav-text">中断处理程序执行时的栈变化和上下文保存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误码"><span class="nav-number">4.4.3.</span> <span class="nav-text">错误码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现中断"><span class="nav-number">4.5.</span> <span class="nav-text">实现中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理系统"><span class="nav-number">5.</span> <span class="nav-text">内存管理系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#makefile"><span class="nav-number">5.1.</span> <span class="nav-text">makefile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现assert和字符串处理函数"><span class="nav-number">5.2.</span> <span class="nav-text">实现assert和字符串处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位图bitmap"><span class="nav-number">5.3.</span> <span class="nav-text">位图bitmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存池的规划"><span class="nav-number">5.4.</span> <span class="nav-text">内存池的规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配页内存"><span class="nav-number">5.5.</span> <span class="nav-text">分配页内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">6.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行流"><span class="nav-number">6.1.</span> <span class="nav-text">执行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的作用"><span class="nav-number">6.2.</span> <span class="nav-text">线程的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和线程的关系"><span class="nav-number">6.3.</span> <span class="nav-text">进程和线程的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程-线程的状态"><span class="nav-number">6.4.</span> <span class="nav-text">进程&#x2F;线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB-程序控制块"><span class="nav-number">6.5.</span> <span class="nav-text">PCB(程序控制块)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的两种实现方式"><span class="nav-number">6.6.</span> <span class="nav-text">线程的两种实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在内核中实现线程"><span class="nav-number">6.7.</span> <span class="nav-text">在内核中实现线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核数据结构，双向链表"><span class="nav-number">6.8.</span> <span class="nav-text">内核数据结构，双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单优先级调度的准备"><span class="nav-number">6.9.</span> <span class="nav-text">简单优先级调度的准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务调度器和任务切换"><span class="nav-number">6.10.</span> <span class="nav-text">任务调度器和任务切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时钟中断处理函数"><span class="nav-number">6.10.1.</span> <span class="nav-text">时钟中断处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现调度器schedule"><span class="nav-number">6.10.2.</span> <span class="nav-text">实现调度器schedule</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现任务切换函数switch-to"><span class="nav-number">6.10.3.</span> <span class="nav-text">实现任务切换函数switch_to</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启用线程调度用运行"><span class="nav-number">6.10.4.</span> <span class="nav-text">启用线程调度用运行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步机制-锁"><span class="nav-number">7.</span> <span class="nav-text">同步机制-锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码中的临界区、互斥、竞争条件"><span class="nav-number">7.1.</span> <span class="nav-text">代码中的临界区、互斥、竞争条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-number">7.2.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的阻塞与唤醒"><span class="nav-number">7.3.</span> <span class="nav-text">线程的阻塞与唤醒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的实现"><span class="nav-number">7.4.</span> <span class="nav-text">锁的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户进程"><span class="nav-number">8.</span> <span class="nav-text">用户进程</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sakura</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'oSjxVuchxdK82iyIiuzHtfiV-gzGzoHsz',
        appKey: 'MK8tCWwU3RWlWQdEA0wOH8Dw',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("oSjxVuchxdK82iyIiuzHtfiV-gzGzoHsz", "MK8tCWwU3RWlWQdEA0wOH8Dw");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
